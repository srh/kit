import ast;
import deferred;
import expr;
import kitutil;
import parse;
import tok;
import typeexpr;
import shray;
import shp;
import state;
import u8ast;

// This code does some typechecking.  See state.ki for types that maintain typechecking state.


func finish_checking(cs *checkstate, clq *clqueue) np {
  check(cs->instantiation_depth == 0);
  while case Has(entry clqueue_entry) = popval(&clq->entries) {
    switch &entry {
      case &ClqDeftypeEntry(e clqueue_deftype_entry): {
        rw depth_rewinder;
        #set_instantiation_depth(cs, e.instantiation_depth, &rw);
        #ensure_deftype_inst_checked(clq, e.ent_id, e.inst_id);
      }
      case &ClqDefEntry(e clqueue_def_entry): {
        rw depth_rewinder;
        #set_instantiation_depth(cs, e.instantiation_depth, &rw);
        // NOTE: It would be nice if checking/graphing, and evaling, were done in separate phases as much as possible.
        val_discard *st_value;
        #ensure_def_inst_evaled(clq, e.ent_id, e.inst_id, &val_discard);
      }
    }
  }
  return NoFail;
}

func check_module(cs *checkstate, mod_name sym) np {
  id module_id = #process_module(cs, mod_name);
  mod *module = ref_module(cs, id);

  naccess_blocks size = count(&mod->access_blocks);
  for i size = 0; i < naccess_blocks; i = i + 1 {
    dti deftype_entry_id;
    #get_accessible_deftype(cs, mod->access_blocks[i], &dti);
  }

  ndefs size = count(&mod->defs);
  for i size = 0; i < ndefs; i = i + 1 {
    #ensure_def_checked(cs, mod->defs[i]);
  }

  ndeftypes size = count(&mod->deftypes);
  for i size = 0; i < ndeftypes; i = i + 1 {
    #ensure_deftype_checked(cs, mod->deftypes[i]);
  }

  // I guess that's everything.
  return NoFail;
}

func convert_typefunc(a *ast_typeexpr) cr[te_puretype] {
  switch a {
  case &Name(b ast_ident):
    return NoFail!@[te_puretype]TePureName(b.value);
  case &Unknown(b ast_unknown):
    return NoFail!@[te_puretype]TePureUnknown;
  default:
    return ERR(_u8("Fancy type expression '"), to_u8str(a), _u8("' in typefunc"));
  }
}

func convert_typeexpr_list(arr *array[ast_typeexpr]) cr[shray[te_typeexpr]] {
  build array[te_typeexpr];
  n size = count(arr);
  reserve(&build, n);
  for i size = 0; i < n; i = i + 1 {
    t te_typeexpr = #convert_typeexpr(&arr[i]);
    push(&build, t);
  }
  return NoFail!freeze(&build);
}

func convert_vardecl_list(arr *array[ast_vardecl]) cr[shray[te_vardecl]] {
  build array[te_vardecl];
  n size = count(arr);
  reserve(&build, n);
  for i size = 0; i < n; i = i + 1 {
    vd te_vardecl = #convert_vardecl(&arr[i]);
    push(&build, vd);
  }
  return NoFail!freeze(&build);
}

func convert_defenum_constructor_list(arr *array[ast_defenum_constructor], decls_out *array[te_vardecl], success_case_ix_out *opt[size]) np {
  build array[te_vardecl];
  n size = count(arr);
  reserve(&build, n);
  success_case_ix opt[size] = None;
  for i size = 0; i < n; i = i + 1 {
    elem *ast_defenum_constructor = ref(arr, i);
    vd te_vardecl = #convert_vardecl(&elem->decl);
    if case SuccessCase = elem->disposition {
      // Parsing's supposed to only allow one success case, this assert verifies.
      set(&success_case_ix, i);
    }
    push(&build, vd);
  }
  swap(decls_out, &build);
  *success_case_ix_out = success_case_ix;
  return NoFail;
}

func convert_vardecl(a *ast_vardecl) cr[te_vardecl] {
  type te_typeexpr = #convert_typeexpr(&a->type);
  return NoFail!{a->name.value, type};
}

// NOTE: This could probably lookup names, check arity, in a defscope, etc.
func convert_typeexpr(a *ast_typeexpr) cr[te_typeexpr] {
  switch a {
  case &Name(b ast_ident):
    return NoFail!@[te_typeexpr]TeName({b.value, None});
  case &App(b ast_typeapp):
    typefunc te_puretype = #convert_typefunc(oo(&b.typefunc));
    params shray[te_typeexpr] = #convert_typeexpr_list(&b.params);
    return NoFail!@[te_typeexpr]TeApp({typefunc, params, None});
  case &Union(b ast_union):
    fields shray[te_vardecl] = #convert_vardecl_list(&b.fields);
    return NoFail!@[te_typeexpr]TeUnion({fields});

  case &Arraytype(b ast_arraytype):
    count opt[u32];
    if case &Has(bo box[ast_expr]) = &b.count {
      num u32;
      #fake_eval_arraytype_count(oo(&bo), &num);
      count = Has(num);
    } else {
      count = None;
    }
    param shp[te_typeexpr];
    *oo(&param) = #convert_typeexpr(oo(&b.param));
    return NoFail!@[te_typeexpr]TeArraytype({count, param});
  case &Unknown(b ast_unknown):
    return NoFail!@[te_typeexpr]TeUnknown;
  }
}

// TODO: Nothing uses cs.  (So remove it.)
func def_converted_typeexpr(cs *checkstate, ent *def_entry, out **te_typeexpr) np {
  switch &ent->converted_typeexpr {
    case &NotComputed: {
      ent->converted_typeexpr = BeganComputing;
      switch &ent->definition {
        case &DefnPrim(op primitive_op): {
          ice(_u8("def_entry for primitive has converted_typeexpr NotComputed."));
          return fake();
        }
        case &DefnHasRhs(np def_nonprim): {
          switch convert_typeexpr(&np.quick_typeexpr) {
          case Printed(pm):
            ent->converted_typeexpr = FailedComputation;
            return Printed(pm);
          case NoFail(converted te_typeexpr):
            ent->converted_typeexpr = Computed(converted);
          }
          if case &Computed(te te_typeexpr) = &ent->converted_typeexpr {
            *out = &te;
          } else {
            crash(_u8("impossible converted_typeexpr"));
          }
          return NoFail;
        }
        case &DefnNonMagic(mag def_non_magic): {
          ice(_u8("def_entry for \"non_magic\" implementation has converted_typeexpr NotComputed."));
          return fake();
        }
        case &DefnMagic(mag def_magic): {
          ice(_u8("ICE: def_entry for magic implementation has converted_typeexpr NotComputed."));
          return fake();
        }
      }
    }
    case &BeganComputing: {
      return ERR(_u8("recursively computing def's typeexpr"));
    }
    case &FailedComputation: {
      return ERR(_u8("repeat of error in def_converted_typeexpr"));
    }
    case &Computed(x te_typeexpr): {
      *out = &x;
      return NoFail;
    }
  }
}

// TODO: cs is not used.  (So remove it?)
func deftype_converted_rhs(cs *checkstate, np *deftype_nonprim, out **deftype_rhs_spec) np {
  switch &np->rhs {
    case &NotComputed: {
      np->rhs = BeganComputing;
      switch &np->tl->rhs {
      case &ClassexprRhs(a ast_classexpr_rhs):
        switch convert_vardecl_list(&a.fields) {
        case Printed(pm):
          np->rhs = FailedComputation;
          return Printed(pm);
        case NoFail(fields shray[te_vardecl]):
          np->rhs = Computed(@[deftype_rhs_spec]ClassexprRhsSpec({a.disposition, {fields}}));
        }
        if case &Computed(b deftype_rhs_spec) = &np->rhs {
          *out = &b;
        } else {
          crash(_u8("impossible rhs"));
        }
        return NoFail;
      case &DefstructRhs(a ast_defstruct_rhs):
        switch convert_vardecl_list(&a.fields) {
        case Printed(pm):
          np->rhs = FailedComputation;
          return Printed(pm);
        case NoFail(fields shray[te_vardecl]):
          np->rhs = Computed(@[deftype_rhs_spec]DefstructRhsSpec({fields}));
        }
        if case &Computed(b deftype_rhs_spec) = &np->rhs {
          *out = &b;
        } else {
          crash(_u8("impossible rhs"));
        }
        return NoFail;
      case &DefenumRhs(a ast_defenum_rhs):
        success_case_ix opt[size];
        constructors array[te_vardecl];
        if case Printed(pm) = convert_defenum_constructor_list(&a.constructors, &constructors, &success_case_ix) {
          np->rhs = FailedComputation;
          return Printed(pm);
        }
        np->rhs = Computed(@[deftype_rhs_spec]DefenumRhsSpec({freeze(&constructors), success_case_ix}));
        if case &Computed(b deftype_rhs_spec) = &np->rhs {
          *out = &b;
        } else {
          crash(_u8("impossible rhs"));
        }
        return NoFail;
      }
    }
    case &BeganComputing: {
      return ERR(_u8("recursively computing deftype's rhs"));
    }
    case &FailedComputation: {
      return ERR(_u8("repeat of error in deftype_converted_rhs"));
    }
    case &Computed(x deftype_rhs_spec): {
      *out = &x;
      return NoFail;
    }
  }
}

func enqueue_def_inst(clq *clqueue, id def_entry_id, parms *idy_genparms) def_inst_id {
  cs *checkstate = clq->cs;
  res id_and_created = ensure_def_inst(cs, ref_def_entry(cs, id), parms);
  if res.created {
    push(&clq->entries, @[clqueue_entry]ClqDefEntry({id, res.id, cs->instantiation_depth}));
  }
  return res.id;
}

struct id_and_created {
  id def_inst_id;
  created bool;
}

// rhs is "None" for extern defs and primitive defs.
func ensure_def_inst(cs *checkstate, ent *def_entry, parms *idy_genparms) id_and_created {
  if case Has(id def_inst_id) = lookup(&ent->insts, parms) {
    return {id, false};
  }
  rhs def_inst_rhs;
  switch &ent->definition {
    case &DefnPrim(op primitive_op):
      rhs = InstRhsPrim(op);
    case &DefnHasRhs(np def_nonprim):
      switch np.tl {
        case &Def(a ast_def): {
          rhs = InstRhsExpr({a.rhs, NotComputed});
        }
        case &ExternDef(a ast_extern_def): { rhs = InstRhsExtern; }
        default: {
          ice(_u8("def_entry has invalid toplevel\n"));
        }
      }
    case &DefnNonMagic(nonmag def_non_magic):
      rhs = InstRhsNonMagic(nonmag);
    case &DefnMagic(mag def_magic):
      rhs = InstRhsMagic(mag);
  }
  id def_inst_id = add_inst(cs, mk(*parms, rhs));
  check_insert(&ent->insts, parms, id);
  return {id, true};
}

// Outputs a stable pointer.
func ensure_def_inst_type_computed(cs *checkstate, clq *clqueue, ent *def_entry, inst_id def_inst_id, out **cu_typrop) np {
  inst *def_inst = ref_inst(cs, inst_id);
  switch &inst->typrop {
    case &NotComputed: {
      rw depth_rewinder;
      #set_instantiation_depth(cs, subsequent_depth(cs, &inst->parms.repls), &rw);
      inst->typrop = BeganComputing;

      ent_typeexpr *te_typeexpr;
      if case Printed(pm) = def_converted_typeexpr(cs, ent, &ent_typeexpr) {
        inst->typrop = FailedComputation;
        return Printed(pm);
      }

      // Important:  We check the typeexpr first.  If that typeexpr cyclically refers to this def, we fail.  If there is no typeexpr, we need to compute it from the rhs (and that also needs to not depend cyclically on this def's own typeexpr).
      computed cac_typeexpr;
      if case Printed(pm) = check_and_compute_typeexpr(clq, &ent->generics, &inst->parms.repls, ent_typeexpr, &computed) {
        inst->typrop = FailedComputation;
        return Printed(pm);
      }
      check(computed.complete);
      props type_properties;
      cu_computed cu_typeexpr = ~computed.te;
      if case Printed(pm) = compute_type_properties(clq, &cu_computed, &props) {
        inst->typrop = FailedComputation;
        return Printed(pm);
      }
      if !is_defwise_trivial(&props) {
        inst->typrop = FailedComputation;
        return ERR(_u8("def (instantiation) has non-trivial type"));
      }

      inst->typrop = Computed({cu_computed, props});
      *out = un(&inst->typrop);
      return NoFail;
    }
    case &BeganComputing: {
      return ERR(_u8("computing def's type arouses cyclic dependency "), lookup(cs->im, ent->def_name));
    }
    case &FailedComputation: {
      return ERR(_u8("revisiting def's type after failure for "), lookup(cs->im, ent->def_name));
    }
    case &Computed(typr cu_typrop): {
      *out = &typr;
      return NoFail;
    }
  }
}

func ensure_def_inst_checked(cs *checkstate, clq *clqueue, ent_id def_entry_id, inst_id def_inst_id) np {
  ent *def_entry = ref_def_entry(cs, ent_id);
  typrop *cu_typrop;
  #ensure_def_inst_type_computed(cs, clq, ent, inst_id, &typrop);
  inst *def_inst = ref_inst(cs, inst_id);
  switch inst->rhs_status {
    case DidNotCheckRhs: {
      rw depth_rewinder;
      #set_instantiation_depth(cs, subsequent_depth(cs, &inst->parms.repls), &rw);
      inst->rhs_status = BeganCheckingRhs;
      switch &inst->rhs {
        case &InstRhsPrim(op primitive_op): {
          // Do nothing.
        }
        case &InstRhsExtern: {
          // Do nothing.
        }
        case &InstRhsExpr(rhs def_inst_rhs_expr): {
          info frame_info;
          #check_def_expr(clq, ent->accessible, &ent->generics, &inst->parms.repls, &rhs.ec, &typrop->cu.x, ent->def_name, &info);
          annotate(&rhs.frame_info, move(&info));
        }
        case &InstRhsNonMagic(nonmag def_non_magic): {
          #check_non_magic(clq, &ent->generics, &inst->parms.repls, &nonmag);
        }
        case &InstRhsMagic(mag def_magic): {
          #check_magic(clq, &ent->generics, &inst->parms.repls, &mag);
        }
      }
      inst->rhs_status = FinishedCheckingRhs;
      return NoFail;
    }
    case BeganCheckingRhs: {
      return NoFail;
    }
    case FinishedCheckingRhs: {
      return NoFail;
    }
  }
}

// parms have already had generics replaced.  They should also be complete.
func check_and_compute_parms_no_canonicalize(clq *clqueue, t *genparms, out *idy_repls) np {
  switch t {
    case &NoParms: {
      *out = blank_idyrepls();
      return NoFail;
    }
    case &HasParms(ps shray[te_typeexpr]): {
      noscope_g ast_generics = NoGenerics;
      noscope_parms idy_repls = blank_idyrepls();
      params_complete bool;
      params shray[te_typeexpr];
      #check_and_compute_typeexpr_shray(clq, &noscope_g, &noscope_parms, &ps, &params, &params_complete);

      if !params_complete {
        ice(_u8("check_and_compute_parms sees incomplete typeexpr"));
      }

      // TODO: Isn't there some function mapconvert for this?
      cu_params array[cu_typeexpr];
      n size = count(&params);
      reserve(&cu_params, n);
      for i size = 0; i < n; i = i + 1 {
        push(&cu_params, ~params[i]);
      }
      *out = {freeze(&cu_params)};
      return NoFail;
    }
  }
}

func mapconvert(x *shray[te_typeexpr]) shray[cu_typeexpr] {
  bu array[cu_typeexpr];
  n size = count(x);
  for i size = 0; i < n; i = i + 1 {
    push(&bu, ~*ref(x, i));
  }
  return freeze(&bu);
}


// parms have already had generics replaced.  They should also be complete.
func check_and_compute_parms(clq *clqueue, t *genparms, out *idy_genparms) np {
  switch t {
    case &NoParms: {
      *out = blank_idyparms();
      return NoFail;
    }
    case &HasParms(ps shray[te_typeexpr]): {
      noscope_g ast_generics = NoGenerics;
      noscope_parms idy_repls = blank_idyrepls();
      params_complete bool;
      params shray[te_typeexpr];
      #check_and_compute_typeexpr_shray(clq, &noscope_g, &noscope_parms, &ps, &params, &params_complete);

      if !params_complete {
        ice(_u8("check_and_compute_parms sees incomplete typeexpr"));
      }

      cu_params shray[cu_typeexpr] = mapconvert(&params);
      *out = {{cu_params}};
      return NoFail;
    }
  }
}

func noscoped_check_and_compute_typeexpr(clq *clqueue, t *te_typeexpr, out *cac_typeexpr) np {
  ng ast_generics = NoGenerics;
  np idy_repls = blank_idyrepls();
  return check_and_compute_typeexpr(clq, &ng, &np, t, out);
}

// NOTE: Generics replacement should really be a separate phase.  (Why?)  (Performance is one counter-argument -- we'd create an extra intermediate te_typeexpr.)
func check_and_compute_typeexpr(clq *clqueue, g *ast_generics, parms *idy_repls, t *te_typeexpr, out *cac_typeexpr) np {
  switch t {
    case &TeName(a te_name): {
      computed cu_typeexpr;
      #check_and_compute_name_type(clq, g, parms, &a, &computed);
      *out = {true, computed.x};
      return NoFail;
    }
    case &TeApp(a te_typeapp): {
      #check_and_compute_app_type(clq, g, parms, &a, out);
      return NoFail;
    }

    case &TeUnion(a te_union): {
      computed_fields_complete bool;
      computed_fields array[te_vardecl];
      #help_check_and_compute_fields(clq, g, parms, &a.fields, &computed_fields, &computed_fields_complete);
      *out = {computed_fields_complete, TeUnion({freeze(&computed_fields)})};
      return NoFail;
    }

    case &TeArraytype(a te_arraytype): {
      param cac_typeexpr;
      #check_and_compute_typeexpr(clq, g, parms, oo(&a.param), &param);
      *out = {param.complete && isHas(&a.count), TeArraytype({a.count, emshp(param.te)})};
      return NoFail;
    }

    case &TeUnknown: {
      *out = {false, TeUnknown};
      return NoFail;
    }
  }
}

func numeric_literal_to_u32(x *ast_numeric_literal, out *u32) bool {
  switch x {
    case &HexLiteral(a ast_hex_literal): {
      return convert_to_u32(16, &a.digits, out);
    }
    case &DecLiteral(a ast_dec_literal): {
      return convert_to_u32(10, &a.digits, out);
    }
  }
}

func convert_to_u32(base i8, digits *shray[i8], out *u32) bool {
  check(base > 0);
  acc u32 = 0;
  n size = count(digits);
  for i size = 0; i < n; i = i + 1 {
    if !try_mul(acc, @[u32]~base, &acc) {
      return false;
    }
    if !try_add(acc, @[u32]~digits[i], &acc) {
      return false;
    }
  }
  *out = acc;
  return true;
}

func fake_eval_arraytype_count(x *ast_expr, count_out *u32) np {
  // NOTE: Remove this function and really evaluate an array's count expression.
  switch &x->u {
  case &NumericLiteral(a ast_numeric_literal):
    if !numeric_literal_to_u32(&a, count_out) {
      return ERR(_u8("Numeric literal out of range for array length"));
    }
    return NoFail;
  default:
    return ERR(_u8("Array types (for now) must have a numeric literal for length (or _)."));
  }
}

func help_check_and_compute_fields(clq *clqueue, g *ast_generics, parms *idy_repls, a *shray[te_vardecl], computed_fields_out *array[te_vardecl], computed_fields_complete_out *bool) np {
  n size = count(a);
  all_complete bool = true;
  all_computed array[te_vardecl];
  for i size = 0; i < n; i = i + 1 {
    decl *te_vardecl = &a[i];
    for j size = 0; j < i; j = j + 1 {
      if a[j].name.x == decl->name.x {
        return ERR(_u8("Duplicate field name "), lookup(clq->im, decl->name));
      }
    }
    computed cac_typeexpr;
    #check_and_compute_typeexpr(clq, g, parms, &decl->type, &computed);
    all_complete = all_complete & computed.complete;
    push(&all_computed, {decl->name, computed.te});
  }
  swap(computed_fields_out, &all_computed);
  *computed_fields_complete_out = all_complete;
  return NoFail;
}

func check_and_compute_name_type(clq *clqueue, g *ast_generics, parms *idy_repls, a *te_name, computed_out *cu_typeexpr) np {
  // Generic parameters have already been checked.  (I hope so.)
  if lookup_plain_generic(g, parms, a->value, computed_out) {
    return NoFail;
  }

  if isHas(&a->pack) {
    *computed_out = ~@[te_typeexpr]TeName(*a);
    return NoFail;
  }

  id deftype_entry_id;
  #match_deftype(clq->cs, fake_ast_meta(), a->value, None, &id);

  np idy_genparms = blank_idyparms();
  inst_id deftype_inst_id = enqueue_deftype_inst(clq, id, &np);
  *computed_out = ~ @[te_typeexpr]TeName({a->value, Has({id, inst_id})});
  return NoFail;
}

func check_and_compute_typeexpr_shray(clq *clqueue, g *ast_generics, parms *idy_repls, t *shray[te_typeexpr], computed_out *shray[te_typeexpr], computed_complete_out *bool) np {
  complete bool = true;
  computed array[te_typeexpr];
  n size = count(t);
  reserve(&computed, n);
  for i size = 0; i < n; i = i + 1 {
    c cac_typeexpr;
    #check_and_compute_typeexpr(clq, g, parms, ref(t, i), &c);
    push(&computed, c.te);
    complete = complete & c.complete;
  }
  *computed_out = freeze(&computed);
  *computed_complete_out = complete;
  return NoFail;
}

func check_and_compute_app_type(clq *clqueue, g *ast_generics, parms *idy_repls, a *te_typeapp, out *cac_typeexpr) np {
  if isHas(&a->pack) {
    *out = {true, TeApp(*a)};
    return NoFail;
  }

  params_complete bool;
  params shray[te_typeexpr];
  #check_and_compute_typeexpr_shray(clq, g, parms, &a->params, &params, &params_complete);

  switch &a->typefunc {
    case &TePureName(value sym): {
      id deftype_entry_id;
      #match_deftype(clq->cs, fake_ast_meta(), value, Has(&params), &id);

      if params_complete {
        // TODO: This is quite duplicated with check_and_compute_parms.  With the changes we're making we should definitely dedup this code.
        canonical shray[cu_typeexpr] = mapconvert(&params);
        hp idy_genparms = {{canonical}};
        inst_id deftype_inst_id = enqueue_deftype_inst(clq, id, &hp);
        *out = {true, TeApp({TePureName(value), params, Has({id, inst_id})})};
      } else {
        *out = {false, TeApp({TePureName(value), params, None})};
      }
      return NoFail;
    }
    case &TePureUnknown: {
      *out = {false, TeApp({TePureUnknown, params, None})};
      return NoFail;
    }
  }
}

func arity_matches(a *ast_generics, params opt[*shray[te_typeexpr]]) bool {
  return help_arity_matches(a, params);
}

func arity_matches(a *ast_generics, params opt[*shray[cu_typeexpr]]) bool {
  return help_arity_matches(a, params);
}

func[T] help_arity_matches(a *ast_generics, params opt[*shray[T]]) bool {
  switch arity(a) {
    case NoParamsArity: {
      if case None = params {
        return true;
      }
    }
    case FiniteArity(n u32): {
      if case Has(p) = params {
        return n == @[u32]~count(p);
      }
    }
    case VariadicArity(ar variadic_arity): {
      if case Has(p) = params {
        return ar.before + ar.after <= @[u32]~count(p);
      }
    }
  }
  return false;
}

func ERR_no_match(cs *checkstate, m ast_meta, name sym, params opt[*shray[te_typeexpr]]) np {
  return MERR(cs, m, _u8("No match for type with name '"), name, _u8("' and maybe some params"));
}

func match_deftype(cs *checkstate, m ast_meta, name sym, params opt[*shray[te_typeexpr]], out *deftype_entry_id) np {
  if case Has(arr *array[deftype_entry_id]) = lookup_ref(&cs->deftypes_by_name, &name) {
    n size = count(arr);
    match opt[deftype_entry_id] = None;
    for i size = 0; i < n; i = i + 1 {
      id deftype_entry_id = arr[i];
      ent *deftype_entry = ref_deftype_entry(cs, id);
      if arity_matches(&ent->generics, params) {
        if case Has(alt_id) = match {
          return ERR(_u8("Multiple deftypes named '"), lookup(cs->im, name), _u8("' match arity"));
        }
        match = Has(id);
      }
    }
    if case Has(id) = match {
      *out = id;
      return NoFail;
    } else {
      return ERR_no_match(cs, m, name, params);
    }
  } else {
    return ERR_no_match(cs, m, name, params);
  }
}

// Returns an index into the HasGenerics array.
func find_plain_generic(g *ast_generics, name sym) opt[size] {
  switch g {
  case &NoGenerics:
    return None;
  case &HasGenerics(a array[ast_generik]):
    return lookup_plain_name(&a, name);
  case &VariadicGenerics(a ast_variadic_generics):
    // We can't see variadic generics because there's no "RHS type" of a fn.
    ice(_u8("find_generic sees variadic generic."));
    return fake();
  }
}

func lookup_plain_generic(g *ast_generics, parms *idy_repls, name sym, out *cu_typeexpr) bool {
  if case Has(ix size) = find_plain_generic(g, name) {
    *out = *ref(&parms->tys, ix);
    return true;
  }
  return false;
}

func ensure_def_checked(cs *checkstate, id def_entry_id) np {
  ent *def_entry = ref_def_entry(cs, id);
  switch &ent->generics {
    case &NoGenerics: {
      parms idy_genparms = blank_idyparms();
      clq clqueue = mk(cs);
      discard_inst_id def_inst_id = enqueue_def_inst(&clq, id, &parms);
      return finish_checking(cs, &clq);
    }
    case &HasGenerics(ig): {
      discard *te_typeexpr;
      #def_converted_typeexpr(cs, ent, &discard);
      // We declare success -- we check non-generic defs.
      return NoFail;
    }
  }
}

func subsequent_depth(cs *checkstate, parms *idy_repls) u32 {
  if empty(&parms->tys) {
    return 0;
  } else {
    return cs->instantiation_depth + 1;
  }
}

func enqueue_deftype_inst(clq *clqueue, id deftype_entry_id, parms *idy_genparms) deftype_inst_id {
  cs *checkstate = clq->cs;
  res type_id_and_created = ensure_deftype_inst(cs, ref_deftype_entry(cs, id), parms);
  if res.created {
    push(&clq->entries, @[clqueue_entry]ClqDeftypeEntry({id, res.id, cs->instantiation_depth}));
  }
  return res.id;
}

struct type_id_and_created {
  id deftype_inst_id;
  created bool;
}

func ensure_deftype_inst(cs *checkstate, ent *deftype_entry, parms *idy_genparms) type_id_and_created {
  if case Has(id deftype_inst_id) = lookup(&ent->insts, parms) {
    return {id, false};
  }
  inst deftype_inst;
  if case &Has(info deftype_inst_info) = &ent->default_info {
    inst = {*parms, Computed(info)};
  } else {
    inst = {*parms, NotComputed};
  }
  id deftype_inst_id = add_deftype_inst(cs, inst);
  check_insert(&ent->insts, parms, id);
  return {id, true};
}

func compute_pack_info(clq *clqueue, pack *te_instpack, out **deftype_inst_info) np {
  #ensure_deftype_inst_checked(clq, pack->ent_id, pack->inst_id);
  inst *deftype_inst = ref_deftype_inst(clq->cs, pack->inst_id);
  if case &Computed(info deftype_inst_info) = &inst->info {
    *out = &info;
    return NoFail;
  } else {
    ice(_u8("ensure_deftype_inst_checked did not compute properties."));
    return fake();
  }
}

func compute_pack_properties(clq *clqueue, pack *te_instpack, out *type_properties) np {
  info *deftype_inst_info;
  #compute_pack_info(clq, pack, &info);
  *out = info->props;
  return NoFail;
}

func compute_type_properties(clq *clqueue, t *cu_typeexpr, out *type_properties) np {
  return compute_complete_type_properties(clq, &t->x, out);
}

struct struct_field_info {
  offset u32;
  props type_properties;
}

struct partial_struct_data {
  found_field bool;
  offset u32;
  max_alignment u32;
  init_level behavior_level;
  move_level behavior_level;
  copy_level behavior_level;
  destroy_level behavior_level;
  is_pow2 pow2_turtles;

  // The length of this is the index of the search-for field (-- it doesn't have all the fields if we stopped early.)
  fields array[struct_field_info];
}

inline func psd_index(psd *partial_struct_data) size {
  return count(&psd->fields);
}

// fields had better damn well be complete
func compute_partial_struct_data(clq *clqueue, fields *shray[te_vardecl], name opt[sym], out *partial_struct_data) np {
  ret partial_struct_data = {false, 0, 1, TrivialLevel, TrivialLevel, TrivialLevel, TrivialLevel, IsPow2AllTheWayDown, mk_array@[struct_field_info]()};
  n size = count(fields);
  for i size = 0; i < n; i = i + 1 {
    vd *te_vardecl = ref(fields, i);
    props type_properties;
    #compute_complete_type_properties(clq, &vd->type, &props);

    ret.offset = ceil_aligned(ret.offset, props.flat_alignment);
    if Has(vd->name) == name {
      ret.found_field = true;
      *out = ret;
      return NoFail;
    }
    push(&ret.fields, {ret.offset, props});
    ret.offset = ret.offset + props.flat_size;

    ret.max_alignment = max(ret.max_alignment, props.flat_alignment);

    ret.init_level = max(ret.init_level, to_level(&props.init_behavior));
    ret.move_level = max(ret.move_level, to_level(&props.move_behavior));
    ret.copy_level = max(ret.copy_level, to_level(&props.copy_behavior));
    ret.destroy_level = max(ret.destroy_level, to_level(&props.destroy_behavior));
    ret.is_pow2 = combine_pow2(ret.is_pow2, props.is_pow2);
  }
  *out = ret;
  return NoFail;
}

def ComputeNone u32 = 0;
def ComputeInit u32 = 1;
def ComputeMove u32 = 2;
def ComputeCopy u32 = 4;
def ComputeDestroy u32 = 8;
def ComputeAll u32 = 0xf;

func mask_level(mask u32, bit u32, level behavior_level) behavior_level {
  if (mask & bit) == 0 {
    return AbsentLevel;
  } else {
    return level;
  }
}

// st had better be complete and computed.
// Realtype is the name (or app) type (a struct or defclass) whose fields the structspec specifies.
func compute_complete_struct_properties(clq *clqueue, st *structspec, realtype *cu_typeexpr, constructor_mask u32, out *type_properties) np {
  psd partial_struct_data;
  #compute_partial_struct_data(clq, &st->fields, None, &psd);
  final_size u32 = ceil_aligned(psd.offset, psd.max_alignment);
  *out = {final_size, psd.max_alignment,
          level_to_derived(clq, CtorInit, 1, &realtype->x, mask_level(constructor_mask, ComputeInit, psd.init_level)),
          level_to_derived(clq, CtorMove, 2, &realtype->x, mask_level(constructor_mask, ComputeMove, psd.move_level)),
          level_to_derived(clq, CtorCopy, 2, &realtype->x, mask_level(constructor_mask, ComputeCopy, psd.copy_level)),
          level_to_derived(clq, CtorDestroy, 1, &realtype->x, mask_level(constructor_mask, ComputeDestroy, psd.destroy_level)),
          IsScalarNo,
          psd.is_pow2};
  return NoFail;
}

func compute_complete_enum_properties(clq *clqueue, et *enumspec, realtype *cu_typeexpr, out *type_properties) np {
  tag_size u32 = clq->cs->plat.enum_tag_size;
  max_size u32 = tag_size;
  max_alignment u32 = tag_size;
  move_level behavior_level = TrivialLevel;
  copy_level behavior_level = TrivialLevel;
  destroy_level behavior_level = TrivialLevel;
  is_pow2 pow2_turtles = IsPow2AllTheWayDown;
  n size = count(&et->constructors);
  for i size = 0; i < n; i = i + 1 {
    props type_properties;
    #compute_complete_type_properties(clq, &ref(&et->constructors, i)->type, &props);
    tagged_size u32 = ceil_aligned(tag_size, props.flat_alignment) + props.flat_size;
    max_size = max(max_size, tagged_size);
    max_alignment = max(max_alignment, props.flat_alignment);
    move_level = max(move_level, to_level(&props.move_behavior));
    copy_level = max(copy_level, to_level(&props.copy_behavior));
    destroy_level = max(destroy_level, to_level(&props.destroy_behavior));
    is_pow2 = combine_pow2(is_pow2, props.is_pow2);
  }

  // See TeUnion for explanation of final_size.
  final_size u32 = ceil_aligned(max_size, max_alignment);
  *out = {final_size, max_alignment,
          // Enum initialization is always trivial -- initializes to zero-filled invalid tag value.
          DerivedMethodTrivial,
          level_to_derived(clq, CtorMove, 2, &realtype->x, move_level),
          level_to_derived(clq, CtorCopy, 2, &realtype->x, copy_level),
          level_to_derived(clq, CtorDestroy, 1, &realtype->x, destroy_level),
          IsScalarNo,
          is_pow2};
  return NoFail;
}

// t had better be complete and computed.
func compute_complete_type_properties(clq *clqueue, t *te_typeexpr, out *type_properties) np {
  cs *checkstate = clq->cs;
  switch t {
    case &TeName(a te_name): {
      if case &Has(p te_instpack) = &a.pack {
        return compute_pack_properties(clq, &p, out);
      } else {
        ice(_u8("compute_type_properties called on packless name type."));
        return fake();
      }
    }
    case &TeApp(a te_typeapp): {
      if case &Has(pack te_instpack) = &a.pack {
        return compute_pack_properties(clq, &pack, out);
      } else {
        ice(_u8("compute_type_properties called on packless app type."));
        return fake();
      }
    }

    case &TeUnion(a te_union): {
      max_size u32 = 0;
      max_alignment u32 = 1;
      is_pow2 pow2_turtles = IsPow2AllTheWayDown;
      n size = count(&a.fields);
      for i size = 0; i < n; i = i + 1 {
        props type_properties;
        #compute_complete_type_properties(clq, &ref(&a.fields, i)->type, &props);
        max_size = max(max_size, props.flat_size);
        max_alignment = max(max_alignment, props.flat_alignment);
        is_pow2 = combine_pow2(is_pow2, props.is_pow2);
        if !(isTrivial(props.init_behavior) && isTrivial(props.move_behavior) && isTrivial(props.copy_behavior) && isTrivial(props.destroy_behavior)) {
          return ERR(_u8("union type has non-trivial field"));
        }
      }
      // Consider the case where you have a union of {uint32_t, uint32_t, uint32_t} and {uint64_t}.  We have alignment 8, thus we need size 16.
      final_size u32 = ceil_aligned(max_size, max_alignment);
      *out = {final_size, max_alignment, DerivedMethodTrivial,
              DerivedMethodTrivial, DerivedMethodTrivial,
              DerivedMethodTrivial, IsScalarNo, is_pow2};
      return NoFail;
    }

    case &TeArraytype(a te_arraytype): {
      if case Has(c u32) = a.count {
        props type_properties;
        #compute_complete_type_properties(clq, oo(&a.param), &props);

        is_pow2 pow2_turtles;
        if c == 0 || (c & (c - 1)) == 0 {
          is_pow2 = props.is_pow2;
        } else {
          is_pow2 = HasNonPow2;
        }

        // We _should_ maintain alignment for a zero-element array because the pointer to such an array might hack in tag-bit logic.
        *out = {props.flat_size * c, props.flat_alignment,
                level_to_derived(clq, CtorInit, 1, t, to_level(&props.init_behavior)),
                level_to_derived(clq, CtorMove, 2, t, to_level(&props.move_behavior)),
                level_to_derived(clq, CtorCopy, 2, t, to_level(&props.copy_behavior)),
                level_to_derived(clq, CtorDestroy, 1, t, to_level(&props.destroy_behavior)),
                IsScalarNo,
                is_pow2};
        return NoFail;
      } else {
        ice(_u8("compute_type_properties called on incomplete arraytype."));
        return fake();
      }
    }

    case &TeUnknown: {
      ice(_u8("compute_type_properties called on incomplete type."));
      return fake();
    }
  }
}

func to_level(b *derived_method_behavior) behavior_level {
  switch b {
  case &DerivedMethodAbsent:
    return AbsentLevel;
  case &DerivedMethodExplicit(ip instpair):
    return NontrivialLevel;
  case &DerivedMethodNontrivial(v instpair):
    return NontrivialLevel;
  case &DerivedMethodTrivial:
    return TrivialLevel;
  }
}

func make_magic_inst(clq *clqueue, magic_name sym, arity size, type *te_typeexpr) instpair {
  arr *array[def_entry_id] = unHas(lookup_ref(&clq->cs->defs_by_name, &magic_name));
  // There is only be one magic def for each name.
  check(count(arr) == 1);
  ent_id def_entry_id = arr[0];

  // It is templatized on one type parameter (type).
  parms genparms = HasParms(mk_shray(*type));
  inst_id def_inst_id;
  if !from_np(make_inst(clq, ent_id, &parms, &inst_id)) {
    ice(_u8("make_inst (from make_magic_inst) seeing error... what?"));
  }
  return {ent_id, inst_id};
}

func make_nontrivial(clq *clqueue, wc which_ctor, arity size, type *te_typeexpr) derived_method_behavior {
  return DerivedMethodNontrivial(make_magic_inst(clq, magic_name(clq->im, wc), arity, type));
}

func make_inst(clq *clqueue, ent def_entry_id, parms *genparms, inst_out *def_inst_id) np {
  idy_parms idy_genparms;
  #check_and_compute_parms(clq, parms, &idy_parms);
  inst_id def_inst_id = enqueue_def_inst(clq, ent, &idy_parms);
  *inst_out = inst_id;
  return NoFail;
}

func level_to_derived(clq *clqueue, wc which_ctor, arity size, type *te_typeexpr, level behavior_level) derived_method_behavior {
  switch level {
  case TrivialLevel:
    return DerivedMethodTrivial;
  case NontrivialLevel:
    return make_nontrivial(clq, wc, arity, type);
  case AbsentLevel:
    return DerivedMethodAbsent;
  }
}




func lambda_declared_type(im *identmap, a *ast_lambda) ast_typeexpr {
  type_params array[ast_typeexpr];
  n size = count(&a->args);
  for i size = 0; i < n; i = i + 1 {
    push(&type_params, ref(&a->args, i)->type);
  }
  push(&type_params, a->return_type);
  return App({embox(@[ast_typeexpr]Name({fake_ast_meta(), im->cym.fnsym})), type_params});
}

func quick_typeexpr(im *identmap, a *ast_def, out *ast_typeexpr) np {
  if case &Has(s ast_typeexpr) = &a->syntactic_typeexpr {
    *out = s;
    return NoFail;
  } else {
    switch &a->rhs.expr.u {
      case &Lambda(b ast_lambda): {
        *out = lambda_declared_type(im, &b);
        return NoFail;
      }
      default: {
        return ERR(_u8("Def does not have immediately conceivable typeexpr."));
      }
    }
  }
}

// This does return a complete and computed typeexpr.  Note that it'll have some generic parameters from an idy_genparms, so watch your scopage.
func inst_type(cs *checkstate, ent_id deftype_entry_id, inst_id deftype_inst_id) cu_typeexpr {
  ent *deftype_entry = ref_deftype_entry(cs, ent_id);
  inst *deftype_inst = ref_deftype_inst(cs, inst_id);
  switch &ent->generics {
  case &NoGenerics:
    return ~@[te_typeexpr]TeName({ent->name, Has({ent_id, inst_id})});
  case &HasGenerics(a array[ast_generik]): { }
  case &VariadicGenerics(a ast_variadic_generics): { }
  }
  cu_params *shray[cu_typeexpr] = &inst->parms.repls.tys;
  te_params array[te_typeexpr];
  n size = count(cu_params);
  reserve(&te_params, n);
  for i size = 0; i < n; i = i + 1 {
    push(&te_params, ref(cu_params, i)->x);
  }
  return ~@[te_typeexpr]TeApp({TePureName(ent->name), freeze(&te_params), Has({ent_id, inst_id})});
}

func ensure_deftype_inst_checked(clq *clqueue, ent_id deftype_entry_id, id deftype_inst_id) np {
  cs *checkstate = clq->cs;
  ent *deftype_entry = ref_deftype_entry(cs, ent_id);
  inst *deftype_inst = ref_deftype_inst(cs, id);

  switch inst->info {
    case NotComputed: {
      rw depth_rewinder;
      #set_instantiation_depth(cs, subsequent_depth(cs, &inst->parms.repls), &rw);
      inst->info = BeganComputing;

      if case &Has(np deftype_nonprim) = &ent->nonprim {
        ent_rhs *deftype_rhs_spec;
        #deftype_converted_rhs(cs, &np, &ent_rhs);

        switch ent_rhs {
        case &ClassexprRhsSpec(crs classexpr_rhs_spec):
          rhs_fields array[te_vardecl];
          rhs_fields_complete bool;
          #help_check_and_compute_fields(clq, &ent->generics, &inst->parms.repls, &crs.drs.fields, &rhs_fields, &rhs_fields_complete);

          check(rhs_fields_complete);

          check(isBeganComputing(&inst->info));
          st structspec = {freeze(&rhs_fields)};

          class_props type_properties;
          if case Printed(pm) = to_defclass_properties(clq, ent_id, id, crs.disposition,&st, &class_props) {
            inst->info = FailedComputation;
            return Printed(pm);
          }
          inst->info = Computed({Has(@[deftype_inst_rhs_info]RhsStructInfo(st)), class_props});

        case &DefstructRhsSpec(drs structspec):
          rhs_fields array[te_vardecl];
          rhs_fields_complete bool;

          if case Printed(pm) = help_check_and_compute_fields(clq, &ent->generics, &inst->parms.repls, &drs.fields, &rhs_fields, &rhs_fields_complete) {
            inst->info = FailedComputation;
            return Printed(pm);
          }
          check(rhs_fields_complete);

          check(isBeganComputing(&inst->info));
          st structspec = {freeze(&rhs_fields)};

          it cu_typeexpr = inst_type(cs, ent_id, id);
          rhs_props type_properties;
          if case Printed(pm) = compute_complete_struct_properties(clq, &st, &it, ComputeAll, &rhs_props) {
            inst->info = FailedComputation;
            return Printed(pm);
          }
          check(isBeganComputing(&inst->info));

          inst->info = Computed({Has(@[deftype_inst_rhs_info]RhsStructInfo(st)), rhs_props});

        case &DefenumRhsSpec(drs enumspec):
          rhs_constructors array[te_vardecl];
          rhs_constructors_complete bool;

          if case Printed(pm) = help_check_and_compute_fields(clq, &ent->generics, &inst->parms.repls, &drs.constructors, &rhs_constructors, &rhs_constructors_complete) {
            inst->info = FailedComputation;
            return Printed(pm);
          }
          check(rhs_constructors_complete);

          check(isBeganComputing(&inst->info));
          et enumspec = {freeze(&rhs_constructors), drs.success_case_ix};

          it cu_typeexpr = inst_type(cs, ent_id, id);
          rhs_props type_properties;
          if case Printed(pm) = compute_complete_enum_properties(clq, &et, &it, &rhs_props) {
            inst->info = FailedComputation;
            return Printed(pm);
          }
          check(isBeganComputing(&inst->info));

          inst->info = Computed({Has(@[deftype_inst_rhs_info]RhsEnumInfo(et)), rhs_props});

        }
      } else {
        ice(_u8("ensure_deftype_inst_checked sees NonComputed inst on primitive type."));
      }
      return NoFail;
    }
    case BeganComputing: {
      return ERR(_u8("deftype for '"), lookup(cs->im, ent->name), _u8("' recursively checking"));
    }
    case FailedComputation: {
      return ERR(_u8("deftype for '"), lookup(cs->im, ent->name), _u8("' already failed checking"));
    }
    case Computed(info deftype_inst_info): {
      return NoFail;
    }
  }
}

func ensure_deftype_checked(cs *checkstate, id deftype_entry_id) np {
  ent *deftype_entry = ref_deftype_entry(cs, id);
  if case &Has(np deftype_nonprim) = &ent->nonprim {
    discard *deftype_rhs_spec;
    #deftype_converted_rhs(cs, &np, &discard);
    switch &np.tl->generics {
      case &NoGenerics: {
        parms idy_genparms = blank_idyparms();
        clq clqueue = mk(cs);
        discard_id deftype_inst_id = enqueue_deftype_inst(&clq, id, &parms);
        return finish_checking(cs, &clq);
      }
      case &HasGenerics(ig): {
        // We declare success -- we check non-generic defs.
        return NoFail;
      }
    }
  } else {
    ice(_u8("ensure_deftype_checked on primitive type"));
    return fake();
  }
}

func modules_next_base_offset(cs *checkstate) size {
  n size = count(&cs->modules);
  if n == 0 {
    return 0;
  } else {
    m *module = oo(ref(&cs->modules, n - 1));
    // We add 1, so that the "last offset" from the k'th module is distinguishable from the "first offset" from the k+1'th module.
    return m->base_offset + count(&m->buf) + 1;
  }
}

func absolute_to_linecol(buf *array[u8], absolute size) tup[size, size] {
  d * ^[0]u8 = data(buf);
  n size = count(buf);
  check(absolute <= n);

  line size = 1;
  column size = 0;
  for i size = 0; i < absolute; i = i + 1 {
    ch u8 = d[i];
    if ch == '\n' {
      line = line + 1;
      column = 0;
    } else if ch == '\t' {
      column = (column | 7) + 1;
    } else {
      column = column + 1;
    }
  }
  return {line, column};
}

func to_human_pos(cs *checkstate, p pos) human_pos {
  if case Has(m *module) = find_pos_module(cs, p) {
    return to_human_pos(m, p);
  } else {
    ice(_u8("to_human_pos sees invalid pos with value "), p.x);
    return fake();
  }
}

func to_human_pos(m *module, p pos) human_pos {
  absolute size = p.x - m->base_offset;
  linecol tup[size, size] = absolute_to_linecol(&m->buf, absolute);
  return {m->module_name, linecol.car, linecol.cdr, absolute};
}

func find_pos_module(cs *checkstate, p pos) opt[*module] {
  n size = count(&cs->modules);
  for i size = 0; i < n; i = i + 1 {
    m *module = oo(ref(&cs->modules, i));
    if m->base_offset <= p.x && m->base_offset + count(&m->buf) >= p.x {
      return Has(m);
    }
  }
  return None;
}

func load_module(cs *checkstate, mod_name sym) cr[module_id] {
  if case Has(id module_id) = lookup(&cs->modules_by_name, &mod_name) {
    return NoFail(id);
  }

  arr array[u8];
  if (cs->loader)(cs, mod_name, &arr) {
    mod shp[module];
    oo(&mod)->process_state = Unprocessed;
    oo(&mod)->module_name = mod_name;
    oo(&mod)->base_offset = modules_next_base_offset(cs);
    swap(&oo(&mod)->buf, &arr);
    p ps = make_ps(cs->im, &cs->posits, oo(&mod)->base_offset, data(&oo(&mod)->buf), count(&oo(&mod)->buf));
    if ! +parse_file(&p, &oo(&mod)->file) {
      // The @[np] was something to grep for at one point.  TODO: Something about this is bad?
      ign np = @[np]ERR(_u8("Trouble parsing module at "), to_u8str(cs->im, to_human_pos(oo(&mod), peek(&p)->interval.left)));
      return Printed(true);
    }
    mod_id module_id = ~count(&cs->modules);
    push(&cs->modules, mod);
    if !try_insert(&cs->modules_by_name, &mod_name, mod_id) {
      return ERR(_u8("ICE: modules_by_name already has name "), lookup(cs->im, mod_name));
    }
    return NoFail(mod_id);
  } else {
    return ERR(_u8("Could not open file for module "), lookup(cs->im, mod_name));
  }
}

func process_module(cs *checkstate, mod_name sym) cr[module_id] {
  id module_id = #load_module(cs, mod_name);
  mod *module = ref_module(cs, id);
  if mod->process_state == Unprocessed {
    #process_module_toplevels(cs, mod);
  }
  return NoFail(id);
}

func process_module_toplevels(cs *checkstate, mod *module) np {
  check_mutate(&mod->process_state, Unprocessed, Processing);
  // We start the module outside of any access blocks, so the scope is empty, of course.
  access_scope array[access_entry_id];
  #process_toplevels(cs, access_scope, mod, &mod->file.toplevels);
  check_mutate(&mod->process_state, Processing, DoneProcessing);
  return NoFail;
}

func add_def_entry(cs *checkstate,
                   module_name sym,
                   module_defs *array[def_entry_id],
                   ent shp[def_entry]) void {
  id def_entry_id = add_def_entry(cs, ent);
  push(module_defs, id);
}

func process_toplevels(cs *checkstate,
                       access_scope array[access_entry_id],
                       mod *module,
                       toplevels *array[ast_toplevel]) np {
  ntoplevels size = count(toplevels);
  for i size = 0; i < ntoplevels; i = i + 1 {
    toplevel *ast_toplevel = ref(toplevels, i);
    switch toplevel {
      case &Import(a ast_import): {
        id module_id = #process_module(cs, a.name.value);
        // Do nothing!  We've processed the module successfully.
      }
      case &Def(a ast_def): {
        quick_te ast_typeexpr;
        #quick_typeexpr(cs->im, &a, &quick_te);
        #check_generics_unique(cs, &a.generics);
        ent def_entry = mk(mod->module_name, a.name.value, access_scope, a.generics, quick_te, toplevel);
        add_def_entry(cs, mod->module_name, &mod->defs, emshp(ent));
      }
      case &ExternDef(a ast_extern_def): {
        ent def_entry = mk(mod->module_name, a.name.value, access_scope, NoGenerics, a.type, toplevel);
        add_def_entry(cs, mod->module_name, &mod->defs, emshp(ent));
      }
      case &TypeDef(a ast_type_def): {
        #check_generics_unique(cs, &a.generics);
        id deftype_entry_id = add_deftype_entry(cs, mk(mod->module_name, a.name.value, access_scope, a.generics, &a));
        push(&mod->deftypes, id);
      }
      case &Access(a ast_access): {
        access_id access_entry_id = add_access_entry(cs, mk(a.name.value, a.arity));
        push(&mod->access_blocks, access_id);
        push(&access_scope, access_id);
        #process_toplevels(cs, access_scope, mod, &a.toplevels);
        pop(&access_scope);
      }
    }
  }
  return NoFail;
}

func check_generics_unique(cs *checkstate, a *ast_generics) np {
  switch a {
    case &NoGenerics: {
      return NoFail;
    }
    case &HasGenerics(b array[ast_generik]): {
      n size = count(&b);
      for i size = 0; i < n; i = i + 1 {
        xi *ast_generik = ref(&b, i);
        for j size = 0; j < i; j = j + 1 {
          yi *ast_generik = ref(&b, j);
          if generiks_same_human_name(xi, yi) {
            return ERR(_u8("Generic params are self-shadowing."));
          }
        }
      }
      return NoFail;
    }
  }
}

func generik_human_name(a *ast_generik) *ast_ident {
  switch a {
  case &PlainGeneric(an ast_ident): return &an;
  }
}

func generiks_same_human_name(a *ast_generik, b *ast_generik) bool {
  return generik_human_name(a)->value == generik_human_name(b)->value;
}

func get_accessible_deftype(cs *checkstate, aid access_entry_id, out *deftype_entry_id) np {
  ent *access_entry = ref_access_entry(cs, aid);
  switch ent->ent_id {
    case NotComputed: {
      ent->ent_id = BeganComputing;
      switch ent->arity {
        case AccessArityNone: {
          id deftype_entry_id;
          if case Printed(pm) = match_deftype(cs, fake_ast_meta(), ent->name, None, &id) {
            ent->ent_id = FailedComputation;
            return Printed(pm);
          }
          *out = id;
          ent->ent_id = Computed(id);
          return NoFail;
        }
        case AccessArityFinite(n u32): {
          params shray[te_typeexpr] = repeat(~n, TeUnknown);
          id deftype_entry_id;
          if case Printed(pm) = match_deftype(cs, fake_ast_meta(), ent->name, Has(&params), &id) {
            ent->ent_id = FailedComputation;
            return Printed(pm);
          }
          *out = id;
          ent->ent_id = Computed(id);
          return NoFail;
        }
      }
    }
    case BeganComputing: {
      return ERR(_u8("Recursively computing access block reference"));
    }
    case FailedComputation: {
      return ERR(_u8("Repeated get_accessible_deftype error"));
    }
    case Computed(x deftype_entry_id): {
      *out = x;
      return NoFail;
    }
  }
}

struct ent_and_parms {
  ent def_entry_id;
  parms genparms;
}

enum match_def_res {
  NoMatch void;
  MultiMatch void;
  OneMatch ent_and_parms;
}

// Note that gp could be incomplete.
func match_def(cs *checkstate, name sym, gp *genparms, pt *te_typeexpr,
               res_out *match_def_res) np {
  if case Has(arr *array[def_entry_id]) = lookup_ref(&cs->defs_by_name, &name) {
    n size = count(arr);
    matches array[ent_and_parms];
    for i size = 0; i < n; i = i + 1 {
      id def_entry_id = arr[i];
      ent *def_entry = ref_def_entry(cs, id);
      ent_typeexpr *te_typeexpr;
      #def_converted_typeexpr(cs, ent, &ent_typeexpr);
      match_result entry_matches_res = entry_matches(cs, pt, &ent->generics, gp, ent_typeexpr);
      switch match_result {
        case EntryDoesNotMatch: {
          // Do nothing.
        }
        case EntryMatchesAmbigously: {
          // NOTE: We could see if we have _one_ ambiguously matching entry, and extract any type information that we learned, to help the next match attempt (see check_expr and its allow_ambiguous parameter).  (Maybe we should, but maybe we shouldn't to keep the type checking algorithm simple and describable.)
          // Certainly the error message (somewhere) could be improved.
          *res_out = MultiMatch;
          return NoFail;
        }
        case EntryMatchesPrecisely(complete_parms genparms): {
          push(&matches, {id, complete_parms});
        }
      }
    }
    num_matches size = count(&matches);
    if num_matches == 0 {
      *res_out = NoMatch;
      return NoFail;
    } else if num_matches == 1 {
      *res_out = OneMatch(matches[0]);
      return NoFail;
    } else {
      *res_out = MultiMatch;
      return NoFail;
    }
  } else {
    *res_out = NoMatch;
    return NoFail;
  }
}

enum entry_matches_res {
  EntryDoesNotMatch void;
  EntryMatchesAmbigously void;
  EntryMatchesPrecisely genparms;
}

func from_type_matches_res(hasparms bool, x *type_matches_res) entry_matches_res {
  switch x {
    case &TypeDoesNotMatch: {
      return EntryDoesNotMatch;
    }
    case &TypeMatchesAmbiguously(a): {
      return EntryMatchesAmbigously;
    }
    case &TypeMatchesPrecisely(a shray[te_typeexpr]): {
      if hasparms {
        return EntryMatchesPrecisely(HasParms(a));
      } else {
        check(count(&a) == 0);
        return EntryMatchesPrecisely(NoParms);
      }
    }
  }
}

func entry_matches(cs *checkstate, pt *te_typeexpr, generics *ast_generics, gp *genparms, typeexpr *te_typeexpr) entry_matches_res {
  switch generics {
    case &NoGenerics: {
      switch gp {
        case &HasParms(parms shray[te_typeexpr]): {
          return EntryDoesNotMatch;
        }
        case &NoParms: {
          names array[ast_generik];
          parms shray[te_typeexpr];
          res var = type_matches(pt, &names, &parms, typeexpr);
          return from_type_matches_res(false, &res);
        }
      }
    }
    case &HasGenerics(names array[ast_generik]): {
      switch gp {
        case &HasParms(parms shray[te_typeexpr]): {
          if count(&parms) != count(&names) {
            return EntryDoesNotMatch;
          }
          res var = type_matches(pt, &names, &parms, typeexpr);
          return from_type_matches_res(true, &res);
        }
        case &NoParms: {
          parms shray[te_typeexpr] = repeat(count(&names), TeUnknown);
          res var = type_matches(pt, &names, &parms, typeexpr);
          return from_type_matches_res(true, &res);
        }
      }
    }
  }
}

enum type_matches_res {
  TypeDoesNotMatch void;
  // Provides partial types of some generic names.
  TypeMatchesAmbiguously shray[te_typeexpr];
  // Provides complete types of all generic names.
  TypeMatchesPrecisely shray[te_typeexpr];
}

// t is complete, but it references the generic names in "names", whose corresponding values in "parms" could be incomplete.  pt is the partial type of an expression we're matching against this generic definition.  count(parms) == count(names).
func type_matches(pt *te_typeexpr, names *array[ast_generik], parms *shray[te_typeexpr],
                  t *te_typeexpr) type_matches_res {
  check(count(names) == count(parms));
  // We need to retain all new information we gain about the value of the generic param typeexprs as we compare the whole type, in order to make sure we don't match conflicting information about a generic parameter.
  unif_parms array[te_typeexpr] = mk_copy(parms);
  // Since t is complete, unified is irrelevant and must be identical to t.
  unified te_typeexpr;
  if !unify_under_generics(pt, names, &unif_parms, t, &unified) {
    return TypeDoesNotMatch;
  }
  frozen_unif_parms shray[te_typeexpr] = freeze(&unif_parms);
  if all_complete_computed(&frozen_unif_parms).complete {
    return TypeMatchesPrecisely(frozen_unif_parms);
  } else {
    return TypeMatchesAmbiguously(frozen_unif_parms);
  }
}

func all_complete_computed(types *shray[te_typeexpr]) complete_computed {
  n size = count(types);
  all_computed bool = true;
  for i size = 0; i < n; i = i + 1 {
    cc complete_computed = is_complete_computed(&types[i]);
    if !cc.complete {
      return {false, false};
    }
    all_computed = all_computed & cc.computed;
  }
  return {true, all_computed};
}

func all_complete_computed(decls *shray[te_vardecl]) complete_computed {
  n size = count(decls);
  all_computed bool = true;
  for i size = 0; i < n; i = i + 1 {
    cc complete_computed = is_complete_computed(&decls[i].type);
    if !cc.complete {
      return {false, false};
    }
    all_computed = all_computed & cc.computed;
  }
  return {true, all_computed};
}

func is_complete_computed(t *te_typeexpr) complete_computed {
  switch t {
    case &TeName(a te_name): { return {true, isHas(&a.pack)}; }
    case &TeApp(a te_typeapp): {
      if case &TePureUnknown = &a.typefunc {
        return {false, false};
      }
      all complete_computed = all_complete_computed(&a.params);
      return {all.complete, all.computed & isHas(&a.pack)};
    }
    case &TeUnion(a te_union): { return all_complete_computed(&a.fields); }
    case &TeArraytype(a te_arraytype): {
      if isHas(&a.count) {
        return is_complete_computed(oo(&a.param));
      } else {
        return {false, false};
      }
    }

    case &TeUnknown: {
      return {false, false};
    }
  }
}

struct complete_computed {
  complete bool;
  computed bool;
}

func is_complete(t *te_typeexpr) bool {
  return is_complete_computed(t).complete;
}

// t references the generic names in "names", whose corresponding values in "unif_parms" might be incomplete.  We update the values in unif_parms when necessary.  t does not need to be complete -- this code is also used by unify_types.
// "*unified_out" is initialized with the unified type, _except_ when t references a generic name, in which case it's initialized with the value of "*t", the generic name.  (The reason is, we might not have gathered complete information about the generic parameter when we've halfway-processed the type -- the caller can and should reconstruct the correct values later.)
func unify_under_generics(pt *te_typeexpr,
                          names *array[ast_generik], unif_parms *array[te_typeexpr],
                          t *te_typeexpr, unified_out *te_typeexpr) bool {
  if case &TeUnknown = pt {
    // It's worth pointing out:  This _is_ correct behavior if t is a generic parameter.
    *unified_out = *t;
    return true;
  }
  switch t {
    case &TeName(a te_name): {
      if case Has(ix size) = lookup_plain_name(names, a.value) {
        unified te_typeexpr;
        if !unify_types(ref(unif_parms, ix), pt, &unified) {
          return false;
        }
        *ref(unif_parms, ix) = unified;
        *unified_out = TeName({a.value, None});
        return true;
      } else {
        if case &TeName(pa te_name) = pt {
          // NOTE: Naturally, at some point scopage might be a factor.
          if a.value != pa.value {
            return false;
          }
          *unified_out = TeName({a.value, None});
          return true;
        } else {
          return false;
        }
      }
    }

    case &TeApp(a te_typeapp): {
      // Generics can't be type constructors (yet).
      if case &TeApp(pa te_typeapp) = pt {
        unified_typefunc te_puretype;
        if !unify_puretypes(&a.typefunc, &pa.typefunc, &unified_typefunc) {
          return false;
        }
        a_params *shray[te_typeexpr] = &a.params;
        pa_params *shray[te_typeexpr] = &pa.params;
        n size = count(a_params);
        if n != count(pa_params) {
          return false;
        }
        unified_params array[te_typeexpr];
        reserve(&unified_params, n);
        for i size = 0; i < n; i = i + 1 {
          unified te_typeexpr;
          if !unify_under_generics(ref(pa_params, i), names, unif_parms, ref(a_params, i), &unified) {
            return false;
          }
          push(&unified_params, unified);
        }
        *unified_out = TeApp({unified_typefunc, freeze(&unified_params), None});
        return true;
      } else {
        return false;
      }
    }

    case &TeUnion(a te_union): {
      if case &TeUnion(pa te_union) = pt {
        n size = count(&a.fields);
        if n != count(&pa.fields) {
          return false;
        }
        unified_fields array[te_vardecl];
        for i size = 0; i < n; i = i + 1 {
          pd *te_vardecl = ref(&pa.fields, i);
          d *te_vardecl = ref(&a.fields, i);
          if pd->name != d->name {
            return false;
          }
          unified te_typeexpr;
          if !unify_under_generics(&pd->type, names, unif_parms, &d->type, &unified) {
            return false;
          }
          push(&unified_fields, {d->name, unified});
        }
        *unified_out = TeUnion({freeze(&unified_fields)});
        return true;
      } else {
        return false;
      }
    }

    case &TeArraytype(a te_arraytype): {
      if case &TeArraytype(pa te_arraytype) = pt {
        unified_count opt[u32];
        if case Has(ac u32) = a.count {
          if case Has(pac u32) = pa.count {
            if ac != pac {
              return false;
            } else {
              unified_count = Has(ac);
            }
          } else {
            unified_count = Has(ac);
          }
        } else {
          unified_count = pa.count;
        }
        unified_type te_typeexpr;
        if !unify_under_generics(oo(&pa.param), names, unif_parms, oo(&a.param), &unified_type) {
          return false;
        }
        *unified_out = TeArraytype({unified_count, emshp(unified_type)});
        return true;
      } else {
        return false;
      }
    }

    case &TeUnknown: {
      // Right now, the only callers are type_matches and unify_types.  From type_matches, t is complete, and from unify_types, there are no generic names.
      check(count(names) == 0);
      *unified_out = *pt;
      return true;
    }
  }
}

func lookup_plain_name(arr *array[ast_generik], x sym) opt[size] {
  n size = count(arr);
  for i size = 0; i < n; i = i + 1 {
    switch ref(arr, i) {
    case &PlainGeneric(b ast_ident):
      if b.value == x {
        return Has(i);
      }
    }
  }
  return None;
}

func unify_puretypes(ppta *te_puretype, pptb *te_puretype, out *te_puretype) bool {
  switch ppta {
    case &TePureName(as sym): {
      switch pptb {
        case &TePureName(bs sym): {
          if as == bs {
            *out = TePureName(as);
            return true;
          } else {
            return false;
          }
        }
        case &TePureUnknown: {
          *out = *ppta;
          return true;
        }
      }
    }
    case &TePureUnknown: {
      *out = *pptb;
      return true;
    }
  }
}

func unify_types(pta *te_typeexpr, ptb *te_typeexpr, out *te_typeexpr) bool {
  names array[ast_generik];
  unif_parms array[te_typeexpr];
  return unify_under_generics(pta, &names, &unif_parms, ptb, out);
}
