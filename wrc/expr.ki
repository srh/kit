import bigint;
import body;
import check;
import primitives;

// Used with the variable name "es" -- its name used to be different.
struct framescope {
  ds *defscope;
  // Same as ds->cs.
  cs *checkstate;
  // Same as ds->im, same as cs->im.
  im *identmap;
  // Same as ds->clq.
  clq *clqueue;

  all_vars array[var_info];

  // These var_numbers are always in increasing order.
  current_vars array[var_number];

  // Used for auto-generating $frame_1, $frame_2, ... ipses.
  ipse_gen_counter size;

  // The return type... if we're in a body that has a return type -- used for QuickReturn expressions.
  return_type opt[*cu_typeexpr];

  gr frame_graph;
}

func mk(ds *defscope, return_type opt[*cu_typeexpr]) framescope {
  return {ds, ds->cs, ds->im, ds->clq,
          mk_array@[var_info](), mk_array@[var_number](),
          0,
          return_type,
          init_frame_graph_empty(ds->def_informal_name)};
}

inline func add_cell(es *framescope, info cell_info) cell_num {
  return add_cellp(&es->gr, &info);
}

inline func ref_cell(es *framescope, num cell_num) *cell_info {
  return ref_cell(&es->gr, num);
}

struct frame_cell_count { x size; }

func reannotate_static_to_virtual(es *framescope, num cell_num) void {
  info *cell_info = ref_cell(es, num);
  if case LocationStatic = info->location {
    info->location = LocationVirtual;
  } else {
    ice(_u8("reannotate_static_to_virtual seeing non-rigid location"));
  }
}

struct defscope {
  cs *checkstate;
  // Same as cs->im.
  im *identmap;
  clq *clqueue;
  accessible array[access_entry_id];
  // Generics and their _complete_ replacements.
  generics *ast_generics;
  repls *idy_repls;
  def_informal_name sym;
}

struct var_number { x size; }

def `~` fn[size, var_number] = wrapconvert;
def `==` fn[var_number, var_number, bool] = wrapequate;
func `!=`(x var_number, y var_number) bool { return !(x == y); }
func `<`(x var_number, y var_number) bool {
  return x.x < y.x;
}

enum var_binding {
  // The variable overlays some other object, in a switch/etc.  It's bound _to_ some object, or partt of one, and we can't auto-initialize it (and it doesn't get destructed on its own when it goes out of scope).
  VarOverlay void;
  // The variable's a self-contained object -- it gets destroyed or not, it can be autoinitialized.
  VarSelfContained void;
}

struct var_info {
  num var_number;
  // A complete, checked, type, with generics replaced.
  type cu_typeexpr;
  props type_properties;
  cell cell_num;
  name opt[sym];
  ipse cu_typeexpr;
  // Can a goto statement enter this var's scope and construct the var?  True if the var is self-contained.  I.e. true if the variable is not bound by a case-pattern.  (Also true for lambda parameters, out of general principle.)  This also means the var needs to be destructed by return statements and gotos that leave its scope.  NOTE: What about default cases of switch statements?  You shouldn't be able to goto into one of those?  But you should be able to goto into the else block of an "if case" -- this needs to be fixed?  Should the swartch get destroyed?  Are we treating the "destroy later" of the condition properly?
  binding var_binding;
  initter opt[ctor_desc];
  destroyer opt[ctor_desc];
}

func ref_var(es *framescope, num var_number) *var_info {
  return ref(&es->all_vars, num.x);
}

func vars_in_scope(es *framescope) array[var_number] {
  return es->current_vars;
}


enum allow_incomplete {
  AllowIncompleteNo void;
  AllowIncompleteYes void;
}

func `==`(x allow_incomplete, y allow_incomplete) bool {
  return enumnum(&x) == enumnum(&y);
}

defclass move varpopper {
  es *framescope;
  nums array[var_number];
}

access varpopper {

func do_init(vp *varpopper) void {
  init(&vp->es);
  init(&vp->nums);
}

func init_vp(vp *varpopper, es *framescope) void {
  check(vp->es == null);
  vp->es = es;
}

func do_destroy(vp *varpopper) void {
  if vp->es != null {
    descope_vars(vp);
  }
  destroy(&vp->nums);
  vp->es = null;
}

func es_push_var(es *framescope, vp *varpopper, cell cell_num, name opt[*ast_ident], ipse cu_typeexpr, computed_type *cu_typeexpr, binding var_binding, vn_out *var_number) np {
  osymname opt[sym];
  if case Has(ident *ast_ident) = name {
    osymname = Has(ident->value);
    if case Has(num var_number) = es_find_current_local(es, ident->value) {
      return ERR(_u8("Local variable '"), lookup(es->im, ident->value), _u8("' shadows another"));
    }
  } else {
    osymname = None;
  }
  props type_properties;
  #compute_type_properties(es->clq, computed_type, &props);
  num var_number = ~count(&es->all_vars);
  push(&es->all_vars, {num, *computed_type, props, cell, osymname, ipse, binding, None, None});
  push(&es->current_vars, num);
  push(&vp->nums, num);
  *vn_out = num;
  return NoFail;
}

func descope_vars(vp *varpopper) void {
  es *framescope = vp->es;
  check(es != null);
  while case Has(expected var_number) = popval(&vp->nums) {
    num var_number;
    if !popval(&es->current_vars, &num) {
      ice(_u8("varpopper sees empty local_vars"));
    }
    if num != expected {
      ice(_u8("varpopper sees mismatch"));
    }
  }
}

func read_nums(vp *varpopper) *array[var_number] {
  return &vp->nums;
}

}  // access varpopper

func es_note_var_initter(es *framescope, vn var_number) np {
  info *var_info = ref_var(es, vn);
  if case &Has(desc ctor_desc) = &info->initter {
    return NoFail;
  }
  desc ctor_desc = #get_init_ctor(es->clq, &info->type);
  info->initter = Has(desc);
  return NoFail;
}

func es_note_var_destroyer(es *framescope, vn var_number) np {
  info *var_info = ref_var(es, vn);
  if case &Has(desc ctor_desc) = &info->destroyer {
    return NoFail;
  }
  desc ctor_desc = #get_destroy_ctor(es->clq, &info->type);
  info->destroyer = Has(desc);
  return NoFail;
}

func check_def_expr(clq *clqueue, accessible array[access_entry_id], g *ast_generics, parms *idy_repls, x *ast_expr_consume, pt *te_typeexpr, def_informal_name sym, frame_info_out *frame_info) np {
  ds defscope = {clq->cs, clq->im, clq, accessible, g, parms, def_informal_name};
  es framescope = mk(&ds, None);
  #check_expr_consume(&es, x, pt);
  *frame_info_out = {Has(move(&es.gr))};
  return NoFail;
}

func check_expr_consume(es *framescope, x *ast_expr_consume, pt *te_typeexpr) np {
  // If you change this, see also check_expr_retconsume.
  #check_expr_ai(es, AllowIncompleteNo, &x->expr, pt);
  #annotate_disposal_for_consume(es, &x->expr, &x->after);
  return NoFail;
}

func check_expr_retconsume(es *framescope, x *ast_expr_consume, pt *te_typeexpr, movable_cells *shray[opt[cell_num]], moved_cell_ix_out *opt[size]) np {
  #check_expr_ai(es, AllowIncompleteNo, &x->expr, pt);
  #annotate_disposal_for_consume(es, &x->expr, movable_cells, &x->after, moved_cell_ix_out);
  return NoFail;
}

func replaced_name_parms(ds *defscope, a *ast_name_expr, out *genparms) np {
  if case &Has(arr array[ast_typeexpr]) = &a->generic_params {
    replaced array[te_typeexpr];
    n size = count(&arr);
    for i size = 0; i < n; i = i + 1 {
      converted te_typeexpr = #convert_typeexpr(ref(&arr, i));
      computed cac_typeexpr;
      #check_and_compute_typeexpr(ds->clq, ds->generics, ds->repls, &converted, &computed);
      push(&replaced, computed.te);
    }
    *out = HasParms(freeze(&replaced));
    return NoFail;
  } else {
    *out = NoParms;
    return NoFail;
  }
}

struct constructor_info {
  // A fn type.
  type cu_typeexpr;
  constructor_tag enum_tag_value;
  ip instpair;
}

struct voidconstructed_info {
  // The actual constructed type, which we need for some reason.
  constructed_type cu_typeexpr;
  // The enum type (the structural rhs of constructed_type).
  et enumspec;
  constructor_tag enum_tag_value;
}

enum ds_constructor_res {
  NoMatchConstructor void;
  AmbigMatchConstructor void;
  MatchedConstructor constructor_info;
  MatchedVoidConstructed voidconstructed_info;
}

// Like any pt, pt is either (a) incomplete, or (b) complete and computed.
func ds_lookup_constructor(ds *defscope, name sym, gp *genparms, pt *te_typeexpr) cr[ds_constructor_res] {
  if case &HasParms(a) = gp {
    return NoFail(NoMatchConstructor);
  }
  arg_type *te_typeexpr;
  return_type *te_typeexpr;
  switch tri_decompose_typeapp(pt, primitive_function_puretype(ds->cs), &arg_type, &return_type) {
  case BadPuretype:
    switch pt {
    case &TeName(te te_name): { }
    case &TeApp(te te_typeapp): { }
    case &TeUnknown:
      return NoFail(AmbigMatchConstructor);
    default:
      return NoFail(NoMatchConstructor);
    }
    // TODO: Dedup some of the code from here on?
    if !is_complete(pt) {
      return NoFail(AmbigMatchConstructor);
    }
    et *enumspec;
    switch structural_enumspec(ds, pt, &et) {
    case Error(pm):
      return Printed(pm);
    case Success: { }
    case NotAccessible:
      return NoFail(NoMatchConstructor);
    }

    rhs_type *te_typeexpr;
    decl_index size;
    if !find_vardecl(&et->constructors, name, &rhs_type, &decl_index) {
      return NoFail(NoMatchConstructor);
    }
    void_type te_typeexpr = primitive_void_type(ds->cs);
    unified te_typeexpr;
    if !unify_types(&void_type, rhs_type, &unified) {
      return NoFail(NoMatchConstructor);
    }
    return NoFail(@[ds_constructor_res]MatchedVoidConstructed({~ *pt, *et, mk_enum_tag_value(decl_index)}));
  case BadArity:
    return NoFail(NoMatchConstructor);
  case Success:
    cac_return_type cac_typeexpr;
    #noscoped_check_and_compute_typeexpr(ds->clq, return_type, &cac_return_type);
    if !cac_return_type.complete {
      return NoFail(AmbigMatchConstructor);
    }
    et *enumspec;
    switch structural_enumspec(ds, &cac_return_type.te, &et) {
    case Error(pm):
      return Printed(pm);
    case Success: { }
    case NotAccessible:
      return NoFail(NoMatchConstructor);
    }
    rhs_type *te_typeexpr;
    decl_index size;
    if !find_vardecl(&et->constructors, name, &rhs_type, &decl_index) {
      return NoFail(NoMatchConstructor);
    }
    // rhs_type is complete.
    unified te_typeexpr;
    if !unify_types(arg_type, rhs_type, &unified) {
      return NoFail(NoMatchConstructor);
    }
    ctor_type te_typeexpr = fn_type(ds->cs, *rhs_type, cac_return_type.te);
    cac_ctor_type cac_typeexpr;
    #noscoped_check_and_compute_typeexpr(ds->clq, &ctor_type, &cac_ctor_type);
    check(cac_ctor_type.complete);

    ip instpair = #lookup_or_make_enum_constructor_def(ds, et, &cac_return_type.te, &cac_ctor_type.te, decl_index);

    return NoFail(@[ds_constructor_res]MatchedConstructor({~cac_ctor_type.te, mk_enum_tag_value(decl_index), ip}));
  }
}

// return_type is the return type of ctor_type.  Both are complete and computed.
func lookup_or_make_enum_constructor_def(ds *defscope, et *enumspec, return_type *te_typeexpr, ctor_type *te_typeexpr, decl_index size) cr[instpair] {
  defname_u8 array[u8] = _u8("$magic_enum_ctor_");
  build_u8str(void, &defname_u8, &decl_index);
  defname sym = intern(ds->im, from_u8(defname_u8));

  nogp genparms = NoParms;
  if true {
    res match_def_res;
    #match_def(ds->cs, defname, &nogp, ctor_type, &res);
    switch &res {
      case &NoMatch: {
        // Do nothing.
      }
      case &MultiMatch: {
        ice(_u8("magic_enum_ctor lookup sees MultiMatch"));
      }
      case &OneMatch(m ent_and_parms): {
        inst_id def_inst_id;
        if !from_np(make_inst(ds->clq, m.ent, &m.parms, &inst_id)) {
          ice(_u8("lookup_or_make_enum_constructor_def make_inst failed after match"));
        }
        return NoFail({m.ent, inst_id});
      }
    }
  }

  // There was no match -- so we make the def ourselves.
  rhs_type *te_typeexpr = &ref(&et->constructors, decl_index)->type;
  rhs_props type_properties;
  #compute_complete_type_properties(ds->clq, rhs_type, &rhs_props);

  meco magic_enum_construct_op;
  switch &rhs_props.move_behavior {
    case &DerivedMethodAbsent: {
      copy_desc ctor_desc = #behavior_to_desc(&rhs_props.copy_behavior);
      destroy_desc ctor_desc = #behavior_to_desc(&rhs_props.destroy_behavior);
      meco = EnumConstructCopyDestroy({copy_desc, destroy_desc});
    }
    case &DerivedMethodExplicit(ip instpair): {
      meco = EnumConstructMove(FunCtor(ip));
    }
    case &DerivedMethodNontrivial(ip instpair): {
      meco = EnumConstructMove(FunCtor(ip));
    }
    case &DerivedMethodTrivial: {
      meco = EnumConstructMove(TrivialCtor);
    }
  }

  return_type_props type_properties;
  #compute_complete_type_properties(ds->clq, return_type, &return_type_props);

  mec magic_enum_construct = {*et, ~ *return_type, return_type_props, decl_index, rhs_props, meco};

  ent def_entry_id = add_def_primitive(ds->cs, defname, NoGenerics, *ctor_type, @[def_definition]DefnMagic(MagicEnumConstruct(mec)));
  inst_id def_inst_id;
  if !from_np(make_inst(ds->clq, ent, &nogp, &inst_id)) {
    ice(_u8("lookup_or_make_enum_constructor_def make_inst failed on fresh def"));
  }

  return NoFail({ent, inst_id});
}

struct es_global_match {
  ent_id def_entry_id;
  inst_id def_inst_id;
  parms genparms;
}

enum es_match_res {
  NoMatch void;
  AmbigGlobalMatch void;
  NoGlobalAmbigEnumConstructorMatch void;
  OneGlobalMatch es_global_match;
  OneLocalMatch local_info;
  OneEnumConstructorMatch constructor_info;
  EnumVoidConstructedMatch voidconstructed_info;
}

func es_lookup_name(es *framescope, name sym, gp *genparms, pt *te_typeexpr, res_out *es_match_res) np {
  if case &NoParms = gp {
    if case Has(num var_number) = es_find_current_local(es, name) {
      type te_typeexpr;
      vartype *cu_typeexpr = &ref_var(es, num)->type;
      if !unify_types(pt, &vartype->x, &type) {
        return ERR(_u8("local '"), lookup(es->im, name), _u8("' has wrong type: '"), pretty(es->im, vartype), _u8("' where '"), pretty(es->im, pt), _u8("' expected"));
      }
      *res_out = OneLocalMatch({num});
      return NoFail;
    }
  }

  res match_def_res;
  #match_def(es->cs, name, gp, pt, &res);

  switch &res {
    case &NoMatch: {
      constructor_res ds_constructor_res = #ds_lookup_constructor(es->ds, name, gp, pt);
      switch &constructor_res {
      case &NoMatchConstructor:
        *res_out = NoMatch;
      case &AmbigMatchConstructor:
        *res_out = NoGlobalAmbigEnumConstructorMatch;
      case &MatchedConstructor(inf constructor_info):
        *res_out = OneEnumConstructorMatch(inf);
      case &MatchedVoidConstructed(inf voidconstructed_info):
        *res_out = EnumVoidConstructedMatch(inf);
      }
      return NoFail;
    }
    case &MultiMatch: {
      *res_out = AmbigGlobalMatch;
      return NoFail;
    }
    case &OneMatch(m ent_and_parms): {
      inst_id def_inst_id;
      #make_inst(es->clq, m.ent, &m.parms, &inst_id);
      *res_out = OneGlobalMatch({m.ent, inst_id, m.parms});
      return NoFail;
    }
  }
}

func es_find_current_local(es *framescope, name sym) opt[var_number] {
  n size = count(&es->current_vars);
  for i size = 0; i < n; i = i + 1 {
    num var_number = es->current_vars[i];
    inf *var_info = ref_var(es, num);
    if case Has(s sym) = inf->name {
      if s == name {
        return Has(num);
      }
    }
  }
  return None;
}

func help_check_simple_literal(es *framescope, pt *te_typeexpr, type te_typeexpr, errmsg_name array[u8], x *ast_expr) np {
  unified te_typeexpr;
  if !unify_types(pt, &type, &unified) {
    return ERR(errmsg_name, _u8(" literal in bad place"));
  }
  if is_complete(&unified) {
    c cac_typeexpr;
    if !from_np(noscoped_check_and_compute_typeexpr(es->clq, &unified, &c)) {
      ice(_u8("help_check_simple_literal passed bad type"));
    }
    check(c.complete);
    props type_properties;
    if !from_np(compute_complete_type_properties(es->clq, &c.te, &props)) {
      ice(_u8("help_check_simple_literal passed type with bad properties"));
    }

    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~c.te, props})), ~c.te, props)));
  } else {
    annotate_info(x, @[ast_expr_info]IncompleteCheck);
  }
  return NoFail;
}

// pt is either (a) incomplete, or (b) complete and computed.
func check_expr_ai(es *framescope, ai allow_incomplete, x *ast_expr, pt *te_typeexpr) np {
  if case &CompleteCheck(t ast_expr_complete_info) = &x->info {
    return NoFail;
  }

  if case Printed(printed_meta bool) = help_check_expr_ai(es, ai, x, pt) {
    if !printed_meta {
      // TODO: Get rid of this terrible hackish way to error message.
      return MERR(es->cs, x->meta, _u8(" in this expression"));
    } else {
      return Printed(printed_meta);
    }
  }

  return NoFail;
}

func help_check_expr_ai(es *framescope, ai allow_incomplete, x *ast_expr, pt *te_typeexpr) np {
  switch &x->u {
    case &NameExpr(a ast_name_expr):
      return check_expr_name(es, ai, &a, pt, x);

    case &ParenExpr(a ast_paren_expr):
      #check_expr_ai(es, ai, oo(&a.expr), pt);
      annotate_info(x, oo(&a.expr)->info);
      return NoFail;

    case &NumericLiteral(a ast_numeric_literal):
      return check_numeric_literal(es, ai, pt, numeric_literal_value(&a), x);

    case &BoolLiteral(a ast_bool_literal):
      return help_check_simple_literal(es, pt, primitive_bool_type(es->cs), _u8("bool"), x);

    case &VoidLiteral(a ast_void_literal):
      return help_check_simple_literal(es, pt, primitive_void_type(es->cs), _u8("void"), x);

    case &NullLiteral(a ast_null_literal):
      return help_check_simple_literal(es, pt, ptr_type(es->cs, TeUnknown), _u8("null"), x);

    case &CharLiteral(a ast_char_literal):
      return check_numeric_literal(es, ai, pt, ~a.charspec.value, x);

    case &StringLiteral(a ast_string_literal):
      return check_expr_string_literal(es, &a, pt, x);

    case &Funcall(a ast_funcall):
      return check_expr_funcall(es, ai, &a, pt, x);

    case &LogicalConjunction(a ast_logical_conjunction):
      return check_expr_logical_conjunction(es, &a, pt, x);

    case &Assignment(a ast_assignment):
      return check_expr_assignment(es, &a, pt, x);

    case &RefOf(a ast_refof):
      return check_expr_refof(es, &a, pt, x);

    case &AddressOf(a ast_addressof):
      return check_expr_addressof(es, &a, pt, x);

    case &Deref(a ast_deref):
      return check_expr_deref(es, &a, pt, x);

    case &IndexExpr(a ast_index_expr):
      return check_expr_index(es, &a, pt, x);

    case &Lambda(a ast_lambda):
      return check_expr_lambda(es, &a, pt, x);

    case &LocalField(a ast_local_field):
      return check_expr_local_field(es, &a, pt, x);

    case &DerefField(a ast_deref_field):
      return check_expr_deref_field(es, &a, pt, x);

    case &TypedExpr(a ast_typed_expr):
      return check_expr_typed_expr(es, ai, &a, pt, x);

    case &Strinit(a ast_strinit):
      return check_expr_strinit(es, ai, &a, pt, x);

    case &Ternary(a ast_ternary):
      return check_expr_ternary(es, ai, &a, pt, x);

    case &QuickReturn(a ast_quickreturn):
      return check_expr_quickreturn(es, ai, &a, pt, x);
  }
}

func success_enum_case_info(ds *defscope, cu *cu_typeexpr, success_case_ix_out *size, et_out **enumspec) np {
  et *enumspec;
  switch structural_enumspec(ds, &cu->x, &et) {
  case Error(pm):
    return Printed(pm);
  case Success:
    if case Has(ix size) = et->success_case_ix {
      *success_case_ix_out = ix;
      *et_out = et;
      return NoFail;
    } else {
      return ERR(_u8("Bad type (enum without success case) in quick-return"));
    }
  case NotAccessible:
    return ERR(_u8("Bad type (not enum) in quick-return"));
  }
}

func structurally_convertible_in_non_success(ds *defscope, rhs_success_ix size, rhs_constructors *shray[te_vardecl], return_success_ix size, return_et *enumspec, out *bool, constructor_mapping_out *array[size]) np {
  // For now we're going to be uber-restrictive and require exactly the same constructor ordering (and of course exactly the same enum case types).  "Structurally convertible" is designed around generic enum types like opt[T] or cr[T].

  n size = count(rhs_constructors);
  if n != count(&return_et->constructors) || rhs_success_ix != return_success_ix {
    *out = false;
    return NoFail;
  }

  constructor_mapping array[size];
  for i size = 0; i < n; i = i + 1 {
    push(&constructor_mapping, i);
    if i != rhs_success_ix {
      rhs_constructor *te_vardecl = ref(rhs_constructors, i);
      return_constructor *te_vardecl = ref(&return_et->constructors, i);
      if rhs_constructor->name != return_constructor->name {
        *out = false;
        return NoFail;
      }
      if !help_idy_typeexpr_equal(&rhs_constructor->type, &return_constructor->type) {
        *out = false;
        return NoFail;
      }
    }
  }

  *out = true;
  swap(constructor_mapping_out, &constructor_mapping);
  return NoFail;
}

func check_expr_quickreturn(es *framescope, ai allow_incomplete, a *ast_quickreturn, pt *te_typeexpr, x *ast_expr) np {
  if case Has(return_type *cu_typeexpr) = es->return_type {
    // In order for a quickreturn expression to be valid, the following must be true:
    //   a. the rhs must be an enum type with a success case
    //   b. the pt must be the success case's inside type
    //   c. the return type of the fullbody we're in must be an enum type that is "structurally convertible in the non-success cases" from the rhs enum type.  For example, opt[foo] is structurally convertible (in the non-success cases) from opt[bar].
    //
    // Because the rhs can be _any_ enum type, for now we'll evaluate the rhs with no pt, and AllowIncompleteNo, and then see if that matches up with the lhs.  Eventually we can implement "looking through the enum" logic -- that will be necessary for arithmetic overflow.

    rhs_pt te_typeexpr = TeUnknown;
    #check_expr_ai(es, AllowIncompleteNo, oo(&a->rhs), &rhs_pt);

    rhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->rhs));

    success_case_ix size;
    et *enumspec;
    #success_enum_case_info(es->ds, &rhs_info->cu, &success_case_ix, &et);

    success_case_type *te_typeexpr = &ref(&et->constructors, success_case_ix)->type;

    unified te_typeexpr;
    if !unify_types(pt, success_case_type, &unified) {
      return ERR(_u8("quick-return expr has bad type"));
    }

    return_success_case_ix size;
    return_et *enumspec;
    #success_enum_case_info(es->ds, return_type, &return_success_case_ix, &return_et);

    is_structurally_convertible bool;
    constructor_mapping array[size];
    #structurally_convertible_in_non_success(es->ds, success_case_ix, &et->constructors, return_success_case_ix, return_et, &is_structurally_convertible, &constructor_mapping);
    if !is_structurally_convertible {
      return ERR(_u8("quick-return types not structurally convertible"));
    }

    success_case_cu cu_typeexpr = ~ *success_case_type;
    success_case_props type_properties;
    #compute_type_properties(es->clq, &success_case_cu, &success_case_props);

    lval is_lval;
    switch &rhs_info->lval {
    case &IsLvalYes(desc lval_description):
      lval = IsLvalYes({add_cell(es, {LocationVirtual, success_case_cu, success_case_props}), DeadMe, enum_field_ipse(desc.ipse)});
    case &IsLvalNo(desc rval_description):
      lval = IsLvalNo({desc.whole_num, add_cell(es, {LocationVirtual, success_case_cu, success_case_props})});
    }

    annotate_info(x, CompleteCheck(mk(lval, success_case_cu, success_case_props)));

    tag_cell cell_num = add_virtual_tag_cell(es, et);
    return_tag_cell cell_num = add_virtual_tag_cell(es, et);
    annotate(&a->info, {tag_cell, *et, return_tag_cell, *return_et, constructor_mapping});

    return NoFail;
  } else {
    return ERR(_u8("quick-return expression outside body"));
  }
}

func check_expr_refof(es *framescope, a *ast_refof, pt *te_typeexpr, x *ast_expr) np {
  ref_skeleton te_typeexpr = mk_ref_type(es->cs, TeUnknown, TeUnknown);
  unif_pt te_typeexpr;
  if !unify_types(pt, &ref_skeleton, &unif_pt) {
    return ERR(_u8("RefOf expr in non-ref context"));
  }

  pt_ipse *te_typeexpr;
  pt_param *te_typeexpr;
  if !decompose_ref(&unif_pt, es->cs, &pt_ipse, &pt_param) {
    ice(_u8("RefOf sees non-ref after unifying with ref."));
  }

  // We require complete matching because addressof requires it.  Addressof says meh, the rhs should be some crystal clear lvalue anyway.
  #check_expr_ai(es, AllowIncompleteNo, oo(&a->rhs), pt_param);

  rhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->rhs));
  switch &rhs_info->lval {
  case &IsLvalNo(desc rval_description):
    // TODO: Support taking reference of an rvalue -- have it become a temporary that expires... when it can.
    return ERR(_u8("Taking reference of a non-lvalue"));
  case &IsLvalYes(desc lval_description):
    unified_ipse te_typeexpr;
    if !unify_types(pt_ipse, &desc.ipse, &unified_ipse) {
      return ERR(_u8("Refof ipse types do not match."));
    }

    ref_type te_typeexpr = mk_ref_type(es->cs, unified_ipse, rhs_info->cu.x);
    ref_computed cac_typeexpr;
    #noscoped_check_and_compute_typeexpr(es->clq, &ref_type, &ref_computed);
    // (TODO: Make lval desc.ipse be a te_ipse, so it can't be incomplete?)
    if !ref_computed.complete {
      return ERR(_u8("ICE?  lval desc.ipse must have been incomplete (after complete type-check)."));
    }

    ref_props type_properties;
    #compute_complete_type_properties(es->clq, &ref_computed.te, &ref_props);
    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ref_computed.te, ref_props})), ~ref_computed.te, ref_props)));
    return NoFail;
  }
}

func check_expr_ternary(es *framescope, ai allow_incomplete, a *ast_ternary, pt *te_typeexpr, x *ast_expr) np {
  boolean cu_typeexpr = compute_prim(es->clq, primitive_bool_type(es->cs));
  #check_consume_then_discard_expr(es, oo(&oo(&a->condition)->expr), &boolean.x, &oo(&a->condition)->discard);
  #check_expr_consume(es, oo(&a->then_clause), pt);
  #check_expr_consume(es, oo(&a->else_clause), pt);

  conjoined cell_num;
  if true {
    then_cell *cell_info = ref_cell(es, result_cell(oo(&a->then_clause)));
    conjoined = add_cell(es, {LocationStatic, then_cell->type, then_cell->props});
  }
  reannotate_static_to_virtual(es, result_cell(oo(&a->then_clause)));
  reannotate_static_to_virtual(es, result_cell(oo(&a->else_clause)));
  conj *cell_info = ref_cell(es, conjoined);
  annotate_info(x, @[ast_expr_info]CompleteCheck({IsLvalNo({conjoined, conjoined}), conj->type, conj->props}));
  return NoFail;
}

func check_expr_typed_expr(es *framescope, ai allow_incomplete, a *ast_typed_expr, pt *te_typeexpr, x *ast_expr) np {
  // TODO: Cache converted.
  converted te_typeexpr = #convert_typeexpr(&a->type);
  // We call check_and_compute_typeexpr to disallow totally bogus typeexprs more directly than the eventual type error that would happen.
  computed cac_typeexpr;
  #check_and_compute_typeexpr(es->clq, es->ds->generics, es->ds->repls, &converted, &computed);
  unified te_typeexpr;
  if !unify_types(pt, &computed.te, &unified) {
    return ERR(_u8("TypedExpr is incompatible with contextual type."));
  }
  unified_computed cac_typeexpr;
  if computed.complete {
    unified_computed = computed;
  } else {
    if !from_np(noscoped_check_and_compute_typeexpr(es->clq, &unified, &unified_computed)) {
      return ERR(_u8("TypedExpr encounters un-computable unified type."));
    }
  }
  #check_expr_ai(es, ai, oo(&a->expr), &unified_computed.te);
  annotate_info(x, oo(&a->expr)->info);
  return NoFail;
}

func check_expr_deref_field(es *framescope, a *ast_deref_field, pt *te_typeexpr, x *ast_expr) np {
  // The fact that our partial type isn't a pointer type is deliberate.
  unknown te_typeexpr = TeUnknown;
  #check_consume_then_discard_expr(es, oo(&a->lhs), &unknown, &a->ptr_discard);
  info *ast_expr_complete_info = expr_complete_info(&oo(&a->lhs)->expr);
  ipse te_typeexpr;
  param *te_typeexpr;
  if !decompose_ref_or_ptr(&info->cu.x, es->cs, &ipse, &param) {
    return ERR(_u8("Expected pointer for lhs of deref field"));
  }
  cu_param cu_typeexpr = ~ *param;
  fieldtype cu_typeexpr;
  cf_res check_field_result;
  #check_field(es, &cu_param, &a->fieldname, pt, &fieldtype, &cf_res);
  props type_properties;
  #compute_type_properties(es->clq, &fieldtype, &props);
  lval is_lval;
  switch cf_res {
    case InheritsLval(offset u32): {
      // We deref, so it's always an lval.
      lval = IsLvalYes({add_cell(es, {LocationVirtual, fieldtype, props}), DeadMe, field_ipse(ipse)});
      annotate(&a->info, DerefFieldName(offset));
    }
    case ConstantField(value u32): {
      lval = wholeRval(add_cell(es, {LocationStatic, fieldtype, props}));
      annotate(&a->info, DerefArrayLength(value));
    }
  }
  annotate_info(x, CompleteCheck(mk(lval, fieldtype, props)));
  return NoFail;
}

// Right now fields have the same ipse as what they're part of -- they're part of the same object!  So, having equal ipses does not mean you're the same object.
func field_ipse(outer_ipse te_typeexpr) te_typeexpr {
  return outer_ipse;
}

// This is halfway B.S. the same way that field_ipse is.
func enum_field_ipse(outer_ipse te_typeexpr) te_typeexpr {
  return outer_ipse;
}

// Varnames aren't supposed to shadow, so... we have user-friendly ipse names.  (Note that vars could shadow generic ipse parameters, for now, so we add the $var_ prefix.)
func varname_ipse(im *identmap, name sym) te_typeexpr {
  n sym = intern(im, _s("$var_") + lookup(im, name));
  return TeIpse({n});
}

// TODO: Most uses of this will get replaced by some rval ipse getter.  (We'll set rval ipses with this value, though.)
func unnamed_ipse(es *framescope) te_typeexpr {
  n sym = intern(es->im, _s("$frame_") + from_u8(to_u8str(void, es->ipse_gen_counter)));
  es->ipse_gen_counter = es->ipse_gen_counter + 1;
  return TeIpse({n});
}

func check_expr_local_field(es *framescope, a *ast_local_field, pt *te_typeexpr, x *ast_expr) np {
  unknown te_typeexpr = TeUnknown;
  #check_expr_ai(es, AllowIncompleteNo, oo(&a->lhs), &unknown);
  info *ast_expr_complete_info = expr_complete_info(oo(&a->lhs));
  fieldtype cu_typeexpr;
  cf_res check_field_result;
  #check_field(es, &info->cu, &a->fieldname, pt, &fieldtype, &cf_res);
  props type_properties;
  #compute_type_properties(es->clq, &fieldtype, &props);
  lval is_lval;
  switch cf_res {
    case InheritsLval(offset u32): {
      switch &info->lval {
        case &IsLvalYes(desc lval_description): {
          lval = IsLvalYes({add_cell(es, {LocationVirtual, fieldtype, props}), DeadMe, field_ipse(desc.ipse)});
        }
        case &IsLvalNo(desc rval_description): {
          lval = IsLvalNo({desc.whole_num, add_cell(es, {LocationVirtual, fieldtype, props})});
        }
      }
      // There's no disposal, it's a real field access.
      annotate(&a->info, FieldName(offset));
    }
    case ConstantField(value u32): {
      after nc[ast_expr_after_discard] = NotComputed;
      #annotate_disposal_for_discard(es, oo(&a->lhs), &after);
      annotate(&a->info, @[ast_local_field_info]ArrayLength({*un(&after), value}));
      lval = wholeRval(add_cell(es, {LocationStatic, fieldtype, props}));
    }
  }
  annotate_info(x, CompleteCheck(mk(lval, fieldtype, props)));
  return NoFail;
}

func check_expr_deref(es *framescope, a *ast_deref, pt *te_typeexpr, x *ast_expr) np {
  ptr_pt te_typeexpr = TeUnknown;
  // Let's force the rhs to be a complete type.  Because why not!
  #check_consume_then_discard_expr(es, oo(&a->rhs), &ptr_pt, &a->ptr_discard);
  rhs_type *cu_typeexpr = expr_complete_type(&oo(&a->rhs)->expr);
  ipse te_typeexpr;
  param *te_typeexpr;
  if decompose_ref_or_ptr(&rhs_type->x, es->cs, &ipse, &param) {
    // param is already complete.
    unified_discard te_typeexpr;
    if !unify_types(pt, param, &unified_discard) {
      return ERR(_u8("Pointer dereferences into wrong type."));
    }

    props type_properties;
    #compute_complete_type_properties(es->clq, param, &props);
    annotate_info(x, CompleteCheck(mk(@[is_lval]IsLvalYes({add_cell(es, {LocationVirtual, ~ *param, props}), DeadMe, ipse}), ~ *param, props)));
    return NoFail;
  }
  return ERR(_u8("Trying to deref a non-pointer, non-reference."));
}

func check_expr_addressof(es *framescope, a *ast_addressof, pt *te_typeexpr, x *ast_expr) np {
  ptr_skeleton te_typeexpr = ptr_type(es->cs, TeUnknown);
  unif_pt te_typeexpr;
  if !unify_types(pt, &ptr_skeleton, &unif_pt) {
    return ERR(_u8("AddressOf expr in non-pointer context"));
  }
  param *te_typeexpr;
  if !decompose_typeapp(&unif_pt, primitive_pointer_puretype(es->cs), &param) {
    ice(_u8("AddressOf sees non-pointer after unifying with pointer."));
  }
  // We require complete matching, because, meh, the rhs should be some crystal clear lvalue anyway.
  #check_expr_ai(es, AllowIncompleteNo, oo(&a->rhs), param);
  rhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->rhs));
  if case &IsLvalNo(desc rval_description) = &rhs_info->lval {
    // TODO: Support taking address of an rvalue -- have it become a temporary that expires at the end of the full expression.
    return ERR(_u8("Taking address of a non-lvalue"));
  }

  ptr_type te_typeexpr = ptr_type(es->cs, rhs_info->cu.x);
  ptr_computed cac_typeexpr;
  #noscoped_check_and_compute_typeexpr(es->clq, &ptr_type, &ptr_computed);
  check(ptr_computed.complete);
  ptr_props type_properties;
  #compute_complete_type_properties(es->clq, &ptr_computed.te, &ptr_props);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ptr_computed.te, ptr_props})), ~ptr_computed.te, ptr_props)));
  return NoFail;
}

func check_expr_assignment(es *framescope, a *ast_assignment, pt *te_typeexpr, x *ast_expr) np {
  void_type te_typeexpr = primitive_void_type(es->cs);
  unified te_typeexpr;
  if !unify_types(pt, &void_type, &unified) {
    return ERR(_u8("ICE: assignment in non-void place"));
  }

  if !is_complete(&unified) {
    ice(_u8("check_expr_assignment incomplete successful unification with void"));
  }

  c cac_typeexpr;
  if !from_np(noscoped_check_and_compute_typeexpr(es->clq, &unified, &c)) {
    ice(_u8("check_expr_assignment sees void bad type"));
  }
  check(c.complete);
  props type_properties;
  if !from_np(compute_complete_type_properties(es->clq, &c.te, &props)) {
    ice(_u8("check_expr_assignment void bad props"));
  }

  unknown te_typeexpr = TeUnknown;
  // We check the lhs independently of the rhs, deliberately, to ensure clarity.
  #check_expr_ai(es, AllowIncompleteNo, oo(&a->lhs), &unknown);
  lhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->lhs));
  switch &lhs_info->lval {
    case &IsLvalNo(desc rval_description): {
      return ERR(_u8("Assigning to non-lvalue"));
    }
    case &IsLvalYes(desc lval_description): {
      #check_expr_ai(es, AllowIncompleteNo, oo(&a->rhs), &lhs_info->cu.x);
      #annotate_disposal_for_assignment(es, desc.num, oo(&a->rhs), a);
      annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~c.te, props})), ~c.te, props)));
      return NoFail;
    }
  }
}

func behavior_to_desc(b *derived_method_behavior) cr[ctor_desc] {
  switch b {
  case &DerivedMethodAbsent:
    return ERR(_u8("Cannot find derived method."));
  case &DerivedMethodExplicit(ip instpair):
    return NoFail(FunCtor(ip));
  case &DerivedMethodNontrivial(ip instpair):
    return NoFail(FunCtor(ip));
  case &DerivedMethodTrivial:
    return NoFail(TrivialCtor);
  }
}

func computed_ptr_type(clq *clqueue, t *cu_typeexpr) cu_typrop {
  return compute_prim(clq, ptr_type(clq->cs, t->x));
}

func get_init_ctor(clq *clqueue, t *cu_typeexpr) cr[ctor_desc] {
  props type_properties;
  #compute_type_properties(clq, t, &props);
  return behavior_to_desc(&props.init_behavior);
}

func get_copy_ctor(clq *clqueue, t *cu_typeexpr) cr[ctor_desc] {
  props type_properties;
  #compute_type_properties(clq, t, &props);
  return behavior_to_desc(&props.copy_behavior);
}

func get_move_ctor(clq *clqueue, t *cu_typeexpr) cr[ctor_desc] {
  props type_properties;
  #compute_type_properties(clq, t, &props);
  return behavior_to_desc(&props.move_behavior);
}

func get_destroy_ctor(clq *clqueue, t *cu_typeexpr) cr[ctor_desc] {
  props type_properties;
  #compute_type_properties(clq, t, &props);
  return behavior_to_desc(&props.destroy_behavior);
}

func annotate_disposal_for_consume(es *framescope, a *ast_expr, after *nc[ast_expr_after_consume]) np {
  movable_cells shray[opt[cell_num]];
  moved_cell_ix_discard opt[size];
  return annotate_disposal_for_consume(es, a, &movable_cells, after, &moved_cell_ix_discard);
}

// Annotates the disposal to "consume" the value -- i.e. what happens if it's a function param or otherwise a "use-once" value (i.e. to be copied/moved into a param list, or whatever).
func annotate_disposal_for_consume(es *framescope, a *ast_expr, movable_cells *shray[opt[cell_num]], after *nc[ast_expr_after_consume], moved_cell_ix_out *opt[size]) np {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
    case &IsLvalNo(desc rval_description): {
      if whole_temporary(&desc) {
        annotate(after, mk_after(@[consume_actions]ConsumeByInPlace, desc.whole_num));
      } else {
        copy ctor_desc = #get_copy_ctor(es->clq, &info->cu);
        destroy ctor_desc = #get_destroy_ctor(es->clq, &ref_cell(es, desc.whole_num)->type);
        dest cell_num = add_cell(es, {LocationStatic, info->cu, info->cu_props});
        annotate(after,
          mk_after(@[consume_actions]ConsumeByCopyDestroy({+{copy, dest, desc.partial_num},
                                                           +{destroy, desc.whole_num}}),
                   dest));
      }
      *moved_cell_ix_out = None;
    }
    case &IsLvalYes(desc lval_description): {
      dest cell_num = add_cell(es, {LocationStatic, info->cu, info->cu_props});
      if case Has(ix size) = find(movable_cells, Has(desc.num)) {
        move ctor_desc = #get_move_ctor(es->clq, &info->cu);
        annotate(after, mk_after(@[consume_actions]ConsumeByMove(@[move_action]+{move, dest, desc.num}), dest));
        *moved_cell_ix_out = Has(ix);
      } else {
        copy ctor_desc = #get_copy_ctor(es->clq, &info->cu);
        annotate(after, mk_after(@[consume_actions]ConsumeByCopy({@[copy_action]+{copy, dest, desc.num}, desc.deadme}), dest));
        *moved_cell_ix_out = None;
      }
    }
  }
  return NoFail;
}

// Annotates the disposal of an Expr statement's expr, or some other value we are done using.
func annotate_disposal_for_discard(es *framescope, a *ast_expr, after *nc[ast_expr_after_discard]) np {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
    case &IsLvalNo(desc rval_description): {
      destroy ctor_desc = #get_destroy_ctor(es->clq, &ref_cell(es, desc.whole_num)->type);
      annotate(after, mk_after_discard(@[destroy_action]+{destroy, desc.whole_num}));
    }
    case &IsLvalYes(desc lval_description): {
      if case DeadMe = desc.deadme {
        // This could ostensibly be Has(desc.num), but there's no reason to be inconsistent with the rvalue case.
        annotate(after, mk_virtualdead_discard(desc.num));
      } else {
        annotate(after, mk_nothing_discard());
      }
    }
  }
  return NoFail;
}


// Annotates the disposal for a value we'll use but then discard.
func annotate_disposal_for_consume_then_discard(es *framescope, a *ast_expr, after *nc[ast_expr_after_consume], later *ast_later_discard_info) np {
  #annotate_disposal_for_consume(es, a, after);

  info *ast_expr_complete_info = expr_complete_info(a);
  destroy ctor_desc = #get_destroy_ctor(es->clq, &info->cu);
  annotate(&later->action, @[destroy_action]+{destroy, result_cell(un(after))});

  return NoFail;
}

func make_comparecells(es *framescope, dest cell_num) instpair {
  if case Has(ent def_entry_id) = es->cs->prims.ptr_eq {
    ipse_names array[sym];
    canonical te_typeexpr;
    canonicalize_idy_ipses(es->im, &ipse_names, &ref_cell(es, dest)->type.x, &canonical);
    parms idy_genparms = {count(&ipse_names), {mk_shray(~canonical)}};
    inst_id def_inst_id = enqueue_def_inst(es->clq, ent, &parms);
    return {ent, inst_id};
  } else {
    ice(_u8("cs->prims.ptr_eq not initialized"));
    return fake();
  }
}

func annotate_disposal_for_assignment(es *framescope, dest cell_num, a *ast_expr, assignment *ast_assignment) np {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
    case &IsLvalNo(desc rval_description): {
      target_destroy ctor_desc = #get_destroy_ctor(es->clq, &ref_cell(es, dest)->type);
      if whole_temporary(&desc) {
        move ctor_desc = #get_move_ctor(es->clq, &ref_cell(es, dest)->type);
        annotate(&assignment->info,
          @[ast_assignment_info]
          SimpleMoveAssignment({@[destroy_action]+{target_destroy, dest},
                                @[move_action]+{move, dest, desc.whole_num}}));
      } else {
        // TODO: This dups code with other makers of DisposeCopyAndDestroy.
        copy ctor_desc = #get_copy_ctor(es->clq, &ref_cell(es, dest)->type);
        destroy ctor_desc = #get_destroy_ctor(es->clq, &ref_cell(es, desc.whole_num)->type);

        annotate(&assignment->info,
          @[ast_assignment_info]
          SimpleCopyDestroyAssignment({@[destroy_action]+{target_destroy, dest},
                                       @[copy_action]+{copy, dest, desc.partial_num},
                                       @[destroy_action]+{destroy, desc.whole_num}}));
      }
    }
    case &IsLvalYes(desc lval_description): {
      if dest == desc.num {
        // Static self-assignment!
        annotate(&assignment->info, StaticSelfAssignment);
      } else {
        target_destroy ctor_desc = #get_destroy_ctor(es->clq, &ref_cell(es, dest)->type);
        copy ctor_desc = #get_copy_ctor(es->clq, &ref_cell(es, dest)->type);
        do_conditional bool;
        switch &target_destroy {
        case &TrivialCtor:
          switch &copy {
          case &TrivialCtor:
            do_conditional = false;
          case &FunCtor(bfcd):
            do_conditional = true;
          }
        case &FunCtor(ip instpair):
          do_conditional = true;
        }
        if do_conditional {
          annotate(&assignment->info,
            @[ast_assignment_info]
            ConditionalAssignment({make_comparecells(es, dest),
                                   @[destroy_action]+{target_destroy, dest},
                                   @[copy_action]+{copy, dest, desc.num},
                                   desc.deadme}));
        } else {
          annotate(&assignment->info,
            @[ast_assignment_info]
            SimpleCopyAssignment({@[destroy_action]+{target_destroy, dest},
                                  @[copy_action]+{copy, dest, desc.num},
                                  desc.deadme}));
        }
      }
    }
  }
  return NoFail;
}

func check_expr_name(es *framescope, ai allow_incomplete, a *ast_name_expr, pt *te_typeexpr, x *ast_expr) np {
  parms genparms;
  #replaced_name_parms(es->ds, a, &parms);
  match_res es_match_res;
  #es_lookup_name(es, a->ident.value, &parms, pt, &match_res);
  switch &match_res {
    case &NoMatch: {
      return MERR(es->cs, a->ident.meta, _u8("Name lookup for '"), lookup(es->im, a->ident.value), _u8("', maybe with parms, not found, matching type '"), pretty(es->im, pt), _u8("'"));
    }
    case &AmbigGlobalMatch: {
      if ai == AllowIncompleteYes {
        // NOTE: We could annotate this more precisely in ambiguous-single-match cases.
        annotate_info(x, @[ast_expr_info]IncompleteCheck);
        return NoFail;
      } else {
        return MERR(es->cs, a->ident.meta, _u8("Name lookup for '"), lookup(es->im, a->ident.value), _u8("', maybe with parms, matches ambiguously over "), pretty(es->im, pt));
      }
    }
    case &NoGlobalAmbigEnumConstructorMatch: {
      if ai == AllowIncompleteYes {
        annotate_info(x, @[ast_expr_info]IncompleteCheck);
        return NoFail;
      } else {
        return MERR(es->cs, a->ident.meta, _u8("Name lookup for '"), lookup(es->im, a->ident.value), _u8("', maybe with parms, not found, but cannot rule out enum constructor, on type '"), pretty(es->im, pt));
      }
    }
    case &OneEnumConstructorMatch(ci constructor_info): {
      annotate(&a->name_info, @[ast_name_expr_info]EnumConstructor({ci.constructor_tag, ci.ip}));
      props type_properties;
      #compute_type_properties(es->clq, &ci.type, &props);
      annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ci.type, props})), ci.type, props)));
      return NoFail;
    }
    case &EnumVoidConstructedMatch(vci voidconstructed_info): {
      annotate(&a->name_info, @[ast_name_expr_info]EnumVoidConstructed({vci.constructor_tag, vci.et}));
      props type_properties;
      #compute_type_properties(es->clq, &vci.constructed_type, &props);
      annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, vci.constructed_type, props})), vci.constructed_type, props)));
      return NoFail;
    }
    case &OneGlobalMatch(egm es_global_match): {
      ent *def_entry = ref_def_entry(es->cs, egm.ent_id);

      // This parallels or plagairizes ensure_def_inst_type_computed.
      // TODO: Dedup anything?
      matched_parms idy_repls;
      #check_and_compute_parms_no_canonicalize(es->clq, &egm.parms, &matched_parms);

      ent_typeexpr *te_typeexpr;
      #def_converted_typeexpr(es->cs, ent, &ent_typeexpr);

      computed cac_typeexpr;
      #check_and_compute_typeexpr(es->clq, &ent->generics, &matched_parms, ent_typeexpr, &computed);

      check(computed.complete);
      cu_computed cu_typeexpr = ~computed.te;
      props type_properties;
      #compute_type_properties(es->clq, &cu_computed, &props);

      annotate(&a->name_info, @[ast_name_expr_info]GlobalResolve({egm.ent_id, egm.inst_id}));
      annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, cu_computed, props})), cu_computed, props)));
      return NoFail;
    }
    case &OneLocalMatch(v local_info): {
      annotate(&a->name_info, @[ast_name_expr_info]LocalResolve({v.varnum}));
      vi *var_info = ref_var(es, v.varnum);
      annotate_info(x, CompleteCheck(mk(@[is_lval]IsLvalYes({vi->cell, DontDeadMe, vi->ipse.x}), vi->type, vi->props)));
      return NoFail;
    }
  }
}

func check_expr_string_literal(es *framescope, a *ast_string_literal, pt *te_typeexpr, x *ast_expr) np {
  type cu_typeexpr;
  props type_properties;
  compute_prim(es->clq, primitive_string_literal_type(es->cs, count(&a->charspecs)),
               &type, &props);
  unified te_typeexpr;
  if !unify_types(pt, &type.x, &unified) {
    return ERR(_u8("string literal in bad place"));
  }
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, type, props})), type, props)));
  return NoFail;
}

func check_expr_strinit(es *framescope, ai allow_incomplete, a *ast_strinit, pt *te_typeexpr, x *ast_expr) np {
  if !is_complete(pt) {
    if ai == AllowIncompleteYes {
      // NOTE: We could have more specific info, like number of fields and their incomplete types.
      annotate_info(x, @[ast_expr_info]IncompleteCheck);
      return NoFail;
    } else {
      return ERR(_u8("Structure literal used ambiguously."));
    }
  }

  // Since pt is complete, and since it's a pt, it's computed.
  if !is_complete_computed(pt).computed {
    ice(_u8("check_expr_strinit has non-computed pt"));
  }

  if case &TeArraytype(b te_arraytype) = pt {
    n u32 = *unHas(&b.count);  // We checked is_complete(pt).
    if n != ~count(&a->exprs) {
      return MERR(es->cs, a->meta, _u8("Structure literal has wrong number of fields."));
    }

    for i u32 = 0; i < n; i = i + 1 {
      x_i *ast_expr_consume = &ref(&a->exprs, ~i)->ec;
      #check_expr_consume(es, x_i, oo(&b.param));
      reannotate_static_to_virtual(es, result_cell(x_i));
    }

    // We checked is_computed(pt).
    props type_properties;
    #compute_complete_type_properties(es->clq, pt, &props);

    // We checked is_computed(pt)
    param_props type_properties;
    #compute_complete_type_properties(es->clq, oo(&b.param), &param_props);

    for i u32 = 0; i < n; i = i + 1 {
      p_i *ast_strinit_param = ref(&a->exprs, ~i);
      annotate(&p_i->info, {i * param_props.flat_size});
    }
    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ *pt, props})), ~ *pt, props)));
    return NoFail;
  } else {
    b *structspec;
    switch structural_structspec(es->ds, pt, &b) {
    case Error(pm):
      return Printed(pm);
    case Success: { }
    case NotAccessible:
      return MERR(es->cs, a->meta, _u8("Strinit for inaccessible or non-structural type, "), pretty(es->im, pt));
    }

    n size = count(&b->fields);
    if n != count(&a->exprs) {
      return MERR(es->cs, a->meta, _u8("Structure literal has wrong number of fields."));
    }

    offsets array[u32];
    for i size = 0; i < n; i = i + 1 {
      x_i *ast_expr_consume = &ref(&a->exprs, i)->ec;
      field *te_vardecl = ref(&b->fields, i);
      #check_expr_consume(es, x_i, &field->type);
      reannotate_static_to_virtual(es, result_cell(x_i));
      psd partial_struct_data;
      #compute_partial_struct_data(es->clq, &b->fields, Has(field->name), &psd);
      check(psd.found_field);
      push(&offsets, psd.offset);
    }

    // We checked is_computed(pt).
    props type_properties;
    #compute_complete_type_properties(es->clq, pt, &props);

    for i size = 0; i < n; i = i + 1 {
      p_i *ast_strinit_param = &a->exprs[i];
      annotate(&p_i->info, {offsets[i]});
    }
    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ *pt, props})), ~ *pt, props)));
    return NoFail;
  }
}

func check_expr_lambda(es *framescope, a *ast_lambda, pt *te_typeexpr, x *ast_expr) np {
  // TODO: Cache type.
  type ast_typeexpr = lambda_declared_type(es->im, a);
  // TODO: Cache converted.
  converted te_typeexpr = #convert_typeexpr(&type);
  // TODO: I see some duplicated logic with the TypedExpr case.
  computed cac_typeexpr;
  #check_and_compute_typeexpr(es->clq, es->ds->generics, es->ds->repls, &converted, &computed);
  // Lambda exprs can't have partial types (yet!).
  check(computed.complete);
  unified te_typeexpr;
  if !unify_types(pt, &computed.te, &unified) {
    return ERR(_u8("Lambda is incompatible with contextual type."));
  }

  computed_params *shray[te_typeexpr];
  if !decompose_typeapp(&computed.te, primitive_function_puretype(es->cs), &computed_params) {
    ice(_u8("lambda type is not a function type"));
  }

  if true {
    nargs size = count(&a->args);
    return_type cu_typeexpr = ~computed_params[nargs];
    #help_check_lambda_body(es->ds, &return_type, a, computed_params);
  }

  props type_properties;
  #compute_complete_type_properties(es->clq, &computed.te, &props);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~computed.te, props})), ~computed.te, props)));
  return NoFail;
}

// This helper method shields its code from using the wrong (outer) framescope variable in check_expr_lambda.
func help_check_lambda_body(ds *defscope, return_type *cu_typeexpr, a *ast_lambda, computed_params *shray[te_typeexpr]) np {
  bs bodystate = mk(ds, return_type);
  vp varpopper;
  init_vp(&vp, &bs.es);
  nargs size = count(&a->args);
  check(nargs + 1 == count(computed_params));
  arg_cells array[cell_num];
  for i size = 0; i < nargs; i = i + 1 {
    cu_param cu_typeexpr = ~computed_params[i];
    cu_param_props type_properties;
    #compute_type_properties(bs.clq, &cu_param, &cu_param_props);
    cell cell_num = add_cell(&bs.es, {LocationStatic, cu_param, cu_param_props});
    push(&arg_cells, cell);
    vn var_number;
    name *ast_ident = &a->args[i].name;
    #es_push_var(&bs.es, &vp, cell, Has(name), ~varname_ipse(bs.im, name->value), &cu_param, VarSelfContained, &vn);
    #es_note_var_destroyer(&bs.es, vn);
  }

  ee entryexit;
  #check_body(&bs, None, &a->body.bb, &ee);
  #finish_lambda_body(&bs, ee);

  destructions array[var_destruction];
  #make_destructions(&bs.es, read_nums(&vp), &destructions);

  return_type_props type_properties;
  #compute_type_properties(bs.clq, return_type, &return_type_props);
  return_cell cell_num = add_cell(&bs.es, {LocationStatic, *return_type, return_type_props});

  info ast_fullbody_info = {destructions, move(&bs.es.all_vars), Has(move(&bs.es.gr)), bs.gotos, bs.labels, move(&bs.statements), return_cell, arg_cells};
  annotate(&a->body.info, info);

  return NoFail;
}

func numeric_literal_value(a *ast_numeric_literal) bigint {
  switch a {
    case &HexLiteral(b ast_hex_literal): {
      return convert_to_bigint(16, &b.digits);
    }
    case &DecLiteral(b ast_dec_literal): {
      return convert_to_bigint(10, &b.digits);
    }
  }
}

func check_numeric_literal(es *framescope, ai allow_incomplete, pt *te_typeexpr, n bigint, x *ast_expr) np {
  if case &TeUnknown = pt {
    if ai == AllowIncompleteYes {
      annotate_info(x, @[ast_expr_info]IncompleteCheck);
      return NoFail;
    } else {
      return ERR(_u8("Numeric literal usage is ambiguous."));
    }
  }

  facts numeric_traits;
  if !is_numeric_type(es->cs, pt, &facts) {
    return ERR(_u8("Numeric literal in bad place."));
  }
  if n < facts.minval || n > facts.maxval {
    return ERR(_u8("Numeric literal out of range."));
  }
  // It's a pt, and it's a numeric type, which means it must be a complete pt, which means it's computed.
  check(is_complete_computed(pt).computed);
  props type_properties;
  #compute_complete_type_properties(es->clq, pt, &props);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ *pt, props})), ~ *pt, props)));
  return NoFail;
}

// You really should use this, in case we decide to rearrange the order of parameters of the ref type.
func decompose_ref(t *te_typeexpr, cs *checkstate, ipse_out **te_typeexpr, param_out **te_typeexpr) bool {
  return decompose_typeapp(t, primitive_ref_puretype(cs), ipse_out, param_out);
}

// Writes a fake ipse in the case of pointer, a real ipse in the case of a reference.
func decompose_ref_or_ptr(t *te_typeexpr, cs *checkstate, ipse_out *te_typeexpr, param_out **te_typeexpr) bool {
  lt *te_typeexpr;
  param *te_typeexpr;
  if decompose_ref(t, cs, &lt, &param) {
    *ipse_out = *lt;
    *param_out = param;
    return true;
  }
  if decompose_typeapp(t, primitive_pointer_puretype(cs), &param) {
    *ipse_out = fake_ipse(cs);
    *param_out = param;
    return true;
  }
  return false;
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, params_out **shray[te_typeexpr]) bool {
  // This could be implemented in terms of unify_under_generics, you know.
  if case &TeApp(app te_typeapp) = t {
    unified te_puretype;
    if !unify_puretypes(&app.typefunc, &expected_puretype, &unified) {
      return false;
    }
    *params_out = &app.params;
    return true;
  } else {
    return false;
  }
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr) bool {
  params *shray[te_typeexpr];
  if !decompose_typeapp(t, expected_puretype, &params) {
    return false;
  }
  if count(params) != 1 {
    return false;
  }
  *oneparam_out = ref(params, 0);
  return true;
}

enum decompose_result {
  Success void;
  BadPuretype void;
  BadArity void;
}

func tri_decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr, twoparam_out **te_typeexpr) decompose_result {
  params *shray[te_typeexpr];
  if !decompose_typeapp(t, expected_puretype, &params) {
    return BadPuretype;
  }
  if count(params) != 2 {
    return BadArity;
  }
  *oneparam_out = ref(params, 0);
  *twoparam_out = ref(params, 1);
  return Success;
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr, twoparam_out **te_typeexpr) bool {
  if case Success = tri_decompose_typeapp(t, expected_puretype, oneparam_out, twoparam_out) {
    return true;
  } else {
    return false;
  }
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr, twoparam_out **te_typeexpr, threeparam_out **te_typeexpr) bool {
  params *shray[te_typeexpr];
  if !decompose_typeapp(t, expected_puretype, &params) {
    return false;
  }
  if count(params) != 3 {
    return false;
  }
  *oneparam_out = ref(params, 0);
  *twoparam_out = ref(params, 1);
  *threeparam_out = ref(params, 2);
  return true;
}

enum check_field_result {
  // Inherits the lvalue-ness of the thing it's a field of.  Includes the field's offset (in bnnos).
  InheritsLval u32;
  // Doesn't inherit the lvalue-ness.  In fact it's a compile-time constant (for the array ".length" field).
  ConstantField u32;
}

func check_field(es *framescope, t *cu_typeexpr, a *ast_fieldname, pt *te_typeexpr, fieldtype_out *cu_typeexpr, res_out *check_field_result) np {
  fieldtype cu_typeexpr;
  res check_field_result;
  #lookup_field(es, t, a, &fieldtype, &res);
  unified te_typeexpr;
  if !unify_types(pt, &fieldtype.x, &unified) {
    return ERR(_u8("field has wrong type."));
  }
  *fieldtype_out = fieldtype;
  *res_out = res;
  return NoFail;
}

func structural_structspec(ds *defscope, t *te_typeexpr, st_out **structspec) structural_rhs_result {
  if case Has(pack te_instpack) = type_pack(t) {
    st *structspec;
    switch help_structural_structspec(ds, &pack, &st) {
    case Error(pm):
      return Error(pm);
    case Success:
      *st_out = st;
      return Success;
    case NotAccessible:
      return NotAccessible;
    }
  } else {
    // We don't allow strinit exprs on raw struct types anymore.
    return NotAccessible;
  }
}

// et_out is set to a complete/computed value.
func structural_enumspec(ds *defscope, t *te_typeexpr, et_out **enumspec) structural_rhs_result {
  if case Has(pack te_instpack) = type_pack(t) {
    et *enumspec;
    switch help_structural_enumspec(ds, &pack, &et) {
    case Error(pm):
      return Error(pm);
    case Success:
      *et_out = et;
      return Success;
    case NotAccessible:
      return NotAccessible;
    }
  } else {
    // We don't allow constructors/switching on raw enum types anymore.
    return NotAccessible;
  }
}

func deftype_rhs_info_accessible(ds *defscope, id deftype_entry_id, result_out *bool) np {
  ent *deftype_entry = ref_deftype_entry(ds->cs, id);
  if case &Has(np deftype_nonprim) = &ent->nonprim {
    rhs *deftype_rhs_spec;
    #deftype_converted_rhs(ds->cs, &np, &rhs);
    switch rhs {
    case &ClassexprRhsSpec(crs classexpr_rhs_spec):
      n size = count(&ds->accessible);
      for i size = 0; i < n; i = i + 1 {
        aid access_entry_id = ds->accessible[i];
        dti deftype_entry_id;
        #get_accessible_deftype(ds->cs, aid, &dti);
        if dti == id {
          *result_out = true;
          return NoFail;
        }
      }
      *result_out = false;
      return NoFail;
    case &DefstructRhsSpec(drs structspec):
      *result_out = true;
      return NoFail;
    case &DefenumRhsSpec(drs enumspec):
      *result_out = true;
      return NoFail;
    }
  } else {
    *result_out = false;
    return NoFail;
  }
}

func type_pack(t *te_typeexpr) opt[te_instpack] {
  switch t {
  case &TeName(a te_name):
    if case &Has(pack te_instpack) = &a.pack {
      return Has(pack);
    }
    ice(_u8("type_pack called on uncomputed type"));
  case &TeApp(a te_typeapp):
    if case &Has(pack te_instpack) = &a.pack {
      return Has(pack);
    }
    ice(_u8("type_pack called on uncomputed type"));
  case &TeUnknown:
    ice(_u8("type_pack called on incomplete type"));
  default:
    return None;
  }
  return fake();
}

enum structural_rhs_result {
  // An error was printed.  True if location info was printed.
  Error bool;
  Success void;
  NotAccessible void;
}

func help_structural_rhs_info(ds *defscope, pack *te_instpack, rhs_info_out **deftype_inst_rhs_info) structural_rhs_result {
  accessible_result bool;
  if case Printed(pm) = deftype_rhs_info_accessible(ds, pack->ent_id, &accessible_result) {
    return Error(pm);
  }
  if !accessible_result {
    return NotAccessible;
  }
  if case Printed(pm) = ensure_deftype_inst_checked(ds->clq, pack->ent_id, pack->inst_id) {
    return Error(pm);
  }
  inst *deftype_inst = ref_deftype_inst(ds->cs, pack->inst_id);
  if case &Computed(info deftype_inst_info) = &inst->info {
    if case &Has(rhs_info deftype_inst_rhs_info) = &info.rhs {
      *rhs_info_out = &rhs_info;
      return Success;
    } else {
      ice(_u8("deftype_rhs_accessible permitted a primitive type."));
      return fake();
    }
  } else {
    ice(_u8("inst checked, info still None"));
    return fake();
  }
}

func help_structural_enumspec(ds *defscope, pack *te_instpack, et_out **enumspec) structural_rhs_result {
  rhs_info *deftype_inst_rhs_info;
  switch help_structural_rhs_info(ds, pack, &rhs_info) {
  case Error(pm):
    return Error(pm);
  case Success:
    switch rhs_info {
    case &RhsStructInfo(ri structspec):
      return NotAccessible;
    case &RhsEnumInfo(ri enumspec):
      *et_out = &ri;
      return Success;
    }
  case NotAccessible:
    return NotAccessible;
  }
}

func help_structural_structspec(ds *defscope, pack *te_instpack, st_out **structspec) structural_rhs_result {
  rhs_info *deftype_inst_rhs_info;
  switch help_structural_rhs_info(ds, pack, &rhs_info) {
  case Error(pm):
    return Error(pm);
  case Success:
    switch rhs_info {
    case &RhsStructInfo(ri structspec):
      *st_out = &ri;
      return Success;
    case &RhsEnumInfo(ri enumspec):
      return NotAccessible;
    }
  case NotAccessible:
    return NotAccessible;
  }
}

func lookup_name_field(es *framescope, pack *te_instpack, fieldname *ast_ident, fieldtype_out *cu_typeexpr, res_out *check_field_result) np {
  st *structspec;
  switch help_structural_structspec(es->ds, pack, &st) {
  case Error(pm):
    return Printed(pm);
  case Success:
    return help_lookup_struct_field(es, st, fieldname, fieldtype_out, res_out);
  case NotAccessible:
    return ERR(_u8("Looking up field on inaccessible defclass or primitive type"));
  }
}

func help_lookup_struct_field(es *framescope, st *structspec, fieldname *ast_ident, fieldtype_out *cu_typeexpr, res_out *check_field_result) np {
  offset u32;
  #lookup_field_from_list(es->clq, &st->fields, fieldname->value, fieldtype_out, &offset);
  *res_out = InheritsLval(offset);
  return NoFail;
}

func help_lookup_name_field(es *framescope, t *cu_typeexpr, fieldname *ast_ident, fieldtype_out *cu_typeexpr, res_out *check_field_result) np {
  switch &t->x {
    case &TeName(a te_name): {
      return lookup_name_field(es, unHas(&a.pack), fieldname, fieldtype_out, res_out);
    }
    case &TeApp(a te_typeapp): {
      return lookup_name_field(es, unHas(&a.pack), fieldname, fieldtype_out, res_out);
    }
    case &TeUnion(a te_union): {
      // The offset's what it would be for a struct.
      offset_discard u32;
      #lookup_field_from_list(es->clq, &a.fields, fieldname->value, fieldtype_out, &offset_discard);
      // Offset's always 0 for a union.
      *res_out = InheritsLval(0);
      return NoFail;
    }
    case &TeArraytype(a te_arraytype): {
      if fieldname->value != es->im->cym.lengthsym {
        return ERR(_u8("field lookup (not .length) on array type"));
      }
      *fieldtype_out = compute_prim(es->clq, primitive_size_type(es->cs));
      if case Has(n u32) = a.count {
        *res_out = ConstantField(n);
      } else {
        ice(_u8("Complete arraytype has incomplete count"));
      }
      return NoFail;
    }
    case &TeIpse(a te_ipse):
      return ERR(_u8("ICE: Looking up name field of... a ipse type?"));

    case &TeUnknown: {
      ice(_u8("lookup_field sees incomplete type"));
      return fake();
    }
  }
}

func lookup_field(es *framescope, t *cu_typeexpr, f *ast_fieldname, fieldtype_out *cu_typeexpr, res_out *check_field_result) np {
  return help_lookup_name_field(es, t, &f->name, fieldtype_out, res_out);
}

func find_vardecl(a *shray[te_vardecl], name sym, out **te_typeexpr, index_out *size) bool {
  n size = count(a);
  for i size = 0; i < n; i = i + 1 {
    d *te_vardecl = ref(a, i);
    if d->name == name {
      *out = &d->type;
      *index_out = i;
      return true;
    }
  }
  return false;
}

// fields is supposed to be complete.
func lookup_field_from_list(clq *clqueue, fields *shray[te_vardecl], fieldname sym, fieldtype_out *cu_typeexpr, offset_out *u32) np {
  psd partial_struct_data;
  #compute_partial_struct_data(clq, fields, Has(fieldname), &psd);

  if !psd.found_field {
    return ERR(_u8("fieldname '"), lookup(clq->im, fieldname), _u8("' not found"));
  }

  *fieldtype_out = ~ ref(fields, psd_index(&psd))->type;
  *offset_out = psd.offset;
  return NoFail;
}

func check_expr_logical_conjunction(es *framescope, a *ast_logical_conjunction, pt *te_typeexpr, x *ast_expr) np {
  type cu_typeexpr;
  props type_properties;
  compute_prim(es->clq, primitive_bool_type(es->cs), &type, &props);

  unified te_typeexpr;
  if !unify_types(pt, &type.x, &unified) {
    return ERR(_u8("logical conjunction in bad place"));
  }
  #check_expr_consume(es, oo(&a->lhs), &type.x);
  #check_expr_consume(es, oo(&a->rhs), &type.x);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, type, props})), type, props)));
  return NoFail;
}

func ai_incomplete(yes bool) allow_incomplete {
  if yes {
    return AllowIncompleteYes;
  } else {
    return AllowIncompleteNo;
  }
}

func check_expr_funcall(es *framescope, ai allow_incomplete, a *ast_funcall, pt *te_typeexpr, x *ast_expr) np {
  a_param_incomplete bool;
  #check_funcall_params_firsttime(es, &a->params, &a_param_incomplete);

  func_pt te_typeexpr;
  #make_fn_partial_type(es->clq, pt, &a->params, &func_pt);
  funec *ast_expr_consume = oo(&a->fun);
  #check_expr_ai(es, ai_incomplete(!a_param_incomplete && ai == AllowIncompleteYes), &funec->expr, &func_pt);

  if expr_type_incomplete(&funec->expr) {
    check(ai == AllowIncompleteYes);
    annotate_info(x, @[ast_expr_info]IncompleteCheck);
    return NoFail;
  }

  #check_funcall_params_secondtime(es, expr_complete_type(&funec->expr), &a->params);

  #annotate_disposal_for_consume(es, &funec->expr, &funec->after);

  return_type *te_typeexpr = fn_return_type(es->cs, &expr_complete_type(&oo(&a->fun)->expr)->x);
  props type_properties;
  #compute_complete_type_properties(es->clq, return_type, &props);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ *return_type, props})), ~ *return_type, props)));
  return NoFail;
}

func check_funcall_params_firsttime(es *framescope, params *array[ast_expr_consume], a_param_incomplete_out *bool) np {
  n size = count(params);
  unknown te_typeexpr = TeUnknown;
  all_params_complete bool = true;
  for i size = 0; i < n; i = i + 1 {
    expr *ast_expr = &ref(params, i)->expr;
    #check_expr_ai(es, AllowIncompleteYes, expr, &unknown);
    complete bool = expr_type_complete(expr);
    all_params_complete = all_params_complete & complete;
  }
  *a_param_incomplete_out = !all_params_complete;
  return NoFail;
}

func check_funcall_params_secondtime(es *framescope, functype *cu_typeexpr, params *array[ast_expr_consume]) np {
  n size = count(params);

  type_params *shray[te_typeexpr];
  if !decompose_typeapp(&functype->x, primitive_function_puretype(es->cs), &type_params) {
    ice(_u8("Expecting a TeApp for fn-type."));
  }
  check(count(type_params) == n + 1);

  for i size = 0; i < n; i = i + 1 {
    ec *ast_expr_consume = ref(params, i);
    #check_expr_consume(es, ec, ref(type_params, i));
  }
  return NoFail;
}

func compute_prim(clq *clqueue, t te_typeexpr) cu_typeexpr {
  cac cac_typeexpr;
  if !from_np(noscoped_check_and_compute_typeexpr(clq, &t, &cac)) {
    ice(_u8("compute_prim encounters uncomputable type"));
  }
  check(cac.complete);
  return ~cac.te;
}

func compute_prim(clq *clqueue, t te_typeexpr) cu_typrop {
  ret cu_typrop;
  compute_prim(clq, t, &ret.cu, &ret.props);
  return ret;
}

func compute_prim(clq *clqueue, t te_typeexpr, out *cu_typeexpr, props_out *type_properties) void {
  type cu_typeexpr = compute_prim(clq, t);
  if !from_np(compute_type_properties(clq, &type, props_out)) {
    ice(_u8("compute_prim fails to compute type properties"));
  }
  *out = type;
}

func check_expr_index(es *framescope, a *ast_index_expr, pt *te_typeexpr, x *ast_expr) np {
  unknown te_typeexpr = TeUnknown;
  #check_expr_ai(es, AllowIncompleteNo, oo(&a->lhs), &unknown);
  lhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->lhs));

  result_type *te_typeexpr;
  key_type te_typeexpr;
  tech indexing_technique;
  #decompose_indexable(es->clq, &lhs_info->cu.x, &result_type, &key_type, &tech);

  unified te_typeexpr;
  if !unify_types(pt, result_type, &unified) {
    return ERR(_u8("index expr returns wrong type"));
  }

  result_props type_properties;
  #compute_complete_type_properties(es->clq, result_type, &result_props);

  lval is_lval;
  switch tech.array {
  case None:
    rhs_later ast_later_discard_info = mk_later();
    #check_consume_then_discard_expr(es, oo(&a->rhs), &key_type, &rhs_later);

    if !tech.deref {
      // TODO: This is totally duplicating field access logic.
      switch &lhs_info->lval {
        case &IsLvalYes(desc lval_description): {
          lval = IsLvalYes({add_cell(es, {LocationVirtual, ~ *result_type, result_props}), DeadMe, field_ipse(desc.ipse)});
        }
        case &IsLvalNo(desc rval_description): {
          lval = IsLvalNo({desc.whole_num, add_cell(es, {LocationVirtual, ~ *result_type, result_props})});
        }
      }
      // Nothing to dispose, it's a field access.
      annotate(&a->info, {None, ArrayIndexingInfo({rhs_later})});
    } else {
      // Dereferencing a pointer always makes an lvalue.
      lval = IsLvalYes({add_cell(es, {LocationVirtual, ~ *result_type, result_props}), DeadMe, field_ipse(fake_ipse(es->cs))});
      ie_info_after nc[ast_expr_after_consume] = NotComputed;
      lhs_later ast_later_discard_info = mk_later();
      #annotate_disposal_for_consume_then_discard(es, oo(&a->lhs), &ie_info_after, &lhs_later);

      annotate(&a->info, {Has({*un(&ie_info_after), lhs_later}), ArrayIndexingInfo({rhs_later})});
    }

  case Has(ip instpair):
    // What this becomes is:
    //   - If the lhs (possibly derefed) is an lvalue, we take its address, call ip, and deref the return value, which makes an lvalue.
    //   - If the lhs is an rvalue, we take its address, call ip, and copy the return value to a new whole rvalue.  But WHAT IF an rvalue's partial_num was allowed to not be a subcell of whole_num?  Then we could just update partial_num.
    //   - For now, if the lhs is an rvalue, we fail to compile.

    if !tech.deref {
      #check_expr_consume(es, oo(&a->rhs), &key_type);

      switch &lhs_info->lval {
      case &IsLvalYes(desc lval_description):
        lval = IsLvalYes({add_cell(es, {LocationVirtual, ~ *result_type, result_props}), DeadMe, fake_ipse(es->cs)});
      case &IsLvalNo(desc rval_description):
        return ERR(_u8("User-defined array indexing only works on lvalues"));
      }

      annotate(&a->info, {None, FnIndexingInfo(ip)});
    } else {
      #check_expr_consume(es, oo(&a->rhs), &key_type);

      lval = IsLvalYes({add_cell(es, {LocationVirtual, ~ *result_type, result_props}), DeadMe, fake_ipse(es->cs)});
      ie_info_after nc[ast_expr_after_consume] = NotComputed;
      lhs_later ast_later_discard_info = mk_later();
      #annotate_disposal_for_consume_then_discard(es, oo(&a->lhs), &ie_info_after, &lhs_later);

      annotate(&a->info, {Has({*un(&ie_info_after), lhs_later}), FnIndexingInfo(ip)});
    }
  }

  annotate_info(x, CompleteCheck(mk(lval, ~ *result_type, result_props)));
  return NoFail;
}

struct indexing_technique {
  // None = raw array, Has(...) = fn indexing
  array opt[instpair];
  deref bool;
}

func decompose_indexable(clq *clqueue, typ *te_typeexpr, result_type_out **te_typeexpr, key_type_out *te_typeexpr, tech_out *indexing_technique) np {
  // We specifically do _not_ support references here.  You can't index into a reference... you'd need a slice type or something like that.
  indexable *te_typeexpr;
  deref bool;
  if decompose_typeapp(typ, primitive_pointer_puretype(clq->cs), &indexable) {
    deref = true;
  } else {
    indexable = typ;
    deref = false;
  }

  if decompose_arraytype(indexable, result_type_out) {
    *tech_out = {None, deref};
    *key_type_out = (@[cu_typeexpr]compute_prim(clq, primitive_size_type(clq->cs))).x;
    return NoFail;
  }

  fntype te_typeexpr = fn_type(clq->cs, ptr_type(clq->cs, *indexable), TeUnknown, TeUnknown);
  gp genparms = NoParms;
  res match_def_res;
  #match_def(clq->cs, clq->im->cym.do_indexsym, &gp, &fntype, &res);
  switch &res {
  case &NoMatch:
    return ERR(_u8("indexing on non-indexable type"));
  case &MultiMatch:
    return ERR(_u8("indexing on type with multiple '"), lookup(clq->im, clq->im->cym.do_indexsym), _u8("' definitions"));
  case &OneMatch(m ent_and_parms):
    inst_id def_inst_id;
    #make_inst(clq, m.ent, &m.parms, &inst_id);
    ty *cu_typrop;
    #ensure_def_inst_type_computed(clq->cs, clq, ref_def_entry(clq->cs, m.ent), inst_id, &ty);
    arr_ptr_type *te_typeexpr;
    key_type *te_typeexpr;
    result_ptr_type *te_typeexpr;
    if !decompose_typeapp(&ty->cu.x, primitive_function_puretype(clq->cs), &arr_ptr_type, &key_type, &result_ptr_type) {
      // This failure can't happen because we constructed fntype to have 3 types.
      return ERR(_u8("ICE: decompose_indexable cannot decompose match_def type"));
    }
    result_type *te_typeexpr;
    if !decompose_typeapp(result_ptr_type, primitive_pointer_puretype(clq->cs), &result_type) {
      return ERR(_u8("indexing function '"), lookup(clq->im, clq->im->cym.do_indexsym), _u8("' returns non-pointer type"));
    }
    *result_type_out = result_type;
    *key_type_out = *key_type;
    *tech_out = {Has({m.ent, inst_id}), deref};
    return NoFail;
  }
}

func decompose_arraytype(t *te_typeexpr, out **te_typeexpr) bool {
  if case &TeArraytype(a te_arraytype) = t {
    *out = oo(&a.param);
    return true;
  } else {
    return false;
  }
}

func expr_type(a *ast_expr) te_typeexpr {
  switch &a->info {
    case &NoInfo: {
      ice(_u8("expr_type sees NoInfo"));
      return fake();
    }
    case &IncompleteCheck: {
      return TeUnknown;
    }
    case &CompleteCheck(t ast_expr_complete_info): {
      return t.cu.x;
    }
  }
}

func expr_complete_info(a *ast_expr) *ast_expr_complete_info {
  if case &CompleteCheck(inf ast_expr_complete_info) = &a->info {
    return &inf;
  } else {
    ice(_u8("expr_complete_info sees... not a complete type"));
    return fake();
  }
}

func expr_complete_type(a *ast_expr) *cu_typeexpr {
  return &expr_complete_info(a)->cu;
}

func expr_type_complete(a *ast_expr) bool {
  switch &a->info {
    case &NoInfo: {
      ice(_u8("expr_type_complete sees NoInfo"));
      return fake();
    }
    case &IncompleteCheck: { return false; }
    case &CompleteCheck(t ast_expr_complete_info): { return true; }
  }
}


func expr_type_incomplete(a *ast_expr) bool {
  return !expr_type_complete(a);
}

func make_fn_partial_type(clq *clqueue, return_type *te_typeexpr, params *array[ast_expr_consume], out *te_typeexpr) np {
  type_params array[te_typeexpr];
  n size = count(params);
  reserve(&type_params, n + 1);
  for i size = 0; i < n; i = i + 1 {
    push(&type_params, expr_type(&ref(params, i)->expr));
  }
  push(&type_params, *return_type);
  fntype te_typeexpr = TeApp({primitive_function_puretype(clq->cs), freeze(&type_params), None});
  cac cac_typeexpr;
  #noscoped_check_and_compute_typeexpr(clq, &fntype, &cac);
  *out = cac.te;
  return NoFail;
}

func fn_return_type(cs *checkstate, func_type *te_typeexpr) *te_typeexpr {
  params *shray[te_typeexpr];
  if !decompose_typeapp(func_type, primitive_function_puretype(cs), &params) {
    ice(_u8("Expected TeApp for fn-type in fn_return_type."));
  }
  n size = count(params);
  check(n > 0);
  return ref(params, n - 1);
}
