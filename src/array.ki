import stdlib;

defclass[T] move array struct {
  count size;
  cap size;
  ptr *T;
};

access array[_] {
  func[T] do_init(r *array[T]) void {
    r->count = 0;
    r->cap = 0;
    r->ptr = null;
  }

  func[T] do_copy(dest *array[T], src *array[T]) void {
    dest->count = src->count;
    dest->cap = src->count;
    dest->ptr = cast(checkmalloc(src->count * sizeof@[T]));
    e size = src->count;
    for i size = 0; i < e; i = i + 1 {
      copy(&dest->ptr[i], &src->ptr[i]);
    }
  }

  func[T] do_destroy(r *array[T]) void {
    for i size = r->count; i > 0; {
      i = i - 1;
      destroy(&r->ptr[i]);
    }
    free(@[*void] cast(r->ptr));
  }

  func[T] set(r *array[T], i size, val T) void {
    check(i < r->count);
    r->ptr[i] = val;
  }

  func[T] get(r *array[T], i size) T {
    check(i < r->count);
    return r->ptr[i];
  }

  func[T] ref(r *array[T], i size) *T {
    check(i < r->count);
    return &r->ptr[i];
  }

  func[T] count(r *array[T]) size {
    return r->count;
  }

  func[T] change_cap_(r *array[T], newcap size) void {
    check(newcap >= r->count);
    p *T = cast(checkmalloc(newcap * sizeof@[T]));
    e size = r->count;
    for i size = 0; i < e; i = i + 1 {
      move(&p[i], &r->ptr[i]);
    }
    free(@[*void] cast(r->ptr));
    r->ptr = p;
    r->cap = newcap;
  }

  func[T] reserve(r *array[T], newcap size) void {
    if newcap > r->cap {
      change_cap_(r, newcap);
    }
  }

  func[T] pop(r *array[T]) void {
    check(r->count > 0);
    r->count = r->count - 1;
    destroy(&r->ptr[r->count]);
  }

  func[T] push(r *array[T], value T) void {
    if (r->count == r->cap) {
      change_cap_(r, max(4, r->cap * 2));
    }
    // The reason we use copy, not move, here, is because value's
    // destructor will get called when we exit this function.
    copy(&r->ptr[r->count], &value);
    r->count = r->count + 1;
  }

  func[T] append(r *array[T], s *array[T]) void {
    n size = s->count;
    for i size = 0; i < n; i = i + 1 {
      push(r, s->ptr[i]);
    }
  }

  func[T] append_raw(r *array[T], p *T, n size) void {
    for i size = 0; i < n; i = i + 1 {
      push(r, p[i]);
    }
  }

  func[T] data(r *array[T]) *T {
    return r->ptr;
  }

  func[T, U] make(raw_arr U) array[T] {
    ret array[T];
    reserve(&ret, raw_arr.length);
    append_raw(&ret, &raw_arr[0], raw_arr.length);
    return ret;
  }

  func[T] swap(a *array[T], b *array[T]) void {
    var tmp = a->~;
    a->~ = b->~;
    b->~ = tmp;
  }
}

func[T] make_copy(p *T, n size) array[T] {
  ret array[T];
  reserve(&ret, n);
  for i size = 0; i < n; i = i + 1 {
    push(&ret, p[i]);
  }
  return ret;
}

func[T] truncate(a *array[T], n size) void {
  m size = count(a);
  check(n <= m);
  while n < m {
    pop(a);
    m = m - 1;
  }
}

func[T] array_equal(a *array[T], b *array[T]) bool {
  e size = count(a);
  if e != count(b) {
    return false;
  }
  for i size = 0; i < e; i = i + 1 {
    if get(a, i) != get(b, i) {
      return false;
    }
  }
  return true;
}

func[T] append(a *array[T], b array[T]) void {
  return append(a, &b);
}

func[T] subarray(a *array[T], i size) array[T] {
  // If i >= count(a), successfully return empty.
  ret array[T];
  n size = count(a);
  for ; i < n; i = i + 1 {
    push(&ret, *ref(a, i));
  }
  return ret;
}

func[T] reverse(a *array[T]) array[T] {
  n size = count(a);
  ret array[T];
  reserve(&ret, n);
  while n > 0 {
    n = n - 1;
    push(&ret, get(a, n));
  }
  return ret;
}

func[T] empty(a *array[T]) bool {
  return count(a) == 0;
}

func[T] popval(a *array[T], val_out *T) bool {
  n size = count(a);
  if n == 0 {
    return false;
  }
  *val_out = get(a, n - 1);
  pop(a);
  return true;
}

func[T] popval(a *array[T]) opt[T] {
  val T;
  if popval(a, &val) {
    return Has(val);
  } else {
    return None();
  }
}

func[T] repeat(n size, value T) array[T] {
  ret array[T];
  reserve(&ret, n);
  for i size = 0; i < n; i = i + 1 {
    push(&ret, value);
  }
  return ret;
}

func[H] build_u8str(help H, r *array[u8], a *array[u8]) void {
  append(r, a);
}

func build_u8str(r *array[u8], a *array[u8]) void {
  append(r, a);
}

func[U, T] mapconvert(x array[T]) array[U] {
  build array[U];
  n size = count(&x);
  reserve(&build, n);
  for i size = 0; i < n; i = i + 1 {
    push(&build, @[U]~get(&x, i));
  }
  return build;
}

func[T] is_strictly_increasing(x *array[T]) bool {
  n size = count(x);
  for i size = 1; i < n; i = i + 1 {
    if !(get(x, i - 1) < get(x, i)) {
      return false;
    }
  }
  return true;
}

func[T] overwrite_raw(x *array[T], offset size, p *T, n size) void {
  check(n <= count(x) - offset);
  w *T = ref(x, offset);
  for i size = 0; i < n; i = i + 1 {
    w[i] = p[i];
  }
}

func[T] append(x *array[T], a *opt[T]) void {
  if case &Has(t T) = a {
    push(x, t);
  }
}

func[T, U] concat(a array[T], b U) array[T] {
  ret array[T] = a;
  append(&ret, &b);
  return ret;
}

func[T, U, V, W] concat(a opt[T], b U, c V, d W) array[T] {
  ret array[T];
  append(&ret, &a);
  append(&ret, &b);
  append(&ret, &c);
  append(&ret, &d);
  return ret;
}

func[T] mk_array() array[T] {
  ret array[T];
  return ret;
}

func[T] mk_array(x0 T) array[T] {
  ret array[T];
  push(&ret, x0);
  return ret;
}

func[T] mk_array(x0 T, x1 T) array[T] {
  ret array[T];
  push(&ret, x0);
  push(&ret, x1);
  return ret;
}

func[T] mk_array(x0 T, x1 T, x2 T) array[T] {
  ret array[T];
  push(&ret, x0);
  push(&ret, x1);
  push(&ret, x2);
  return ret;
}

func[T] mk_array(x0 T, x1 T, x2 T, x3 T) array[T] {
  ret array[T];
  push(&ret, x0);
  push(&ret, x1);
  push(&ret, x2);
  push(&ret, x3);
  return ret;
}

func[T] mk_array(x0 T, x1 T, x2 T, x3 T, x4 T, x5 T, x6 T, x7 T) array[T] {
  ret array[T];
  reserve(&ret, 8);
  push(&ret, x0);
  push(&ret, x1);
  push(&ret, x2);
  push(&ret, x3);
  push(&ret, x4);
  push(&ret, x5);
  push(&ret, x6);
  push(&ret, x7);
  return ret;
}


// Heh.
def[T] _u8 fn[T, array[u8]] = make;
