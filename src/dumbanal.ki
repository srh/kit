import state;

deftype gn_annot struct {
  // Which cells are guaranteed to be live when the gn starts.
  live hash[cell_num, void];
  // Only for GrApply and GrPrimApply.
  lower_paramlists nc[array[gr_num]];
};

deftype frame struct {
  cs *checkstate;
  gr *frame_graph;
  bas *basic_analyze_state;
  // by_gn[i].fs shows what the state must is _before_ evaluating node i.  (All incoming nodes must agree!)
  by_gn array[opt[gn_annot]];
};

deftype exprmut struct {
  // Cells that weren't live, that are used.
  made_live hash[cell_num, void];
  // Cells that were live, that are used (and not made dead).
  used hash[cell_num, void];
  // Cells that were not live, that are used.
  encapsulated hash[cell_num, void];
  // Cells that were live, that are made dead.
  made_dead hash[cell_num, void];
};

deftype partial_exprmut struct {
  used hash[cell_num, void];
  encapsulated hash[cell_num, void];
};

func dumbly_analyze_returning_expression(cs *checkstate, f *objfile, h *frame, gr *frame_graph, gn gr_num, prelive *hash[cell_num, void], mut_out *exprmut) bool {
  mbmut genexpr_result;
  if !dumbly_analyze_expression(cs, f, h, gr, gn, prelive, &mbmut) {
    return false;
  }
  switch &mbmut {
  case &Terminal(m exprmut):
    *mut_out = m;
    return true;
  case &NonTerminal(pm partial_exprmut):
    ERR(_u8("ICE: Expecting terminal expression, for gn "), gn.~, _u8(" in "), lookup(cs->im, gr->informal_name));
    return false;
  }
}

defenum genexpr_result {
  Terminal exprmut;
  NonTerminal partial_exprmut;
};

// TODO: Remove this and its callers.
func[T] DUMBG(x T) void {
}

func dumbly_analyze_expression(cs *checkstate, f *objfile, h *frame, gr *frame_graph, gn gr_num, prelive *hash[cell_num, void], mut_out *genexpr_result) bool {
  gnc *opt[gn_annot] = ref_annot(h, gn);
  if case &Has(annot gn_annot) = gnc {
    // TODO: We should also check that we're part of the same sequential _family_ of exprs.
    if !sets_equal(prelive, &annot.live) {
      ERR(_u8("ICE: Inconsistent liveness state when revisiting node, prelive="), *prelive, _u8(", annot.live="), annot.live);
      return false;
    }
    *mut_out = NonTerminal({mk_hash@[cell_num, void](), mk_hash@[cell_num, void]()});
    return true;
  }

  set(gnc, {*prelive, NotComputed()});

  prec_muts exprmut;

  node *gr_node = ref_node(gr, gn);
  nprecs size = count(&node->precs);
  for i size = 0; i < nprecs; i = i + 1 {
    i_mut exprmut;
    if !dumbly_analyze_returning_expression(cs, f, h, gr, get(&node->precs, i), prelive, &i_mut) {
      return false;
    }
    if !add_parallel_mut(prelive, &prec_muts, &i_mut) {
      return false;
    }
  }

  switch &node->op {
  case &GrApply(a gr_apply):
    DUMBG("GrApply");

    // Retcell is activated _before_ the param cells are dead -- though we shouldn't be generating graphs where this matters for the purposes of this analysis _except_ that we need it for computing lower param lists.
    output(gr, prelive, &prec_muts, a.retcell);

    if true {
      // TODO: Maybe have dumbly_analyze_expression, update prelive, instead of duplicating this update logic in its caller.
      // TODO: Dedup with GrPrimApply.
      apptime_live hash[cell_num, void] = *prelive;
      compose_live(&apptime_live, &prec_muts);

      note_lower_paramlists(h->bas, unHas(gnc), &apptime_live);
    }

    deaden(gr, prelive, &prec_muts, a.funcell);
    nparams size = count(&a.params);
    for i size = 0; i < nparams; i = i + 1 {
      deaden(gr, prelive, &prec_muts, get(&a.params, i));
    }
    *mut_out = Terminal(prec_muts);
    return true;

  case &GrPrimApply(a gr_prim_apply):
    DUMBG("GrPrimApply");
    output(gr, prelive, &prec_muts, a.retcell);

    if true {
      apptime_live hash[cell_num, void] = *prelive;
      compose_live(&apptime_live, &prec_muts);

      note_lower_paramlists(h->bas, unHas(gnc), &apptime_live);
    }

    nparams size = count(&a.params);
    for i size = 0; i < nparams; i = i + 1 {
      deaden(gr, prelive, &prec_muts, get(&a.params, i));
    }
    *mut_out = Terminal(prec_muts);
    return true;

  case &GrMemCopy(a gr_memcopy):
    DUMBG("GrMemCopy");
    output(gr, prelive, &prec_muts, a.dest);
    input(gr, prelive, &prec_muts, a.src);
    *mut_out = Terminal(prec_muts);
    return true;

  case &GrWriteConst(a gr_writeconst):
    DUMBG("GrWriteConst");
    output(gr, prelive, &prec_muts, a.dest);
    *mut_out = Terminal(prec_muts);
    return true;

  case &GrAddressof(a gr_addressof):
    DUMBG("GrAddressof");
    // Yes, addressee is an _output_ -- if it is not live -- we make it live.
    output(gr, prelive, &prec_muts, a.addressee);
    output(gr, prelive, &prec_muts, a.dest);
    *mut_out = Terminal(prec_muts);
    return true;

  case &GrDeref(a gr_deref):
    DUMBG("GrDeref");
    input(gr, prelive, &prec_muts, a.pointer);
    // Location should always be virtual.
    virtual(gr, prelive, &prec_muts, a.name);
    *mut_out = Terminal(prec_muts);
    return true;

  case &GrSubcell(a gr_subcell):
    DUMBG("GrSubcell");
    input(gr, prelive, &prec_muts, a.partof);
    virtual(gr, prelive, &prec_muts, a.name);
    *mut_out = Terminal(prec_muts);
    return true;

  case &GrBranch(a gr_branch):
    DUMBG("GrBranch");
    input(gr, prelive, &prec_muts, a.src);
    new_live hash[cell_num, void] = *prelive;
    compose_live(&new_live, &prec_muts);

    combined_mut genexpr_result = NonTerminal({mk_hash(), mk_hash()});
    ncases size = count(&a.cases);
    for i size = 0; i < ncases; i = i + 1 {
      cas *tup[gr_const, gr_num] = ref(&a.cases, i);
      casmut genexpr_result;
      if !dumbly_analyze_expression(cs, f, h, gr, cas->cdr, &new_live, &casmut) {
        return false;
      }
      combine_branch_mut(&combined_mut, &casmut);
    }

    if case Has(def_gn gr_num) = a.default_case {
      defcasmut genexpr_result;
      if !dumbly_analyze_expression(cs, f, h, gr, def_gn, &new_live, &defcasmut) {
        return false;
      }
      combine_branch_mut(&combined_mut, &defcasmut);
    }

    compose_result(&prec_muts, &combined_mut, mut_out);
    return true;

  case &GrSequence(a gr_sequence):
    DUMBG("GrSequence");
    new_live hash[cell_num, void] = *prelive;
    compose_live(&new_live, &prec_muts);
    firstmut exprmut;
    if !dumbly_analyze_returning_expression(cs, f, h, gr, a.first, &new_live, &firstmut) {
      return false;
    }
    prec_muts = compose_muts(&prec_muts, &firstmut);
    compose_live(&new_live, &firstmut);
    secondmut genexpr_result;
    if !dumbly_analyze_expression(cs, f, h, gr, a.second, &new_live, &secondmut) {
      return false;
    }

    compose_result(&prec_muts, &secondmut, mut_out);
    return true;

  case &GrJmp(a gr_jmp):
    DUMBG("GrJmp");
    new_live hash[cell_num, void] = *prelive;
    compose_live(&new_live, &prec_muts);
    exitmut genexpr_result;
    if !dumbly_analyze_expression(cs, f, h, gr, a.next, &new_live, &exitmut) {
      return false;
    }
    compose_result(&prec_muts, &exitmut, mut_out);
    return true;

  case &GrWriteNothing(a gr_writenothing):
    DUMBG("GrWriteNothing");
    output(gr, prelive, &prec_muts, a.dest);
    *mut_out = Terminal(prec_muts);
    return true;

  case &GrDead(a gr_dead):
    DUMBG("GrDead");
    deaden(gr, prelive, &prec_muts, a.cell);
    *mut_out = Terminal(prec_muts);
    return true;

  case &GrNop(v void):
    DUMBG("GrNop");
    *mut_out = Terminal(prec_muts);
    return true;
  }
}

func note_lower_paramlists(bas *basic_analyze_state, gnc *gn_annot, live_at_app_time *hash[cell_num, void]) void {
  paramlists array[gr_num];
  it hash_iter[cell_num, void] = iter(live_at_app_time);
  while case Has(p *tup[cell_num, void]) = next(&it) {
    if case Has(gn gr_num) = ref(&bas->celldisp, p->car.~)->paramlist {
      push(&paramlists, gn);
    }
  }

  sort(&paramlists);
  dedup_sorted(&paramlists);
  annotate(&gnc->lower_paramlists, paramlists);
}

func combine_branch_mut(onto *genexpr_result, a *genexpr_result) void {
  switch onto {
  case &Terminal(tm exprmut):
    switch a {
    case &Terminal(cm exprmut):
      if !sets_equal(&tm.made_live, &cm.made_live) {
        ice(_u8("terminal/terminal made_live not equal, tm="), tm.made_live, _u8(", cm="), cm.made_live);
      }
      if !sets_equal(&tm.made_dead, &cm.made_dead) {
        ice(_u8("terminal/terminal made_dead not equal, tm="), tm.made_dead, _u8(", cm="), cm.made_dead);
      }
      add_union(&tm.used, &cm.used);
      add_union(&tm.encapsulated, &cm.encapsulated);
    case &NonTerminal(ncm partial_exprmut):
      // Can made_live/made_dead be wrong?  No, because all paths to Terminal must have the same value.  (We _do_ check liveness state when revisiting the node.)
      // We can track what cells are used and encapsulated by _expressions_ but we do _not_ gather such information from various points amid sequences of statements.  (Not when there's a loop.)
      add_union_difference(&tm.used, &ncm.used, &tm.made_dead);
      add_union_difference(&tm.encapsulated, &ncm.encapsulated, &tm.made_live);
    }
  case &NonTerminal(ntm partial_exprmut):
    switch a {
    case &Terminal(cm exprmut):
      // This is just like the Terminal/NonTerminal case.
      new_combined exprmut = cm;
      add_union_difference(&new_combined.used, &ntm.used, &new_combined.made_dead);
      add_union_difference(&new_combined.encapsulated, &ntm.encapsulated, &new_combined.made_live);
      *onto = Terminal(new_combined);
    case &NonTerminal(ncm partial_exprmut):
      add_union(&ntm.used, &ncm.used);
      add_union(&ntm.encapsulated, &ncm.encapsulated);
    }
  }
}

// For deaden and other functions, prelive shows what was alive _before_ prec_muts modified it.
func deaden(gr *frame_graph, prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  if !isLocationStatic(*unHas(&ref_cell(gr, c)->location)) {
    return;
  }

  if case Has(v *void) = lookup_ref(&prec_muts->made_live, &c) {
    check_remove(&prec_muts->made_live, &c);
    check_insert(&prec_muts->encapsulated, &c, void);
  } else if case Has(v *void) = lookup_ref(&prec_muts->used, &c) {
    check_remove(&prec_muts->used, &c);
    check_insert(&prec_muts->made_dead, &c, void);
  } else if case Has(v *void) = lookup_ref(&prec_muts->encapsulated, &c) {
    ice(_u8("deaden on cell seen in encapsulated"));
  } else if case Has(v *void) = lookup_ref(&prec_muts->made_dead, &c) {
    ice(_u8("deaden on cell seen in made_dead"));
  } else {
    if case Has(v *void) = lookup_ref(prelive, &c) {
      check_insert(&prec_muts->made_dead, &c, void);
    } else {
      ice(_u8("deaden on un-live cell "), c.~);
    }
  }
}

// input requires that the cell already be live.
func input(gr *frame_graph, prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  if !isLocationStatic(*unHas(&ref_cell(gr, c)->location)) {
    return;
  }

  if case Has(v *void) = lookup_ref(&prec_muts->made_live, &c) {
    // Success, the cell's live.
  } else if case Has(v *void) = lookup_ref(&prec_muts->used, &c) {
    // Success, the cell's live (in prelive).  This check's redundant with internal logic of this graph-traversing code.
    check(isHas(lookup_ref(prelive, &c)));
  } else if case Has(v *void) = lookup_ref(&prec_muts->encapsulated, &c) {
    ice(_u8("input cell seen in encapsulated"));
  } else if case Has(v *void) = lookup_ref(&prec_muts->made_dead, &c) {
    ice(_u8("input cell seen in made_dead"));
  } else {
    if case Has(v *void) = lookup_ref(prelive, &c) {
      // Success, the cell's live.
    } else {
      ice(_u8("input cell "), c.~, _u8(" not seen in prelive"));
    }
  }
}

// output either makes the cell live, if it wasn't already, or it means we use the cell.
// (Yes, that's so lame -- we should use GrMakeLive.)
func output(gr *frame_graph, prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  if !isLocationStatic(*unHas(&ref_cell(gr, c)->location)) {
    return;
  }

  if case Has(v *void) = lookup_ref(&prec_muts->made_live, &c) {
    // The cell's already live.
  } else if case Has(v *void) = lookup_ref(&prec_muts->used, &c) {
    // The cell's already live.
  } else if case Has(v *void) = lookup_ref(&prec_muts->encapsulated, &c) {
    // The cell's dead.  Make it live.
    check_remove(&prec_muts->encapsulated, &c);
    check_insert(&prec_muts->made_live, &c, void);
  } else if case Has(v *void) = lookup_ref(&prec_muts->made_dead, &c) {
    // The cell's dead.  Make it live.
    check_remove(&prec_muts->made_dead, &c);
    check_insert(&prec_muts->used, &c, void);
  } else {
    if case Has(v *void) = lookup_ref(prelive, &c) {
      // The cell's already live.
    } else {
      check_insert(&prec_muts->made_live, &c, void);
    }
  }
}

// Says that we're naming a virtual cell.
func virtual(gr *frame_graph, prelive *hash[cell_num, void], prec_muts *exprmut, c cell_num) void {
  check(!isLocationStatic(*unHas(&ref_cell(gr, c)->location)));
}

func compose_live(live *hash[cell_num, void], muts *exprmut) void {
  check_add_disjoint(live, &muts->made_live);
  remove_exactly(live, &muts->made_dead);
}

func compose_muts(before *exprmut, after *exprmut) exprmut {
  ret exprmut;

  it hash_iter[cell_num, void] = iter(&before->made_live);
  while case Has(p *_) = next(&it) {
    c cell_num = p->car;
    if case Has(v *void) = lookup_ref(&after->made_live, &c) {
      ice(_u8("compose_muts made_live->made_live"));
    } else if case Has(v *void) = lookup_ref(&after->used, &c) {
      check_insert(&ret.made_live, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->encapsulated, &c) {
      ice(_u8("compose_muts made_live->encapsulated"));
    } else if case Has(v *void) = lookup_ref(&after->made_dead, &c) {
      check_insert(&ret.encapsulated, &c, void);
    } else {
      check_insert(&ret.made_live, &c, void);
    }
  }

  it = iter(&before->used);
  while case Has(p *_) = next(&it) {
    c cell_num = p->car;
    if case Has(v *void) = lookup_ref(&after->made_live, &c) {
      ice(_u8("compose_muts used->made_live"));
    } else if case Has(v *void) = lookup_ref(&after->used, &c) {
      check_insert(&ret.used, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->encapsulated, &c) {
      ice(_u8("compose_muts used->encapsulated"));
    } else if case Has(v *void) = lookup_ref(&after->made_dead, &c) {
      check_insert(&ret.made_dead, &c, void);
    } else {
      check_insert(&ret.used, &c, void);
    }
  }

  it = iter(&before->encapsulated);
  while case Has(p *_) = next(&it) {
    c cell_num = p->car;
    if case Has(v *void) = lookup_ref(&after->made_live, &c) {
      check_insert(&ret.made_live, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->used, &c) {
      ice(_u8("compose_muts encapsulated->used"));
    } else if case Has(v *void) = lookup_ref(&after->encapsulated, &c) {
      check_insert(&ret.encapsulated, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->made_dead, &c) {
      ice(_u8("compose_muts encapsulated->made_dead"));
    } else {
      check_insert(&ret.encapsulated, &c, void);
    }
  }

  it = iter(&before->made_dead);
  while case Has(p *_) = next(&it) {
    c cell_num = p->car;
    if case Has(v *void) = lookup_ref(&after->made_live, &c) {
      check_insert(&ret.used, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->used, &c) {
      ice(_u8("compose_muts made_dead->used"));
    } else if case Has(v *void) = lookup_ref(&after->encapsulated, &c) {
      check_insert(&ret.made_dead, &c, void);
    } else if case Has(v *void) = lookup_ref(&after->made_dead, &c) {
      ice(_u8("compose_muts made_dead->made_dead"));
    } else {
      check_insert(&ret.made_dead, &c, void);
    }
  }

  compose_not_present(&ret, after, before);
  return ret;
}

// Adds to build those of from that aren't in np.
func compose_not_present(build *exprmut, from *exprmut, np *exprmut) void {
  add_not_present(&build->made_live, &from->made_live, np);
  add_not_present(&build->used, &from->used, np);
  add_not_present(&build->encapsulated, &from->encapsulated, np);
  add_not_present(&build->made_dead, &from->made_dead, np);
}

func add_not_present(onto *hash[cell_num, void], from *hash[cell_num, void], np *exprmut) void {
  it hash_iter[cell_num, void] = iter(from);
  while case Has(p *tup[cell_num, void]) = next(&it) {
    c cell_num = p->car;
    if !(member(&np->made_live, &c) || member(&np->used, &c) || member(&np->encapsulated, &c) || member(&np->made_dead, &c)) {
      check_insert(onto, &c, void);
    }
  }
}

func compose_result(before *exprmut, after *genexpr_result, out *genexpr_result) void {
  switch after {
  case &Terminal(am exprmut):
    *out = Terminal(compose_muts(before, &am));
  case &NonTerminal(nam partial_exprmut):
    ret partial_exprmut = nam;
    add_union(&ret.used, &before->used);
    add_union(&ret.encapsulated, &before->encapsulated);
    *out = NonTerminal(ret);
  }
}

// This function should have a symmetry about it.
func add_parallel_mut(prelive *hash[cell_num, void], onto *exprmut, from *exprmut) bool {
  if intersects(&onto->made_dead, &from->used) || intersects(&onto->used, &from->made_dead) {
    ERR(_u8("ICE: One prec-expr marks cell dead that another uses"));
    return false;
  }
  if intersects(&onto->made_live, &from->encapsulated) || intersects(&onto->encapsulated, &from->made_live) {
    ERR(_u8("ICE: One prec-expr makes cell live that another encapsulates"));
    return false;
  }
  if !add_disjoint(&onto->made_live, &from->made_live) {
    ERR(_u8("ICE: multiple prec-exprs made the same cell live"));
    return false;
  }
  if !add_disjoint(&onto->made_dead, &from->made_dead) {
    ERR(_u8("ICE: multiple prec-exprs made the same cell dead"));
    return false;
  }
  if !add_disjoint(&onto->encapsulated, &from->encapsulated) {
    ERR(_u8("ICE: multiple prec-exprs use and discard the same cell"));
    return false;
  }

  add_union(&onto->used, &from->used);
  return true;
}

func ref_annot(h *frame, gn gr_num) *opt[gn_annot] {
  return ref(&h->by_gn, gn.~);
}
