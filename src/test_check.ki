import check;


func testmodule_name() string {
  return from_u8(_u8("testmodule"));
}

func test_loader(cs *checkstate, name sym) opt[array[u8]] {
  if name == intern(cs->im, testmodule_name()) {
    return Has(* @[*array[u8]]cast(cs->loader_ctx));
  } else {
    return None();
  }
}

func test_platform() platform_info {
  ret platform_info = {
    4,
    {1, 1},
    {{1, 1}, {true, -big("128"), big("127")}},
    {{1, 1}, {false, big("0"), big("255")}},
    {{2, 2}, {true, -big("32768"), big("32767")}},
    {{2, 2}, {false, big("0"), big("65536")}},
    {{4, 4}, {true, -big("2147483648"), big("2147483647")}},
    {{4, 4}, {false, big("0"), big("4294967296")}},
    {{4, 4}, {false, big("0"), big("4294967296")}},
    {{4, 4}, {false, big("0"), big("4294967296")}},
    {4, 4},
    {4, 4}
  };
  return ret;
}

func[T] run_check_test(ctx *check_ctx, name T, file array[u8]) void {
  print(Stdout(), _u8("test "), _u8(name), _u8("..."));
  fflush(Stdout());
  im identmap;
  cs checkstate = make_checkstate(&im, test_platform(), @[*void]cast(&file), test_loader);
  add_primitives(&cs);
  if !check_module(&cs, intern(&im, testmodule_name())) {
    print(Stdout(), _u8("FAIL\n"));
    fflush(Stdout());
    ctx->fail = true;
  } else {
    print(Stdout(), _u8("PASS\n"));
    fflush(Stdout());
  }
}

func[T] run_check_negtest(ctx *check_ctx, name T, file array[u8]) void {
  print(Stdout(), _u8("test !"), _u8(name), _u8("..."));
  fflush(Stdout());
  im identmap;
  cs checkstate = make_checkstate(&im, test_platform(), @[*void]cast(&file), test_loader);
  add_primitives(&cs);
  if check_module(&cs, intern(&im, testmodule_name())) {
    print(Stdout(), _u8("FAIL\n"));
    fflush(Stdout());
    ctx->fail = true;
  } else {
    print(Stdout(), _u8("PASS\n"));
    fflush(Stdout());
  }
}

// TODO: Make test output not go directly to stdout/stderr.

deftype check_ctx struct {
  fail bool;
};


func test_check_basic_cases(ctx *check_ctx) void {
  run_check_test(ctx, "c001-a",
    _u8("def x bool = true;"));
  run_check_test(ctx, "c001-b",
    _u8("def x u32 = 3;"));
  run_check_test(ctx, "c001-c",
    _u8("def x i32 = -3;"));
  // Fails because unsigned negation is not permitted.
  run_check_negtest(ctx, "c001-d",
    _u8("def x u32 = -3;"));
  run_check_test(ctx, "c002",
    _u8("def x i32 = 3;\n"
        "deftype dword u32;\n"
        "deftype blah dword;\n"
        "deftype feh *blah;\n"
        "deftype quux *quux;\n"));
  // Fails because foo holds itself flatly.
  run_check_negtest(ctx, "c003",
    _u8("deftype foo bar;\n"
        "deftype bar foo;\n"));
  run_check_test(ctx, "c004",
    _u8("def x i32 = 3;\n"
        "deftype foo struct { x u32; y i32; z *foo; };\n"));
  run_check_test(ctx, "c005",
    _u8("def x i32 = 3;"
        "deftype foo struct { x u32; y i32; z *foo; };\n"));
  // TODO: This should fail, because "whatever[_]" is not in scope.
  run_check_test(ctx, "c006-a",
    _u8("def x i32 = 3;"
        "deftype[T] foo struct { count u32; p whatever[T]; };\n"));
  run_check_test(ctx, "c006-b",
    _u8("def x i32 = 3;"
        "deftype[T] foo struct { count u32; p *T; };\n"));
  // Fails because bar recursively holds itself through a template parameter.
  run_check_negtest(ctx, "c007",
    _u8("deftype[T, U] foo struct { x *T; y U; };\n"
        "deftype bar struct { z foo[u32, bar]; };\n"));
  run_check_test(ctx, "c008",
    _u8("deftype[T, U] foo struct { x *T; y U; };\n"
        "deftype bar struct { z foo[bar, u32]; };\n"));
  run_check_test(ctx, "c009",
    _u8("def x i32 = 3;\n"));
  run_check_test(ctx, "c010",
    _u8("def x u32 = 3;\n"));
  run_check_test(ctx, "c011-a",
    _u8("def[] x i32 = 3;\n"));
  run_check_test(ctx, "c011-b",
    _u8("def[] x i32 = 3;\n"
        "def y i32 = x;\n"));
}

func test_check_lambda_cases(ctx *check_ctx) void {
  run_check_test(ctx, "c012",
    _u8("def x i32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  return x;\n"
        "};\n"));
  // Fails because k is a u32.
  run_check_negtest(ctx, "c013",
    _u8("def x i32 = 3;\n"
        "def k u32 = k;\n"
        "def x i32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  return k;\n"
        "};\n"));
  // Passes despite x shadowing a global, because that's allowed.
  run_check_test(ctx, "c014",
    _u8("def x i32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  var x i32 = 4;\n"
        "  return z;\n"
        "};\n"));
  // Fails because z shadows a local.
  run_check_negtest(ctx, "c016",
    _u8("def x i32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  var z i32 = 4;\n"
        "  return x;\n"
        "};\n"));
  run_check_test(ctx, "c017",
    _u8("def x i32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  return x + z + 5;\n"
        "};\n"));
  // Fails because x is a u32.
  run_check_negtest(ctx, "c018",
    _u8("def x u32 = x;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  return x + z + 5;\n"
        "};\n"));
  // Fails because typechecking can't see that 5 is an i32.
  run_check_negtest(ctx, "c019",
    _u8("def x i32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  return -x + z + -5;\n"
        "};\n"));
  // Fails because you can't negate a u32.
  run_check_negtest(ctx, "c020",
    _u8("def x u32 = 3;\n"
        "def y fn[i32, i32] = func(z i32)i32 {\n"
        "  return -x;\n"
        "};\n"));
  run_check_test(ctx, "c021",
    _u8("deftype foo struct { x i32; y i32; };\n"
        "def y fn[foo, i32] = func(z foo) i32 {\n"
        "  return z.x;\n"
        "};\n"));
  // Fails because the field x has type u32.
  run_check_negtest(ctx, "c022",
    _u8("deftype foo struct { x u32; y i32; };\n"
        "def y fn[foo, i32] = func(z foo) i32 {\n"
        "  return z.x;\n"
        "};\n"));
  run_check_test(ctx, "c023",
    _u8("deftype[T] foo struct { x T; y i32; };\n"
        "def y fn[foo[i32], i32] = func(z foo[i32]) i32 {\n"
        "  return z.x + z.y;\n"
        "};\n"));
  // Fails because z.x is a u32.
  run_check_negtest(ctx, "c024",
    _u8("deftype[T] foo struct { x T; y i32; };\n"
        "def y fn[foo[u32], i32] = func(z foo[u32]) i32 {\n"
        "  return z.x + z.y;\n"
        "};\n"));
  run_check_test(ctx, "c025",
    _u8("def y fn[i32, i32] = func(z i32) i32 {\n"
        "  var k fn[i32, i32] = func(m i32) i32 {\n"
        "    return m + m;\n"
        "  };\n"
        "  return k(z) + k(z);\n"
        "};\n"));
  // Passes!  Because, according to the type checker, lambdas can capture.
  // TODO: Make a decision about capturing.
  run_check_test(ctx, "c026",
    _u8("def y fn[i32, i32] = func(z i32) i32 {\n"
        "  var k fn[i32, i32] = func(m i32) i32 {\n"
        "    return m + z;\n"
        "  };\n"
        "  return k(z) + k(z);\n"
        "};\n"));
  run_check_test(ctx, "c027",
    _u8("deftype foo struct { x i32; y i32; };\n"
        "def y fn[*foo, i32] = func(z *foo) i32 {\n"
        "  return z->x;\n"
        "};\n"));
  run_check_test(ctx, "c028",
    _u8("deftype[T] foo struct { x T; y i32; };\n"
        "def y fn[*foo[i32], i32] = func(z *foo[i32]) i32 {\n"
        "  return z->x + z->y;\n"
        "};\n"));

  run_check_test(ctx, "c029-a",
    _u8("func foo(z *i32) i32 {\n"
        "  return *z;\n"
        "}\n"));
  run_check_test(ctx, "c029-b",
    _u8("deftype[T] foo struct { x T; y i32; };\n"
        "def y fn[*foo[i32], i32] = func(z *foo[i32]) i32 {\n"
        "  return (*z).x + (&(*z))->y;\n"
        "};\n"));

  run_check_test(ctx, "c030",
    _u8("deftype[T] foo struct { x T; y i32; };\n"
        "def y fn[*foo[i32], i32] = func(z *foo[i32]) i32 {\n"
        "  if (z->x < 3 && z->y > 19) {\n"
        "    z->x = (*z).y + 5;\n"
        "  }\n"
        "  return (*z).x + (&(*z))->y;\n"
        "};\n"));
  /* Fails because assignment mismatches types. */
  run_check_negtest(ctx, "c031",
    _u8("deftype[T] foo struct { x T; y i32; };\n"
        "def y fn[*foo[i32], i32] = func(z *foo[i32]) i32 {\n"
        "  if (z->x < 3 && z->y > 19) {\n"
        "    z->x = z;\n"
        "  }\n"
        "  return (*z).x + (&(*z))->y;\n"
        "};\n"));
  run_check_test(ctx, "c032",
    _u8("def[T] foo fn[*T, T] = func(x *T) T { return *x; };\n"
        "def bar fn[i32] = func() i32 {\n"
        "  var x i32 = 3;\n"
        "  return foo(&x);\n"
        "};\n"));
  // Fails because the def does not match.
  run_check_negtest(ctx, "c033",
    _u8("def[T] foo fn[*T, T] = func(x *T) T { return *x; };\n"
        "def bar fn[i32] = func() i32 {\n"
        "  var x i32 = 3;\n"
        "  return foo(x);\n"
        "};\n"));
  run_check_test(ctx, "c034",
    _u8("def[T] fac fn[T, T] = func(x T) T {\n"
        "  if (x == 0) {\n"
        "    return 1;\n"
        "  } else {\n"
        "    return x * fac(x - 1);\n"
        "  }\n"
        "};\n"
        "def bar fn[i32] = func() i32 {\n"
        "  var x i32 = 5;\n"
        "  return fac(x);\n"
        "};\n"));
  // Fails because of recursive template instantiation.
  run_check_negtest(ctx, "c035",
    _u8("deftype[T] foo struct { x i32; };\n"
        "def[T] biggefy fn[T, foo[T]] = func(x T) foo[T] {\n"
        "  return biggefy(x);\n"
        "};\n"
        "def[T] rec fn[T, i32] = func(x T) i32 {\n"
        "  return rec(biggefy(x));\n"
        "};\n"
        "def bar fn[i32] = func() i32 {\n"
        "  var x u32 = 5;\n"
        "  return rec(x);\n"
        "};\n"));
  run_check_test(ctx, "c036",
    _u8("def x i32 = 3;\n"
        "def y u32 = 3 + 4;\n"
        "def z fn[i32, i32] = func(k i32) i32 { return k + 1; };\n"));
  // TODO: This should fail because you can't evaluate z(3) statically.
  run_check_test(ctx, "c037",
    _u8("def x i32 = z(3);\n"
        "def z fn[i32, i32] = func(k i32) i32 { return k + 1; };\n"));
  run_check_test(ctx, "c038",
    _u8("def y i32 = -x;\n"
        "def x i32 = -3;\n"));
  // TODO: This should fail because of cyclic reference.
  run_check_test(ctx, "c039",
    _u8("def y i32 = -x;\n"
        "def x i32 = -y;\n"));
}

func test_check_more_cases(ctx *check_ctx) void {
  // We skip c040, to keep units digit in alignment with s1 testcases.

  run_check_test(ctx, "c041",
    _u8("def foo fn[u32, u32] = func(x u32) u32 {\n"
        "  return x + 4;\n"
        "};"
        "def bar fn[i32, i32] = foo;\n"
        "def foo fn[i32, i32] = func(x i32) i32 {\n"
        "  return x + 3;\n"
        "};\n"));
  run_check_test(ctx, "c042",
    _u8("def foo fn[u32, u32] = func(x u32) u32 {\n"
        "  return x + 4;\n"
        "};"
        "def bar fn[i32, i32] = foo;\n"
        "def[T] foo fn[T, i32] = func(x T) i32 {\n"
        "  return x + 3;\n"
        "};\n"));
  // Fails because foo's instatiation won't typecheck.
  run_check_negtest(ctx, "c043",
    _u8("def foo fn[u32, u32] = func(x u32) u32 {\n"
        "  return x + 4;\n"
        "};"
        "def bar fn[u32, i32] = foo;\n"
        "def[T] foo fn[T, i32] = func(x T) i32 {\n"
        "  return x + 3;\n"
        "};\n"));
  // Fails because foo lacks a return statement.
  run_check_negtest(ctx, "c044",
    _u8("def foo fn[u32, u32] = func(x u32) u32 {\n"
        "  x + x;\n"
        "};"));
  run_check_test(ctx, "c045",
    _u8("def foo i32 = 7;\n"
        "def bar i32 = 5 << foo;\n"));
  // TODO: Should fail, because the shift overflows.
  run_check_test(ctx, "c046",
    _u8("def foo i32 = 30;\n"
        "def bar i32 = 5 << foo;\n"));
  run_check_test(ctx, "c047",
    _u8("def[T] foo fn[T, T] = func(x T) T {\n"
        "  var y T = x;\n"
        "  return y;\n"
        "};\n"
        "def bar fn[i32] = func() i32 {\n"
        "  return foo(3);\n"
        "};\n"));
  run_check_test(ctx, "c048",
    _u8("def[T] add32 fn[i32, T, i32] = func(x i32, y T) i32 {\n"
        "  var z i32 = 4;\n"
        "  return x + z;\n"
        "};\n"
        "def bar fn[i32] = func() i32 {\n"
        "  return add32(3, @[u32]4);\n"
        "};\n"));
  // Fails because return type in return expression is wrong.
  run_check_negtest(ctx, "c049",
    _u8("def foo fn[i32] = func() i32 {\n"
        "  return @[u32] 4;\n"
        "};\n"));
  run_check_test(ctx, "c050",
    _u8("def x i32 = ~ @[u32]4;\n"));
  run_check_test(ctx, "c051",
    _u8("def[T] foo fn[ptr[T], i32, T] = func(p ptr[T], i i32) T {\n"
        "  var ret T = p[i];\n"
        "  p[i] = p[i + 1];\n"
        "  return ret;\n"
        "};\n"));


}

func test_check() bool {
  ctx check_ctx;
  test_check_basic_cases(&ctx);
  test_check_lambda_cases(&ctx);
  test_check_more_cases(&ctx);
  return !ctx.fail;
}
