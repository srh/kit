import identmap;
import state;

// A "computed" typeexpr, which is complete, and which has isHas instpacks.
deftype cu_typeexpr te_typeexpr;

def `~` fn[te_typeexpr, cu_typeexpr] = wrapconvert;

// A "check and computed" typeexpr -- if it's not complete, it should not be converted to a cu_typeexpr.
deftype cac_typeexpr struct {
  complete bool;
  te te_typeexpr;
};

// TODO: Might this still exist in a particular scope?
// This type is an expanded ast_typeexpr.  I hope aliases are expanded and generics replaced consistently.
defenum te_typeexpr {
  TeName te_name;
  TeApp te_typeapp;
  TeStruct te_struct;
  TeEnum te_enum;
  TeUnion te_union;
  TeArraytype te_arraytype;
  TeUnknown void;
};

defenum te_puretype {
  TePureName sym;
  TePureUnknown void;
};

deftype te_instpack struct {
  ent_id deftype_entry_id;
  inst_id deftype_inst_id;
};

deftype te_name struct {
  value sym;
  // Only supplied if the type is complete, the lookup actually happened.
  pack opt[te_instpack];
};

deftype te_typeapp struct {
  // TODO: typefunc doesn't need to be boxed (as long as it's a puretype).
  typefunc box[te_puretype];
  params array[te_typeexpr];
  // Only supplied if the type is complete, the lookup actually happened.
  pack opt[te_instpack];
};

deftype te_struct struct {
  fields array[te_vardecl];
};

deftype te_enum struct {
  constructors array[te_vardecl];
};

deftype te_union struct {
  fields array[te_vardecl];
};

deftype te_arraytype struct {
  count opt[u32];
  param box[te_typeexpr];
};

deftype te_vardecl struct {
  name sym;
  type te_typeexpr;
};

func typeexpr_list_equal(cs *checkstate, a *array[cu_typeexpr], b *array[cu_typeexpr]) bool {
  n size = count(a);
  if n != count(b) {
    return false;
  }
  for i size = 0; i < n; i = i + 1 {
    if !typeexpr_equal(cs, ref(a, i), ref(b, i)) {
      return false;
    }
  }
  return true;
}

func typeexpr_equal(cs *checkstate, a *cu_typeexpr, b *cu_typeexpr) bool {
  return help_typeexpr_equal(cs, &a->~, &b->~);
}

// Must be called on complete, concrete types.
func help_typeexpr_equal(cs *checkstate, a *te_typeexpr, b *te_typeexpr) bool {
  switch a {
    case &TeName(ax te_name): {
      if case &TeName(bx te_name) = b {
        if case &Has(p te_instpack) = &ax.pack {
          if case &Has(q te_instpack) = &bx.pack {
            return p.inst_id == q.inst_id;
          }
        }
        crash(_u8("typeexpr_equal on a non-pack-having name typeexpr"));
      }
    }
    case &TeApp(ax te_typeapp): {
      if case &TeApp(bx te_typeapp) = b {
        if case &Has(p te_instpack) = &ax.pack {
          if case &Has(q te_instpack) = &bx.pack {
            return p.inst_id == q.inst_id;
          }
        }
        crash(_u8("typeexpr_equal on non-pack-having app typeexpr"));
      }
    }
    case &TeStruct(ax te_struct): {
      if case &TeStruct(bx te_struct) = b {
        return help_te_vardecl_list_equal(cs, &ax.fields, &bx.fields);
      }
    }
    case &TeEnum(ax te_enum): {
      if case &TeEnum(bx te_enum) = b {
        return help_te_vardecl_list_equal(cs, &ax.constructors, &bx.constructors);
      }
    }
    case &TeUnion(ax te_union): {
      if case &TeUnion(bx te_union) = b {
        return help_te_vardecl_list_equal(cs, &ax.fields, &bx.fields);
      }
    }
    case &TeArraytype(ax te_arraytype): {
      if case &TeArraytype(bx te_arraytype) = b {
        return ax.count == bx.count && help_typeexpr_equal(cs, oo(&ax.param), oo(&bx.param));
      }
    }
    case &TeUnknown(v void): {
      ice(_u8("typeexpr_equal sees TeUnknown"));
    }
  }

  return false;
}

func te_puretype_equal(cs *checkstate, a *te_puretype, b *te_puretype) bool {
  switch a {
    case &TePureName(an sym): {
      if case &TePureName(bn sym) = b {
        return an == bn;
      }
    }
    case &TePureUnknown(u void): {
      if case &TePureUnknown(v void) = b {
        return true;
      }
    }
  }
  return false;
}

func help_te_vardecl_list_equal(cs *checkstate, a *array[te_vardecl], b *array[te_vardecl]) bool {
  n size = count(a);
  if n != count(b) {
    return false;
  }
  for i size = 0; i < n; i = i + 1 {
    adecl *te_vardecl = ref(a, i);
    bdecl *te_vardecl = ref(b, i);
    if !(adecl->name == bdecl->name && help_typeexpr_equal(cs, &adecl->type, &bdecl->type)) {
      return false;
    }
  }
  return true;
}

func enum_tag_type(cs *checkstate, et *te_enum) te_typeexpr {
  tagsize u32 = cs->platform.enum_tag_size;
  if tagsize == 1 {
    return primitive_u8_type(cs);
  } else if tagsize == 2 {
    return primitive_u16_type(cs);
  } else if tagsize == 4 {
    return primitive_u32_type(cs);
  } else {
    ice(_u8("enum_tag_type does not support enum_tag_size value"));
    return fake();
  }
}

deftype enum_tag_value u32;
def `~` fn[u32, enum_tag_value] = wrapconvert;

func enum_field_offset(cs *checkstate, et *te_enum, tag enum_tag_value) u32 {
  // Things will get more complicated at some point.
  return cs->platform.enum_tag_size;
}

func mk_enum_tag_value(constructor_decl_index size) enum_tag_value {
  return ~(enum_tag_min + ~constructor_decl_index);
}

func[H] build_u8str(help H, r *array[u8], a *cu_typeexpr) void {
  return build_u8str(help, r, &a->~);
}

func[H] build_u8str(help H, r *array[u8], a *te_typeexpr) void {
  switch a {
    case &TeName(b te_name): {
      wrap_u8str(help, r, _u8("TeName"), &b);
    }
    case &TeApp(b te_typeapp): {
      wrap_u8str(help, r, _u8("TeApp"), &b);
    }
    case &TeStruct(b te_struct): {
      wrap_u8str(help, r, _u8("TeStruct"), &b);
    }
    case &TeEnum(b te_enum): {
      wrap_u8str(help, r, _u8("TeEnum"), &b);
    }
    case &TeUnion(b te_union): {
      wrap_u8str(help, r, _u8("TeUnion"), &b);
    }
    case &TeArraytype(b te_arraytype): {
      wrap_u8str(help, r, _u8("TeArraytype"), &b);
    }
    case &TeUnknown(v void): {
      append(r, _u8("TeUnknown"));
    }
  }
}

func build_u8str(im *identmap, r *array[u8], a *sym) void {
  s string = lookup(im, *a);
  build_u8str(r, &s);
}

func build_u8str(nohelp void, r *array[u8], a *sym) void {
  build_u8str(r, a);
}

func[H] build_u8str(help H, r *array[u8], a *te_name) void {
  append(r, _u8("{value:"));
  build_u8str(help, r, &a->value);
  append(r, _u8("}"));
}

func[H] build_u8str(help H, r *array[u8], a *te_typeapp) void {
  append(r, _u8("{typefunc:"));
  build_u8str(help, r, &a->typefunc);
  append(r, _u8(",params:"));
  build_array_u8str(help, r, &a->params);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_struct) void {
  append(r, _u8("{fields:"));
  build_array_u8str(help, r, &a->fields);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_enum) void {
  append(r, _u8("{constructors:"));
  build_array_u8str(help, r, &a->constructors);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_union) void {
  append(r, _u8("{fields:"));
  build_array_u8str(help, r, &a->fields);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_arraytype) void {
  append(r, _u8("{count:"));
  build_u8str(r, &a->count);
  append(r, _u8(",param:"));
  build_u8str(help, r, &a->param);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_vardecl) void {
  append(r, _u8("{name:"));
  build_u8str(help ,r, &a->name);
  append(r, _u8(",type:"));
  build_u8str(help, r, &a->type);
  push(r, '}');
}

func[H] build_u8str(help H, r *array[u8], a *te_puretype) void {
  switch a {
    case &TePureName(s sym): {
      append(r, _u8("TePureName("));
      build_u8str(help, r, &s);
      push(r, ')');
    }
    case &TePureUnknown(v void): {
      append(r, _u8("TePureUnknown"));
    }
  }
}
