import ast;
import identmap;
import pos;

deftype ps struct {
  data *u8;
  length size;
  pos size;

  current tok;
  // The previous value of pos, the same as the previous value of tok.interval.right,
  // or 0 if we're at the beginning of the stream.
  prev_right size;

  base_offset size;
  comments array[interval];
  // ast_meta values are indices into this array.
  metas *array[meta_datum];

  im *identmap;
};

func make_ps(im *identmap, posits *positionals, base_offset size, data *u8, length size) ps {
  p ps;
  p.data = data;
  p.length = length;
  p.pos = 0;
  p.base_offset = base_offset;
  p.im = im;
  p.metas = &posits->metas;
  step(&p);
  return p;
}

func ps_pos(p *ps) pos {
  return mk_pos(p->base_offset, p->pos);
}

func ps_restore_pos(p *ps, pos pos) void {
  p->pos = pos.~ - p->base_offset;
}

func ps_peek(p *ps) i32 {
  check(p->pos <= p->length);
  if p->pos == p->length {
    return -1;
  }
  return ~p->data[p->pos];
}

func ps_step(p *ps) void {
  check(p->pos < p->length);
  p->pos = p->pos + 1;
}

func startend(p *ps) ast_meta {
  ret ast_meta = ~count(p->metas);
  push(p->metas, {Has(p->current.interval.left), Has(p->current.interval.right)});
  return ret;
}

func start(p *ps) ast_meta {
  ret ast_meta = ~count(p->metas);
  push(p->metas, {Has(p->current.interval.left), None()});
  return ret;
}

func end(p *ps, meta ast_meta) void {
  switch ref(p->metas, meta.~)->right {
    case Has(right_pos pos): {
      check(false);
    }
    case None(v): {
      ref(p->metas, meta.~)->right = Has(mk_pos(p->base_offset, p->prev_right));
    }
  }
}

defenum keyw {
  Access void;
  Case void;
  Def void;
  Default void;
  Defclass void;
  Defenum void;
  Deftype void;
  Else void;
  Enum void;
  Export void;
  Extern void;
  False void;
  For void;
  Func void;
  Goto void;
  If void;
  Import void;
  Label void;
  Null void;
  Return void;
  Struct void;
  Switch void;
  True void;
  Underscore void;
  Union void;
  Var void;
  Void void;
  While void;
};

defenum numlit {
  DecNum array[i8];
  HexNum array[i8];
};

defenum grouper {
  LParen void;
  RParen void;
  LBracket void;
  RBracket void;
  LBrace void;
  RBrace void;
};

defenum tokval {
  Keyw keyw;
  Num numlit;
  Oper array[i32];
  Ident array[i32];
  Grouper grouper;
  StringChar i32;
  // TODO: Just make StringDelim and Backtick be Groupers.
  StringDelim i32;
  Backtick void;
  Bad void;
  Eof void;
  Comment void;
};

func `==`(a keyw, b keyw) bool {
  return enumnum(&a) == enumnum(&b);
}

func equal(a *numlit, b *numlit) bool {
  if enumnum(a) != enumnum(b) { return false; }
  switch a {
  case &DecNum(j): { switch b { case &DecNum(k): { return array_equal(&j, &k); } } }
  case &HexNum(j): { switch b { case &HexNum(k): { return array_equal(&j, &k); } } }
  }
}

func `==`(a grouper, b grouper) bool {
  return enumnum(&a) == enumnum(&b);
}

func equal(a *tokval, b *tokval) bool {
  if enumnum(a) != enumnum(b) { return false; }
  switch a {
  case &Keyw(j): { switch b { case &Keyw(k): { return j == k; } } }
  case &Num(j): { switch b { case &Num(k): { return equal(&j, &k); } } }
  case &Oper(j): { switch b { case &Oper(k): { return array_equal(&j, &k); } } }
  case &Ident(j): { switch b { case &Ident(k): { return array_equal(&j, &k); } } }
  case &Grouper(j): { switch b { case &Grouper(k): { return j == k; } } }
  case &StringChar(j): { switch b { case &StringChar(k): { return j == k; } } }
  case &StringDelim(j): { switch b { case &StringDelim(k): { return j == k; } } }
  case &Backtick(j): { return true; }
  case &Bad(j): { return true; }
  case &Eof(j): { return true; }
  case &Comment(v): { return true; }
  }
}

func `==`(a tokval, b tokval) bool {
  return equal(&a, &b);
}

deftype tok struct {
  interval interval;
  val tokval;
};

func mk_tok(left pos, right pos, val tokval) tok {
  return {{left, right}, val};
}

func is_lower(x i32) bool {
  // TODO: Statically assert 'z' - 'a' == 25.
  return x >= 'a' && x <= 'z';
}

func is_upper(x i32) bool {
  // TODO: Statically assert 'Z' - 'A' == 25.
  return x >= 'A' && x <= 'Z';
}

func is_alpha(x i32) bool {
  return is_lower(x) || is_upper(x);
}

func is_digit(x i32) bool {
  // TODO: Statically assert '9' - '0' == 9.
  return x >= '0' && x <= '9';
}

func is_alnum(x i32) bool {
  return is_alpha(x) || is_digit(x);
}

func is_hexdigit(x i32, val_out *i8) bool {
  // TODO: Statically assert 'f' - 'a', 'F' - 'A', '9' - '0'.
  if is_digit(x) {
    *val_out = ~(x - '0');
    return true;
  }
  if 'A' <= x && x <= 'F' {
    *val_out = ~(x - 'A');
    return true;
  }
  if 'a' <= x && x <= 'f' {
    *val_out = ~(x - 'a');
    return true;
  }
  return false;
}

func is_numeric_postchar(x i32) bool {
  // TODO: Implement for real.
  return !is_alnum(x);
}

func is_ident_firstchar(x i32) bool {
  return is_alpha(x) || x == '_';
}

func is_ident_midchar(x i32) bool {
  return is_ident_firstchar(x) || is_digit(x);
}

func is_ident_postchar(x i32) bool {
  // TODO: Implement for real.
  return !is_ident_midchar(x);
}

func is_string_postchar(x i32) bool {
  // TODO: Implement for real.
  return x != '\'' && x != '\"';
}

func is_ws(x i32) bool {
  return x == ' ' || x == '\n' || x == '\t' || x == '\r';
}

func step(p *ps) void {
  right size = p->pos;
  for ;; {
    t tok = grab_tok(p);
    switch t.val {
      case Comment(v): {
        push(&p->comments, t.interval);
      }
      default: {
        p->current = t;
        p->prev_right = right;
        return;
      }
    }
  }
}

func peek(p *ps) *tok {
  return &p->current;
}

func grab_tok(p *ps) tok {
  ch i32 = ps_peek(p);
  while is_ws(ch) {
    ps_step(p);
    ch = ps_peek(p);
  }
  left pos = ps_pos(p);
  if ch == @[i32]-1 {
    return {{left, left}, Eof(void)};
  }
  if ch == '0' {
    ps_step(p);
    ch = ps_peek(p);
    if ch == 'x' {
      ps_step(p);
      ch = ps_peek(p);
      digits array[i8];
      val i8;
      while is_hexdigit(ch, &val) {
        push(&digits, val);
        ps_step(p);
        ch = ps_peek(p);
      }

      if is_numeric_postchar(ch) {
        return mk_res(p, left, @[tokval]Num(HexNum(digits)));
      } else {
        return {{left, ps_pos(p)}, Bad(void)};
      }
    } else {
      if is_numeric_postchar(ch) {
        digits array[i8];
        push(&digits, 0);
        return mk_res(p, left, @[tokval]Num(DecNum(digits)));
      } else {
        return {{left, ps_pos(p)}, Bad(void)};
      }
    }
  } else if is_digit(ch) {
    digits array[i8];
    push(&digits, @[i8]~(ch - '0'));
    ps_step(p);
    ch = ps_peek(p);
    while is_digit(ch) {
      push(&digits, @[i8]~(ch - '0'));
      ps_step(p);
      ch = ps_peek(p);
    }
    if is_numeric_postchar(ch) {
      return mk_res(p, left, @[tokval]Num(DecNum(digits)));
    } else {
      return {{left, ps_pos(p)}, Bad(void)};
    }
  } else if is_ident_firstchar(ch) {
    ret tok;
    if (grab_keyword(p, "access", Access(void), &ret)
        || grab_keyword(p, "case", Case(void), &ret)
        || grab_keyword(p, "def", Def(void), &ret)
        || grab_keyword(p, "default", Default(void), &ret)
        || grab_keyword(p, "defclass", Defclass(void), &ret)
        || grab_keyword(p, "defenum", Defenum(void), &ret)
        || grab_keyword(p, "deftype", Deftype(void), &ret)
        || grab_keyword(p, "else", Else(void), &ret)
        || grab_keyword(p, "enum", Enum(void), &ret)
        || grab_keyword(p, "export", Export(void), &ret)
        || grab_keyword(p, "extern", Extern(void), &ret)
        || grab_keyword(p, "false", False(void), &ret)
        || grab_keyword(p, "for", For(void), &ret)
        || grab_keyword(p, "func", Func(void), &ret)
        || grab_keyword(p, "goto", Goto(void), &ret)
        || grab_keyword(p, "if", If(void), &ret)
        || grab_keyword(p, "import", Import(void), &ret)
        || grab_keyword(p, "label", Label(void), &ret)
        || grab_keyword(p, "null", Null(void), &ret)
        || grab_keyword(p, "return", Return(void), &ret)
        || grab_keyword(p, "struct", Struct(void), &ret)
        || grab_keyword(p, "switch", Switch(void), &ret)
        || grab_keyword(p, "true", True(void), &ret)
        || grab_keyword(p, "_", Underscore(void), &ret)
        || grab_keyword(p, "union", Union(void), &ret)
        || grab_keyword(p, "var", Var(void), &ret)
        || grab_keyword(p, "void", Void(void), &ret)
        || grab_keyword(p, "while", While(void), &ret)) {
      return ret;
    }

    arr array[i32];
    push(&arr, ch);
    ps_step(p);
    ch = ps_peek(p);
    while is_ident_midchar(ch) {
      push(&arr, ch);
      ps_step(p);
      ch = ps_peek(p);
    }
    if !is_ident_postchar(ch) {
      return {{left, ps_pos(p)}, Bad(void)};
    }
    return mk_res(p, left, Ident(arr));
  } else if ch == '(' {
    ps_step(p);
    return mk_res(p, left, @[tokval]Grouper(LParen(void)));
  } else if ch == ')' {
    ps_step(p);
    return mk_res(p, left, @[tokval]Grouper(RParen(void)));
  } else if ch == '[' {
    ps_step(p);
    return mk_res(p, left, @[tokval]Grouper(LBracket(void)));
  } else if ch == ']' {
    ps_step(p);
    return mk_res(p, left, @[tokval]Grouper(RBracket(void)));
  } else if ch == '{' {
    ps_step(p);
    return mk_res(p, left, @[tokval]Grouper(LBrace(void)));
  } else if ch == '}' {
    ps_step(p);
    return mk_res(p, left, @[tokval]Grouper(RBrace(void)));
  } else if ch == '\"' || ch == '\'' {
    ps_step(p);
    return mk_res(p, left, StringDelim(ch));
  } else if ch == '`' {
    ps_step(p);
    return mk_res(p, left, Backtick(void));
  } else if ch == '~' {
    ps_step(p);
    return mk_res(p, left, Oper(mk_array(ch)));
  } else if ch == '@' {
    ps_step(p);
    return mk_res(p, left, Oper(mk_array(ch)));
  } else if ch == '!' {
    return grab_oper2(p, left, ch, '=');
  } else if ch == '%' {
    return grab_oper2(p, left, ch, '=');
  } else if ch == '^' {
    return grab_oper2(p, left, ch, '=');
  } else if ch == '&' {
    return grab_oper2(p, left, ch, '=', '&');
  } else if ch == '*' {
    return grab_oper2(p, left, ch, '=');
  } else if ch == '-' {
    arr array[i32] = mk_array(ch);
    ps_step(p);
    ch = ps_peek(p);
    if ch == '=' || ch == '-' {
      push(&arr, ch);
      ps_step(p);
    } else if ch == '>' {
      push(&arr, ch);
      ps_step(p);
      ch = ps_peek(p);
      if ch == '~' {
        push(&arr, ch);
        ps_step(p);
      }
    }
    return mk_res(p, left, Oper(arr));
  } else if ch == '=' {
    return grab_oper2(p, left, ch, '=');
  } else if ch == '+' {
    return grab_oper2(p, left, ch, '=', '+');
  } else if ch == '|' {
    return grab_oper2(p, left, ch, '=', '|');
  } else if ch == ':' {
    ps_step(p);
    return mk_res(p, left, Oper(mk_array(ch)));
  } else if ch == ';' {
    ps_step(p);
    return mk_res(p, left, Oper(mk_array(ch)));
  } else if ch == ',' {
    ps_step(p);
    return mk_res(p, left, Oper(mk_array(ch)));
  } else if ch == '<' {
    return grab_angly(p, left, ch);
  } else if ch == '.' {
    return grab_oper2(p, left, ch, '~');
  } else if ch == '>' {
    return grab_angly(p, left, ch);
  } else if ch == '/' {
    ps_step(p);
    ch = ps_peek(p);
    if ch == '/' {
      ps_step(p);
      ch = ps_peek(p);
      while ch != '\n' {
        ps_step(p);
        ch = ps_peek(p);
      }
      ps_step(p);
      return mk_res(p, left, Comment(void));
    } else if ch == '*' {
      ps_step(p);
      ch = ps_peek(p);
      for ;; {
        while ch != '*' {
          ps_step(p);
          ch = ps_peek(p);
        }
        ps_step(p);
        ch = ps_peek(p);
        if ch == '/' {
          ps_step(p);
          return mk_res(p, left, Comment(void));
        }
      }
    } else if ch == '=' {
      ps_step(p);
      return mk_res(p, left, mk_oper('/', '='));
    } else {
      return mk_res(p, left, mk_oper('/'));
    }
  } else {
    return {{left, ps_pos(p)}, Bad(void)};
  }
}

func grab_angly(p *ps, left pos, ch i32) tok {
  arr array[i32] = mk_array(ch);
  ps_step(p);
  dh i32 = ps_peek(p);
  if dh == ch {
    push(&arr, dh);
    ps_step(p);
    dh = ps_peek(p);
  }
  if dh == '=' {
    push(&arr, dh);
    ps_step(p);
  }
  return mk_res(p, left, Oper(arr));
}

func grab_oper2(p *ps, left pos, ch i32, n0 i32) tok {
  return grab_oper2(p, left, ch, n0, n0, n0);
}

func grab_oper2(p *ps, left pos, ch i32, n0 i32, n1 i32) tok {
  return grab_oper2(p, left, ch, n0, n1, n1);
}

func grab_oper2(p *ps, left pos, ch i32, n0 i32, n1 i32, n2 i32) tok {
  arr array[i32] = mk_array(ch);
  ps_step(p);
  ch = ps_peek(p);
  if ch == n0 || ch == n1 || ch == n2 {
    push(&arr, ch);
    ps_step(p);
  }
  return mk_res(p, left, Oper(arr));
}

func mk_res(p *ps, left pos, v tokval) tok {
  return mk_tok(left, ps_pos(p), v);
}

func mk_oper(ch0 i32) tokval {
  return Oper(mk_array(ch0));
}

func mk_oper(ch0 i32, ch1 i32) tokval {
  return Oper(mk_array(ch0, ch1));
}

func mk_oper(ch0 i32, ch1 i32, ch2 i32) tokval {
  return Oper(mk_array(ch0, ch1, ch2));
}

func[String] grab_keyword(p *ps, s String, k keyw, out *tok) bool {
  left pos = ps_pos(p);
  for i size = 0; i < s.length; i = i + 1 {
    si u8 = s[i];
    if ps_peek(p) != ~si {
      ps_restore_pos(p, left);
      return false;
    }
    ps_step(p);
  }

  if !is_ident_postchar(ps_peek(p)) {
    ps_restore_pos(p, left);
    return false;
  }

  *out = mk_tok(left, ps_pos(p), Keyw(k));
  return true;
}

// stop is either '\'' or '\"'.
func string_step(p *ps, stop i32) void {
  p->current = string_grab_tok(p, stop);
}

func string_grab_tok(p *ps, stop i32) tok {
  left pos = ps_pos(p);
  ch i32 = ps_peek(p);

  if ch == @[i32]-1 {
    return {{left, left}, Eof(void)};
  }

  // TODO: ASCII static assertions.
  if ch < ' ' || ch > '~' {
    return {{left, left}, Bad(void)};
  }

  ps_step(p);
  if ch != '\\' {
    if ch != stop {
      return {{left, ps_pos(p)}, StringChar(ch)};
    } else {
      dh i32 = ps_peek(p);
      if is_string_postchar(dh) {
        return {{left, ps_pos(p)}, StringDelim(ch)};
      } else {
        return {{left, ps_pos(p)}, Bad(void)};
      }
    }
  }

  ch = ps_peek(p);
  if ch == 'n' {
    ps_step(p);
    return {{left, ps_pos(p)}, StringChar('\n')};
  } else if ch == 't' {
    ps_step(p);
    return {{left, ps_pos(p)}, StringChar('\t')};
  } else if ch == '\'' || ch == '\"' || ch == '\\' {
    ps_step(p);
    return {{left, ps_pos(p)}, StringChar(ch)};
  } else if ch == 'r' {
    ps_step(p);
    return {{left, ps_pos(p)}, StringChar('\r')};
  } else if ch == '0' {
    ps_step(p);
    return {{left, ps_pos(p)}, StringChar(0)};
  } else if ch == 'x' {
    ps_step(p);
    ch = ps_peek(p);
    sixteens_value i8;
    if !is_hexdigit(ch, &sixteens_value) {
      return {{left, ps_pos(p)}, Bad(void)};
    }
    ps_step(p);
    ch = ps_peek(p);
    units_value i8;
    if !is_hexdigit(ch, &units_value) {
      return {{left, ps_pos(p)}, Bad(void)};
    }
    ps_step(p);

    combined i32 = 16 * (@[i32]~sixteens_value) + @[i32]~units_value;
    return {{left, ps_pos(p)}, StringChar(combined)};
  } else {
    return {{left, ps_pos(p)}, Bad(void)};
  }
}
