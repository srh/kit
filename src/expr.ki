import bigint;
import body;
import check;
import primitives;

// Used with the variable name "es" -- its name used to be different.
struct framescope {
  ds *defscope;
  // Same as ds->cs.
  cs *checkstate;
  // Same as ds->im, same as cs->im.
  im *identmap;
  // Same as ds->clq.
  clq *clqueue;

  tscope type_scope;

  all_vars array[var_info];

  // These var_numbers are always in increasing order.
  current_vars array[var_number];

  // Used for auto-generating $frame_1, $frame_2, ... ipses.
  // And $var_abc_1, $var_abc_2, ...
  ipse_gen_counter size;

  // The return type... if we're in a body that has a return type -- used for QuickReturn
  // expressions.
  return_type opt[*cu_typeexpr];

  gr frame_graph;
}

func mk(ds *defscope, scope *type_scope, return_type opt[*cu_typeexpr]) framescope {
  return {ds, ds->cs, ds->im, ds->clq, clone_scope(scope),
          mk_array@[var_info](), mk_array@[var_number](),
          0,
          return_type,
          init_frame_graph_empty(ds->def_informal_name, NotComputed)};
}

inline func add_cell(es *framescope, info cell_info) cell_num {
  return add_cellp(&es->gr, &info);
}

inline func ref_cell(es *framescope, num cell_num) *cell_info {
  return ref_cell(&es->gr, num);
}

struct frame_cell_count { x size; }

func reannotate_static_to_virtual(es *framescope, num cell_num) void {
  info *cell_info = ref_cell(es, num);
  if case LocationStatic = info->location {
    info->location = LocationVirtual;
  } else {
    ice(_u8("reannotate_static_to_virtual seeing non-rigid location"));
  }
}

struct defscope {
  cs *checkstate;
  // Same as cs->im.
  im *identmap;
  clq *clqueue;
  accessible array[access_entry_id];
  // Generics and their _complete_ replacements.
  generics te_generik_scope;
  repls *idy_repls;
  deflevel_parms_scope *type_scope;
  def_informal_name sym;
}

struct var_number { x size; }

def `~` fn[size, var_number] = wrapconvert;
def `==` fn[var_number, var_number, bool] = wrapequate;
func `!=`(x var_number, y var_number) bool { return !(x == y); }
func `<`(x var_number, y var_number) bool {
  return x.x < y.x;
}

enum var_binding {
  // The variable overlays some other object, in a switch/etc.  It's bound _to_ some
  // object, or partt of one, and we can't auto-initialize it (and it doesn't get
  // destructed on its own when it goes out of scope).
  VarOverlay void;
  // The variable's a self-contained object -- it gets destroyed or not, it can be
  // autoinitialized.
  VarSelfContained void;
}

struct var_info {
  num var_number;
  // A complete, checked, type, with generics replaced.
  type cu_typeexpr;
  props type_properties;
  cell cell_num;
  name opt[sym];
  ipse cu_typeexpr;
  // Can a goto statement enter this var's scope and construct the var?  True if the var
  // is self-contained.  I.e. true if the variable is not bound by a case-pattern.  (Also
  // true for lambda parameters, out of general principle.)  This also means the var needs
  // to be destructed by return statements and gotos that leave its scope.  NOTE: What
  // about default cases of switch statements?  You shouldn't be able to goto into one of
  // those?  But you should be able to goto into the else block of an "if case" -- this
  // needs to be fixed?  Should the swartch get destroyed?  Are we treating the "destroy
  // later" of the condition properly?
  binding var_binding;
  initter opt[ctor_desc];
  destroyer opt[ctor_desc];
}

func ref_var(es *framescope, num var_number) *var_info {
  return ref(&es->all_vars, num.x);
}

func vars_in_scope(es *framescope) array[var_number] {
  return es->current_vars;
}


enum allow_incomplete {
  AllowIncompleteNo void;
  AllowIncompleteYes void;
}

func `==`(x allow_incomplete, y allow_incomplete) bool {
  return enumnum(&x) == enumnum(&y);
}

defclass move varpopper {
  es *framescope;
  nums array[var_number];
}

access varpopper {

func do_init(vp *varpopper) void {
  init(&vp->es);
  init(&vp->nums);
}

func init_vp(vp *varpopper, es *framescope) void {
  check(vp->es == null);
  vp->es = es;
}

func do_destroy(vp *varpopper) void {
  if vp->es != null {
    descope_vars(vp);
  }
  destroy(&vp->nums);
  vp->es = null;
}

func es_push_var(es *framescope, vp *varpopper, cell cell_num, name opt[*ast_ident], ipse cu_typeexpr,
                 computed_type *cu_typeexpr, binding var_binding, vn_out *var_number) np {
  osymname opt[sym];
  if case Has(ident *ast_ident) = name {
    osymname = Has(ident->value);
    if case Has(num var_number) = es_find_current_local(es, ident->value) {
      return ERR(_u8("Local variable '"), lookup(es->im, ident->value), _u8("' shadows another"));
    }
  } else {
    osymname = None;
  }
  props type_properties;
  #compute_type_properties(es->clq, &es->tscope, computed_type, &props);
  num var_number = ~count(&es->all_vars);
  push(&es->all_vars, {num, *computed_type, props, cell, osymname, ipse, binding, None, None});
  push(&es->current_vars, num);
  push(&vp->nums, num);
  *vn_out = num;
  return NoFail;
}

func descope_vars(vp *varpopper) void {
  es *framescope = vp->es;
  check(es != null);
  while case Has(expected var_number) = popval(&vp->nums) {
    num var_number;
    if !popval(&es->current_vars, &num) {
      ice(_u8("varpopper sees empty local_vars"));
    }
    if num != expected {
      ice(_u8("varpopper sees mismatch"));
    }
  }
}

func read_nums(vp *varpopper) *array[var_number] {
  return &vp->nums;
}

}  // access varpopper

func es_note_var_initter(es *framescope, vn var_number) np {
  info *var_info = ref_var(es, vn);
  if case &Has(desc ctor_desc) = &info->initter {
    return NoFail;
  }
  desc ctor_desc = #get_init_ctor(es, &info->type);
  info->initter = Has(desc);
  return NoFail;
}

func es_note_var_destroyer(es *framescope, vn var_number) np {
  info *var_info = ref_var(es, vn);
  if case &Has(desc ctor_desc) = &info->destroyer {
    return NoFail;
  }
  desc ctor_desc = #get_destroy_ctor(es, &info->type);
  info->destroyer = Has(desc);
  return NoFail;
}

func check_def_expr(clq *clqueue, accessible array[access_entry_id], g te_generik_scope, parms *idy_genparms,
                    x *ast_expr_consume, pt *te_typeexpr, def_informal_name sym, frame_info_out *frame_info) np {
  ds defscope = {clq->cs, clq->im, clq, accessible, g, &parms->repls, ref_scope(parms), def_informal_name};
  es framescope = mk(&ds, ref_scope(parms), None);
  #check_expr_consume(&es, x, pt);
  // SCOPE: This is such a ghetto hack.
  es.gr.scope = Computed(move(&es.tscope));
  *frame_info_out = {Has(move(&es.gr))};
  return NoFail;
}

func check_expr_consume(es *framescope, x *ast_expr_consume, pt *te_typeexpr) np {
  // If you change this, see also check_expr_retconsume.
  #check_expr_ai(es, AllowIncompleteNo, &x->expr, pt);
  #annotate_disposal_for_consume(es, &x->expr, &x->after);
  return NoFail;
}

func check_expr_retconsume(es *framescope, x *ast_expr_consume, pt *te_typeexpr,
                           movable_cells *shray[opt[cell_num]], moved_cell_ix_out *opt[size]) np {
  #check_expr_ai(es, AllowIncompleteNo, &x->expr, pt);
  #annotate_disposal_for_consume(es, &x->expr, movable_cells, &x->after, moved_cell_ix_out);
  return NoFail;
}

func replaced_name_parms(ds *defscope, scope *type_scope, a *ast_name_expr, out *genparms) np {
  if case &Has(arr array[ast_typeexpr]) = &a->generic_params {
    replaced array[te_typeexpr];
    // EMISSIONS: We discard these, because we'll re-cac parms later -- there's no expectation that they be computed yet.
    emissions array[unify_emission];
    n size = count(&arr);
    for i size = 0; i < n; i = i + 1 {
      converted te_typeexpr = #convert_typeexpr(ref(&arr, i));
      computed cac_typeexpr;
      #check_and_compute_typeexpr(ds->clq, ds->generics, scope, ds->repls, &converted, &emissions, &computed);
      push(&replaced, computed.te);
    }
    *out = HasParms(freeze(&replaced));
    return NoFail;
  } else {
    *out = NoParms;
    return NoFail;
  }
}

struct constructor_info {
  // A fn type.
  type cu_typeexpr;
  constructor_tag enum_tag_value;
  ip instpair;
  emissions shray[unify_emission];
}

struct voidconstructed_info {
  // The actual constructed type, which we need for some reason.
  constructed_type cu_typeexpr;
  // The enum type (the structural rhs of constructed_type).
  et enumspec;
  constructor_tag enum_tag_value;
}

enum ds_constructor_res {
  NoMatchConstructor void;
  AmbigMatchConstructor void;
  MatchedConstructor constructor_info;
  MatchedVoidConstructed voidconstructed_info;
}

// Like any pt, pt is either (a) incomplete, or (b) complete and computed.
func ds_lookup_constructor(ds *defscope, scope *type_scope, name sym, gp *genparms, pt *te_typeexpr) cr[ds_constructor_res] {
  if case &HasParms(a) = gp {
    return NoFail(NoMatchConstructor);
  }
  arg_type *te_typeexpr;
  return_type *te_typeexpr;
  switch tri_decompose_typeapp(pt, primitive_function_puretype(ds->cs), &arg_type, &return_type) {
  case BadPuretype:
    switch pt {
    case &TeName(te te_name):
      void;
    case &TeApp(te te_app):
      void;
    case &TeUnknown:
      return NoFail(AmbigMatchConstructor);
    default:
      return NoFail(NoMatchConstructor);
    }
    // TODO: Dedup some of the code from here on?
    if !is_complete(pt) {
      return NoFail(AmbigMatchConstructor);
    }
    et enumspec;
    switch structural_enumspec(ds, pt, &et) {
    case Error(pm):
      return Unprinted(pm);
    case Success:
      void;
    case NotAccessible:
      return NoFail(NoMatchConstructor);
    }

    rhs_type *te_typeexpr;
    decl_index size;
    if !find_vardecl(&et.constructors, name, &rhs_type, &decl_index) {
      return NoFail(NoMatchConstructor);
    }
    void_type te_typeexpr = primitive_void_type(ds->cs);
    if !unifies(&void_type, rhs_type) {
      return NoFail(NoMatchConstructor);
    }
    return NoFail(@[ds_constructor_res]MatchedVoidConstructed({~ *pt, et, mk_enum_tag_value(decl_index)}));
  case BadArity:
    return NoFail(NoMatchConstructor);
  case Success:
    emissions array[unify_emission];
    cac_return_type cac_typeexpr;
    #nogeneric_check_and_compute_typeexpr(ds->clq, scope, return_type, &emissions, &cac_return_type);
    if !cac_return_type.complete {
      return NoFail(AmbigMatchConstructor);
    }
    et enumspec;
    switch structural_enumspec(ds, &cac_return_type.te, &et) {
    case Error(pm):
      return Unprinted(pm);
    case Success:
      void;
    case NotAccessible:
      return NoFail(NoMatchConstructor);
    }
    rhs_type *te_typeexpr;
    decl_index size;
    if !find_vardecl(&et.constructors, name, &rhs_type, &decl_index) {
      return NoFail(NoMatchConstructor);
    }
    // rhs_type is complete.
    unified te_typeexpr;
    if !unify_types(scope, arg_type, rhs_type, &emissions, &unified) {
      return NoFail(NoMatchConstructor);
    }
    ctor_type te_typeexpr = fn_type(ds->cs, *rhs_type, cac_return_type.te);
    cac_ctor_type cac_typeexpr;
    #nogeneric_check_and_compute_typeexpr(ds->clq, scope, &ctor_type, &emissions, &cac_ctor_type);
    check(cac_ctor_type.complete);

    ip instpair = #lookup_or_make_enum_constructor_def(ds, scope, &et, &cac_return_type.te, &cac_ctor_type.te, decl_index);

    return NoFail(@[ds_constructor_res]MatchedConstructor({~cac_ctor_type.te, mk_enum_tag_value(decl_index), ip, freeze(&emissions)}));
  }
}

// return_type is the return type of ctor_type.  Both are complete and computed.
func lookup_or_make_enum_constructor_def(ds *defscope, scope *type_scope, et *enumspec, return_type *te_typeexpr,
                                         ctor_type *te_typeexpr, decl_index size) cr[instpair] {
  defname_u8 array[u8] = _u8("$magic_enum_ctor_");
  build_u8str(void, &defname_u8, &decl_index);
  defname sym = intern(ds->im, from_u8(defname_u8));

  nogp genparms = NoParms;
  if true {
    res match_def_res;
    #match_def(ds->cs, defname, scope, &nogp, ctor_type, &res);
    switch &res {
    case &NoMatch:
      void;
    case &MultiMatch:
      ice(_u8("magic_enum_ctor lookup sees MultiMatch"));
    case &OneMatch(m ent_and_parms):
      // EMISSIONS: We've already established the emissions when creating the ctor_type?  No?  So we ignore m.emissions?
      inst_id def_inst_id;
      if case Unprinted(pm) = make_inst(ds->clq, m.ent, scope, &m.parms, &inst_id) {
        ice(_u8("lookup_or_make_enum_constructor_def make_inst failed after match: "), pm.msg);
      }
      return NoFail({m.ent, inst_id});
    }
  }

  // There was no match -- so we make the def ourselves.
  rhs_type *te_typeexpr = &ref(&et->constructors, decl_index)->type;
  rhs_props type_properties;
  #compute_complete_type_properties(ds->clq, scope, rhs_type, &rhs_props);

  meco magic_enum_construct_op;
  switch &rhs_props.move_behavior {
  case &DerivedMethodAbsent:
    copy_desc ctor_desc = #behavior_to_desc(&rhs_props.copy_behavior);
    destroy_desc ctor_desc = #behavior_to_desc(&rhs_props.destroy_behavior);
    meco = EnumConstructCopyDestroy({copy_desc, destroy_desc});
  case &DerivedMethodExplicit(dme derived_method_explicit):
    meco = EnumConstructMove(FunCtor(dme.ip));
  case &DerivedMethodNontrivial(ip instpair):
    meco = EnumConstructMove(FunCtor(ip));
  case &DerivedMethodTrivial:
    meco = EnumConstructMove(TrivialCtor);
  }

  return_type_props type_properties;
  #compute_complete_type_properties(ds->clq, scope, return_type, &return_type_props);

  mec magic_enum_construct = {*et, ~ *return_type, return_type_props, decl_index, rhs_props, meco};

  ent def_entry_id = add_def_primitive(ds->cs, defname, TeNoGenerics, *ctor_type,
                                       @[def_definition]DefnMagic(MagicEnumConstruct(mec)));
  inst_id def_inst_id;
  if case Unprinted(pm) = make_inst(ds->clq, ent, scope, &nogp, &inst_id) {
    ice(_u8("lookup_or_make_enum_constructor_def make_inst failed on fresh def: "), pm.msg);
  }

  return NoFail({ent, inst_id});
}

struct es_global_match {
  ent_id def_entry_id;
  inst_id def_inst_id;
  parms genparms;
  emissions shray[unify_emission];
}

struct es_local_match {
  varnum var_number;
  emissions shray[unify_emission];
}

enum es_match_res {
  NoMatch void;
  AmbigGlobalMatch void;
  NoGlobalAmbigEnumConstructorMatch void;
  OneGlobalMatch es_global_match;
  OneLocalMatch es_local_match;
  OneEnumConstructorMatch constructor_info;
  EnumVoidConstructedMatch voidconstructed_info;
}

func es_lookup_name(es *framescope, name sym, gp *genparms, pt *te_typeexpr, res_out *es_match_res) np {
  if case &NoParms = gp {
    if case Has(num var_number) = es_find_current_local(es, name) {
      vartype *cu_typeexpr = &ref_var(es, num)->type;
      type te_typeexpr;
      emissions array[unify_emission];
      if !unify_types(&es->tscope, pt, &vartype->x, &emissions, &type) {
        return ERR(_u8("local '"), lookup(es->im, name), _u8("' has wrong type: '"),
                   pretty(es->im, vartype), _u8("' where '"), pretty(es->im, pt), _u8("' expected"));
      }
      *res_out = OneLocalMatch({num, freeze(&emissions)});
      return NoFail;
    }
  }

  res match_def_res;
  #match_def(es->cs, name, &es->tscope, gp, pt, &res);

  switch &res {
  case &NoMatch:
    constructor_res ds_constructor_res = #ds_lookup_constructor(es->ds, &es->tscope, name, gp, pt);
    switch &constructor_res {
    case &NoMatchConstructor:
      *res_out = NoMatch;
    case &AmbigMatchConstructor:
      *res_out = NoGlobalAmbigEnumConstructorMatch;
    case &MatchedConstructor(inf constructor_info):
      *res_out = OneEnumConstructorMatch(inf);
    case &MatchedVoidConstructed(inf voidconstructed_info):
      *res_out = EnumVoidConstructedMatch(inf);
    }
    return NoFail;
  case &MultiMatch:
    *res_out = AmbigGlobalMatch;
    return NoFail;
  case &OneMatch(m ent_and_parms):
    inst_id def_inst_id;
    #make_inst(es->clq, m.ent, &es->tscope, &m.parms, &inst_id);
    *res_out = OneGlobalMatch({m.ent, inst_id, m.parms, m.emissions});
    return NoFail;
  }
}

func es_find_current_local(es *framescope, name sym) opt[var_number] {
  n size = count(&es->current_vars);
  for i size = 0; i < n; i = i + 1 {
    num var_number = es->current_vars[i];
    inf *var_info = ref_var(es, num);
    if case Has(s sym) = inf->name {
      if s == name {
        return Has(num);
      }
    }
  }
  return None;
}

func help_check_simple_literal(es *framescope, pt *te_typeexpr, type te_typeexpr,
                               errmsg_name array[u8], x *ast_expr) np {
  unified te_typeexpr;
  emissions array[unify_emission];
  if !unify_types(&es->tscope, pt, &type, &emissions, &unified) {
    return ERR(errmsg_name, _u8(" literal in bad place"));
  }
  if is_complete(&unified) {
    // The type passed in by the caller is one of bool, void, `*`[_], which won't create emissions in unify_types.  But we could append to emissions when we cac below.
    check(empty(&emissions));

    c cac_typeexpr;
    if case Unprinted(pm) = nogeneric_check_and_compute_typeexpr(es->clq, &es->tscope, &unified, &emissions, &c) {
      ice(_u8("help_check_simple_literal passed bad type: "), pm.msg);
    }
    check(c.complete);
    props type_properties;
    if case Unprinted(pm) = compute_complete_type_properties(es->clq, &es->tscope, &c.te, &props) {
      ice(_u8("help_check_simple_literal passed type with bad properties: "), pm.msg);
    }

    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~c.te, props})), ~c.te, props, {freeze(&emissions)})));
  } else {
    annotate_info(x, @[ast_expr_info]IncompleteCheck);
  }
  return NoFail;
}

// pt is either (a) incomplete, or (b) complete and computed.
func check_expr_ai(es *framescope, ai allow_incomplete, x *ast_expr, pt *te_typeexpr) np {
  if case &CompleteCheck(t ast_expr_complete_info) = &x->info {
    return NoFail;
  }

  if case Unprinted(pm err_printed) = help_check_expr_ai(es, ai, x, pt) {
    if !pm.printed_meta {
      // TODO: Get rid of this terrible hackish way to error message.  (By printing
      // location information everywhere.)
      return MERR_append(es->cs, x->meta, pm, _u8(" in this expression"));
    } else {
      return Unprinted(pm);
    }
  }

  return NoFail;
}

func copy_info(x *ast_expr_info, emissions emissions_info) ast_expr_info {
  switch x {
  case &NoInfo:
    return NoInfo;
  case &IncompleteCheck:
    return IncompleteCheck;
  case &CompleteCheck(i ast_expr_complete_info):
    return CompleteCheck({i.lval, i.cu, i.cu_props, emissions});
  }
}

func help_check_expr_ai(es *framescope, ai allow_incomplete, x *ast_expr, pt *te_typeexpr) np {
  switch &x->u {
  case &NameExpr(a ast_name_expr):
    return check_expr_name(es, ai, &a, pt, x);

  case &ParenExpr(a ast_paren_expr):
    #check_expr_ai(es, ai, oo(&a.expr), pt);
    annotate_info(x, copy_info(&oo(&a.expr)->info, {mk_empty_emittance()}));
    return NoFail;

  case &NumericLiteral(a ast_numeric_literal):
    return check_numeric_literal(es, ai, pt, numeric_literal_value(&a), x);

  case &BoolLiteral(a ast_bool_literal):
    return help_check_simple_literal(es, pt, primitive_bool_type(es->cs), _u8("bool"), x);

  case &VoidLiteral(a ast_void_literal):
    return help_check_simple_literal(es, pt, primitive_void_type(es->cs), _u8("void"), x);

  case &NullLiteral(a ast_null_literal):
    return help_check_simple_literal(es, pt, ptr_type(es->cs, TeUnknown), _u8("null"), x);

  case &CharLiteral(a ast_char_literal):
    return check_numeric_literal(es, ai, pt, ~a.charspec.value, x);

  case &StringLiteral(a ast_string_literal):
    return check_expr_string_literal(es, &a, pt, x);

  case &Funcall(a ast_funcall):
    return check_expr_funcall(es, ai, &a, pt, x);

  case &LogicalConjunction(a ast_logical_conjunction):
    return check_expr_logical_conjunction(es, &a, pt, x);

  case &Assignment(a ast_assignment):
    return check_expr_assignment(es, &a, pt, x);

  case &RefOf(a ast_refof):
    return check_expr_refof(es, &a, pt, x);

  case &AddressOf(a ast_addressof):
    return check_expr_addressof(es, &a, pt, x);

  case &Deref(a ast_deref):
    return check_expr_deref(es, &a, pt, x);

  case &IndexExpr(a ast_index_expr):
    return check_expr_index(es, &a, pt, x);

  case &Lambda(a ast_lambda):
    return check_expr_lambda(es, &a, pt, x);

  case &LocalField(a ast_local_field):
    return check_expr_local_field(es, &a, pt, x);

  case &DerefField(a ast_deref_field):
    return check_expr_deref_field(es, &a, pt, x);

  case &TypedExpr(a ast_typed_expr):
    return check_expr_typed_expr(es, ai, &a, pt, x);

  case &Strinit(a ast_strinit):
    return check_expr_strinit(es, ai, &a, pt, x);

  case &Ternary(a ast_ternary):
    return check_expr_ternary(es, ai, &a, pt, x);

  case &QuickReturn(a ast_quickreturn):
    return check_expr_quickreturn(es, ai, &a, pt, x);
  }
}

func success_enum_case_info(ds *defscope, cu *cu_typeexpr, success_case_ix_out *size, et_out *enumspec) np {
  et enumspec;
  switch structural_enumspec(ds, &cu->x, &et) {
  case Error(pm err_printed):
    return Unprinted(pm);
  case Success:
    if case Has(ix size) = et.success_case_ix {
      *success_case_ix_out = ix;
      *et_out = et;
      return NoFail;
    } else {
      return ERR(_u8("Bad type (enum without success case) in quick-return"));
    }
  case NotAccessible:
    return ERR(_u8("Bad type (not enum) in quick-return"));
  }
}

func structurally_convertible_in_non_success(rhs_success_ix size, rhs_constructors *shray[te_vardecl],
                                             return_success_ix size, return_et *enumspec, out *bool,
                                             constructor_mapping_out *array[size]) np {
  // For now we're going to be uber-restrictive and require exactly the same constructor
  // ordering (and of course exactly the same enum case types).  "Structurally
  // convertible" is designed around generic enum types like opt[T] or cr[T].

  n size = count(rhs_constructors);
  if n != count(&return_et->constructors) || rhs_success_ix != return_success_ix {
    *out = false;
    return NoFail;
  }

  constructor_mapping array[size];
  for i size = 0; i < n; i = i + 1 {
    push(&constructor_mapping, i);
    if i != rhs_success_ix {
      rhs_constructor *te_vardecl = ref(rhs_constructors, i);
      return_constructor *te_vardecl = ref(&return_et->constructors, i);
      if rhs_constructor->name != return_constructor->name {
        *out = false;
        return NoFail;
      }
      if !help_idy_typeexpr_equal(&rhs_constructor->type, &return_constructor->type) {
        *out = false;
        return NoFail;
      }
    }
  }

  *out = true;
  swap(constructor_mapping_out, &constructor_mapping);
  return NoFail;
}

func check_expr_quickreturn(es *framescope, ai allow_incomplete, a *ast_quickreturn, pt *te_typeexpr, x *ast_expr) np {
  if case Has(return_type *cu_typeexpr) = es->return_type {
    // In order for a quickreturn expression to be valid, the following must be true:
    //   a. the rhs must be an enum type with a success case
    //   b. the pt must be the success case's inside type
    //   c. the return type of the fullbody we're in must be an enum type that is
    //      "structurally convertible in the non-success cases" from the rhs enum type.
    //      For example, opt[foo] is structurally convertible (in the non-success cases)
    //      from opt[bar].
    //
    // Because the rhs can be _any_ enum type, for now we'll evaluate the rhs with no pt,
    // and AllowIncompleteNo, and then see if that matches up with the lhs.  Eventually we
    // can implement "looking through the enum" logic -- that will be necessary for
    // arithmetic overflow.

    rhs_pt te_typeexpr = TeUnknown;
    #check_expr_ai(es, AllowIncompleteNo, oo(&a->rhs), &rhs_pt);

    rhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->rhs));

    success_case_ix size;
    et enumspec;
    #success_enum_case_info(es->ds, &rhs_info->cu, &success_case_ix, &et);

    success_case_type *te_typeexpr = &ref(&et.constructors, success_case_ix)->type;

    emissions array[unify_emission];
    unified te_typeexpr;
    if !unify_types(&es->tscope, pt, success_case_type, &emissions, &unified) {
      return ERR(_u8("quick-return expr has bad type"));
    }

    return_success_case_ix size;
    return_et enumspec;
    #success_enum_case_info(es->ds, return_type, &return_success_case_ix, &return_et);

    is_structurally_convertible bool;
    constructor_mapping array[size];
    #structurally_convertible_in_non_success(success_case_ix, &et.constructors,
                                             return_success_case_ix, &return_et, &is_structurally_convertible,
                                             &constructor_mapping);
    if !is_structurally_convertible {
      return ERR(_u8("quick-return types not structurally convertible"));
    }

    success_case_cu cu_typeexpr = ~ *success_case_type;
    success_case_props type_properties;
    #compute_type_properties(es->clq, &es->tscope, &success_case_cu, &success_case_props);

    lval is_lval;
    switch &rhs_info->lval {
    case &IsLvalYes(desc lval_description):
      lval = IsLvalYes({add_cell(es, {LocationVirtual, success_case_cu, success_case_props}), DeadMe,
            enum_field_ipse(es, desc.ipse, success_case_cu)});
    case &IsLvalNo(desc rval_description):
      lval = IsLvalNo({desc.whole_num, add_cell(es, {LocationVirtual, success_case_cu, success_case_props})});
    }

    annotate_info(x, CompleteCheck(mk(lval, success_case_cu, success_case_props, {freeze(&emissions)})));

    constructors_props array[type_properties];
    #compute_complete_vardecl_properties(es->clq, &es->tscope, &et.constructors, &constructors_props);

    tag_cell cell_num = add_virtual_tag_cell(es, &et);
    return_tag_cell cell_num = add_virtual_tag_cell(es, &et);
    annotate(&a->info, {tag_cell, et, move(&constructors_props), return_tag_cell, return_et, constructor_mapping});

    return NoFail;
  } else {
    return ERR(_u8("quick-return expression outside body"));
  }
}

func check_expr_refof(es *framescope, a *ast_refof, pt *te_typeexpr, x *ast_expr) np {
  ref_skeleton te_typeexpr = mk_ref_type(es->cs, TeUnknown, TeUnknown);
  emissions_discard array[unify_emission];
  unif_pt te_typeexpr;
  if !unify_types(&es->tscope, pt, &ref_skeleton, &emissions_discard, &unif_pt) {
    return ERR(_u8("RefOf expr in non-ref context"));
  }
  // No emissions are possible, we used TeUnknown everywhere.
  check(empty(&emissions_discard));

  pt_ipse *te_typeexpr;
  pt_param *te_typeexpr;
  if !decompose_ref(&unif_pt, es->cs, &pt_ipse, &pt_param) {
    ice(_u8("RefOf sees non-ref after unifying with ref."));
  }

  // We require complete matching because addressof requires it.  Addressof says meh, the
  // rhs should be some crystal clear lvalue anyway.
  #check_expr_ai(es, AllowIncompleteNo, oo(&a->rhs), pt_param);

  rhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->rhs));
  switch &rhs_info->lval {
  case &IsLvalNo(desc rval_description):
    // TODO: Support taking reference of an rvalue -- have it become a temporary that
    // expires... when it can.
    return ERR(_u8("Taking reference of a non-lvalue"));
  case &IsLvalYes(desc lval_description):
    emissions array[unify_emission];
    unified_ipse te_typeexpr;
    if !unify_types(&es->tscope, pt_ipse, &desc.ipse, &emissions, &unified_ipse) {
      return ERR(_u8("Refof ipse types do not match."));
    }

    ref_type te_typeexpr = mk_ref_type(es->cs, unified_ipse, rhs_info->cu.x);
    ref_computed cac_typeexpr;
    #nogeneric_check_and_compute_typeexpr(es->clq, &es->tscope, &ref_type, &emissions, &ref_computed);
    // (TODO: Make lval desc.ipse be a te_ipse, so it can't be incomplete?)
    if !ref_computed.complete {
      return ERR(_u8("ICE?  lval desc.ipse must have been incomplete (after complete type-check)."));
    }

    ref_props type_properties;
    #compute_complete_type_properties(es->clq, &es->tscope, &ref_computed.te, &ref_props);
    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ref_computed.te, ref_props})),
                                      ~ref_computed.te, ref_props, {freeze(&emissions)})));
    return NoFail;
  }
}

func check_expr_ternary(es *framescope, ai allow_incomplete, a *ast_ternary, pt *te_typeexpr, x *ast_expr) np {
  boolean cu_typeexpr = compute_bool(es->clq);
  #check_consume_then_discard_expr(es, oo(&oo(&a->condition)->expr), &boolean.x, &oo(&a->condition)->discard);
  #check_expr_consume(es, oo(&a->then_clause), pt);
  #check_expr_consume(es, oo(&a->else_clause), pt);

  conjoined cell_num;
  if true {
    then_cell *cell_info = ref_cell(es, result_cell(oo(&a->then_clause)));
    conjoined = add_cell(es, {LocationStatic, then_cell->type, then_cell->props});
  }
  reannotate_static_to_virtual(es, result_cell(oo(&a->then_clause)));
  reannotate_static_to_virtual(es, result_cell(oo(&a->else_clause)));
  conj *cell_info = ref_cell(es, conjoined);
  annotate_info(x, @[ast_expr_info]CompleteCheck({IsLvalNo({conjoined, conjoined}), conj->type, conj->props, {mk_empty_emittance()}}));
  return NoFail;
}

func check_expr_typed_expr(es *framescope, ai allow_incomplete, a *ast_typed_expr, pt *te_typeexpr, x *ast_expr) np {
  // TODO: Cache converted.
  converted te_typeexpr = #convert_typeexpr(&a->type);
  emissions array[unify_emission];
  // We call check_and_compute_typeexpr to disallow totally bogus typeexprs more directly
  // than the eventual type error that would happen.
  computed cac_typeexpr;
  #check_and_compute_typeexpr(es->clq, es->ds->generics, &es->tscope, es->ds->repls, &converted, &emissions, &computed);
  unified te_typeexpr;
  if !unify_types(&es->tscope, pt, &computed.te, &emissions, &unified) {
    return ERR(_u8("TypedExpr is incompatible with contextual type."));
  }
  unified_computed cac_typeexpr;
  if computed.complete {
    unified_computed = computed;
  } else {
    if case Unprinted(pm) = nogeneric_check_and_compute_typeexpr(es->clq, &es->tscope, &unified, &emissions, &unified_computed) {
      return ERR(_u8("TypedExpr encounters un-computable unified type: "), pm.msg);
    }
  }
  #check_expr_ai(es, ai, oo(&a->expr), &unified_computed.te);
  // Obviously (it's obvious to me) sometimes these computed emissions get discarded, but then they'll get recomputed.
  annotate_info(x, copy_info(&oo(&a->expr)->info, {freeze(&emissions)}));
  return NoFail;
}

func check_expr_deref_field(es *framescope, a *ast_deref_field, pt *te_typeexpr, x *ast_expr) np {
  // The fact that our partial type isn't a pointer type is deliberate.
  unknown te_typeexpr = TeUnknown;
  #check_consume_then_discard_expr(es, oo(&a->lhs), &unknown, &a->ptr_discard);
  info *ast_expr_complete_info = expr_complete_info(&oo(&a->lhs)->expr);
  ipse te_typeexpr;
  param *te_typeexpr;
  if !decompose_ref_or_ptr(&info->cu, es, &ipse, &param) {
    return ERR(_u8("Expected pointer for lhs of deref field"));
  }
  cu_param cu_typeexpr = ~ *param;
  fieldtype cu_typeexpr;
  emissions shray[unify_emission];
  cf_res check_field_result;
  #check_field(es, &cu_param, &a->fieldname, pt, &fieldtype, &emissions, &cf_res);
  props type_properties;
  #compute_type_properties(es->clq, &es->tscope, &fieldtype, &props);
  lval is_lval;
  switch cf_res {
  case InheritsLval(off check_field_offset_and_index):
    // We deref, so it's always an lval.
    lval = IsLvalYes({add_cell(es, {LocationVirtual, fieldtype, props}), DeadMe, field_ipse(es, ipse, fieldtype)});
    annotate(&a->info, DerefFieldName(@[ast_field_info]{off.offset, off.index}));
  case ConstantField(value u32):
    lval = wholeRval(add_cell(es, {LocationStatic, fieldtype, props}));
    annotate(&a->info, DerefArrayLength(value));
  }
  annotate_info(x, CompleteCheck(mk(lval, fieldtype, props, {emissions})));
  return NoFail;
}

// Not sure we use field_ipse properly(?) for rvalue fields?  Deref+indexing fields?
func field_ipse(es *framescope, outer_ipse te_typeexpr, inner_cu cu_typeexpr) te_typeexpr {
  return misc_ipse(es, inner_cu);
}

// This ipse's validity and presence is really conditional on a tag value, so... uh, beware?
func enum_field_ipse(es *framescope, outer_ipse te_typeexpr, inner_cu cu_typeexpr) te_typeexpr {
  return misc_ipse(es, inner_cu);
}

// Varnames aren't supposed to shadow, so... we have user-friendly ipse names.  (Note
// that vars could shadow generic ipse parameters, for now, so we add the $var_
// prefix.)
func varname_ipse(es *framescope, name sym, oftype cu_typeexpr, scope_app *type_scope) te_typeexpr {
  n sym = intern(es->im, _s("$var_") + lookup(es->im, name) + _s("_") + from_u8(to_u8str(es->ipse_gen_counter)));
  es->ipse_gen_counter++;
  scope_add(scope_app, n, oftype);
  return TeIpse({n});
}

// Makes a miscellaneous ipse.
func misc_ipse(es *framescope, oftype cu_typeexpr) te_typeexpr {
  n sym = intern(es->im, _s("$frame_") + from_u8(to_u8str(void, es->ipse_gen_counter)));
  es->ipse_gen_counter++;
  scope_add(&es->tscope, n, oftype);
  return TeIpse({n});
}

// Rvalues' ipses are generally created with this.
func unnamed_ipse(es *framescope, oftype cu_typeexpr) te_typeexpr {
  return misc_ipse(es, oftype);
}

func check_expr_local_field(es *framescope, a *ast_local_field, pt *te_typeexpr, x *ast_expr) np {
  unknown te_typeexpr = TeUnknown;
  #check_expr_ai(es, AllowIncompleteNo, oo(&a->lhs), &unknown);
  info *ast_expr_complete_info = expr_complete_info(oo(&a->lhs));
  fieldtype cu_typeexpr;
  emissions shray[unify_emission];
  cf_res check_field_result;
  #check_field(es, &info->cu, &a->fieldname, pt, &fieldtype, &emissions, &cf_res);
  props type_properties;
  #compute_type_properties(es->clq, &es->tscope, &fieldtype, &props);
  lval is_lval;
  switch cf_res {
  case InheritsLval(off check_field_offset_and_index):
    switch &info->lval {
    case &IsLvalYes(desc lval_description):
      lval = IsLvalYes({add_cell(es, {LocationVirtual, fieldtype, props}), DeadMe,
                        field_ipse(es, desc.ipse, fieldtype)});
    case &IsLvalNo(desc rval_description):
      lval = IsLvalNo({desc.whole_num, add_cell(es, {LocationVirtual, fieldtype, props})});
    }
    // There's no disposal, it's a real field access.
    annotate(&a->info, FieldName(@[ast_field_info]{off.offset, off.index}));
  case ConstantField(value u32):
    after nc[ast_expr_after_discard] = NotComputed;
    #annotate_disposal_for_discard(es, oo(&a->lhs), &after);
    annotate(&a->info, @[ast_local_field_info]ArrayLength({*un(&after), value}));
    lval = wholeRval(add_cell(es, {LocationStatic, fieldtype, props}));
  }
  annotate_info(x, CompleteCheck(mk(lval, fieldtype, props, {emissions})));
  return NoFail;
}

func check_expr_deref(es *framescope, a *ast_deref, pt *te_typeexpr, x *ast_expr) np {
  ptr_pt te_typeexpr = TeUnknown;
  // Let's force the rhs to be a complete type.  Because why not!
  #check_consume_then_discard_expr(es, oo(&a->rhs), &ptr_pt, &a->ptr_discard);
  rhs_type *cu_typeexpr = expr_complete_type(&oo(&a->rhs)->expr);
  ipse te_typeexpr;
  param *te_typeexpr;
  if decompose_ref_or_ptr(rhs_type, es, &ipse, &param) {
    // param is already complete.
    emissions array[unify_emission];
    unified_discard te_typeexpr;
    if !unify_types(&es->tscope, pt, param, &emissions, &unified_discard) {
      return ERR(_u8("Pointer dereferences into wrong type."));
    }

    props type_properties;
    #compute_complete_type_properties(es->clq, &es->tscope, param, &props);
    annotate_info(x, CompleteCheck(mk(@[is_lval]IsLvalYes({add_cell(es, {LocationVirtual, ~ *param, props}),
                                                           DeadMe, ipse}),
                                      ~ *param, props, {freeze(&emissions)})));
    return NoFail;
  }
  return ERR(_u8("Trying to deref a non-pointer, non-reference."));
}

func check_expr_addressof(es *framescope, a *ast_addressof, pt *te_typeexpr, x *ast_expr) np {
  ptr_skeleton te_typeexpr = ptr_type(es->cs, TeUnknown);
  emissions array[unify_emission];
  unif_pt te_typeexpr;
  if !unify_types(&es->tscope, pt, &ptr_skeleton, &emissions, &unif_pt) {
    return ERR(_u8("AddressOf expr in non-pointer context"));
  }
  param *te_typeexpr;
  if !decompose_typeapp(&unif_pt, primitive_pointer_puretype(es->cs), &param) {
    ice(_u8("AddressOf sees non-pointer after unifying with pointer."));
  }
  // We require complete matching, because, meh, the rhs should be some crystal clear
  // lvalue anyway.
  #check_expr_ai(es, AllowIncompleteNo, oo(&a->rhs), param);
  rhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->rhs));
  if case &IsLvalNo(desc rval_description) = &rhs_info->lval {
    // TODO: Support taking address of an rvalue -- have it become a temporary that
    // expires at the end of the full expression.
    return ERR(_u8("Taking address of a non-lvalue"));
  }

  ptr_type te_typeexpr = ptr_type(es->cs, rhs_info->cu.x);
  ptr_computed cac_typeexpr;
  #nogeneric_check_and_compute_typeexpr(es->clq, &es->tscope, &ptr_type, &emissions, &ptr_computed);
  check(ptr_computed.complete);
  ptr_props type_properties;
  #compute_complete_type_properties(es->clq, &es->tscope, &ptr_computed.te, &ptr_props);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ptr_computed.te, ptr_props})),
                                    ~ptr_computed.te, ptr_props, {freeze(&emissions)})));
  return NoFail;
}

func check_expr_assignment(es *framescope, a *ast_assignment, pt *te_typeexpr, x *ast_expr) np {
  void_typrop cu_typrop = compute_void(es->clq);
  if !unifies(&void_typrop.cu.x, pt) {
    return ERR(_u8("ICE: assignment in non-void place"));
  }


  unknown te_typeexpr = TeUnknown;
  // We check the lhs independently of the rhs, deliberately, to ensure clarity.
  #check_expr_ai(es, AllowIncompleteNo, oo(&a->lhs), &unknown);
  lhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->lhs));
  switch &lhs_info->lval {
  case &IsLvalNo(desc rval_description):
    return ERR(_u8("Assigning to non-lvalue"));
  case &IsLvalYes(desc lval_description):
    #check_expr_ai(es, AllowIncompleteNo, oo(&a->rhs), &lhs_info->cu.x);
    #annotate_disposal_for_assignment(es, desc.num, oo(&a->rhs), a);
    // I don't know if we really (in the long run) have empty emittance.  Like, the assignee and assignment value can't have certain relationships?
    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, void_typrop.cu, void_typrop.props})), void_typrop.cu, void_typrop.props, {mk_empty_emittance()})));
    return NoFail;
  }
}

func behavior_to_desc(b *derived_method_behavior) cr[ctor_desc] {
  switch b {
  case &DerivedMethodAbsent:
    return ERR(_u8("Cannot find derived method."));
  case &DerivedMethodExplicit(dme derived_method_explicit):
    return NoFail(FunCtor(dme.ip));
  case &DerivedMethodNontrivial(ip instpair):
    return NoFail(FunCtor(ip));
  case &DerivedMethodTrivial:
    return NoFail(TrivialCtor);
  }
}

func get_init_ctor(es *framescope, t *cu_typeexpr) cr[ctor_desc] {
  props type_properties;
  #compute_type_properties(es->clq, &es->tscope, t, &props);
  return behavior_to_desc(&props.init_behavior);
}

func get_copy_ctor(es *framescope, t *cu_typeexpr) cr[ctor_desc] {
  props type_properties;
  #compute_type_properties(es->clq, &es->tscope, t, &props);
  return behavior_to_desc(&props.copy_behavior);
}

func get_move_ctor(es *framescope, t *cu_typeexpr) cr[ctor_desc] {
  props type_properties;
  #compute_type_properties(es->clq, &es->tscope, t, &props);
  return behavior_to_desc(&props.move_behavior);
}

func get_destroy_ctor(es *framescope, t *cu_typeexpr) cr[ctor_desc] {
  props type_properties;
  #compute_type_properties(es->clq, &es->tscope, t, &props);
  return behavior_to_desc(&props.destroy_behavior);
}

func annotate_disposal_for_consume(es *framescope, a *ast_expr, after *nc[ast_expr_after_consume]) np {
  movable_cells shray[opt[cell_num]];
  moved_cell_ix_discard opt[size];
  return annotate_disposal_for_consume(es, a, &movable_cells, after, &moved_cell_ix_discard);
}

// Annotates the disposal to "consume" the value -- i.e. what happens if it's a function
// param or otherwise a "use-once" value (i.e. to be copied/moved into a param list, or
// whatever).
func annotate_disposal_for_consume(es *framescope, a *ast_expr, movable_cells *shray[opt[cell_num]],
                                   after *nc[ast_expr_after_consume], moved_cell_ix_out *opt[size]) np {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
  case &IsLvalNo(desc rval_description):
    if whole_temporary(&desc) {
      annotate(after, mk_after(@[consume_actions]ConsumeByInPlace, desc.whole_num));
    } else {
      copy ctor_desc = #get_copy_ctor(es, &info->cu);
      destroy ctor_desc = #get_destroy_ctor(es, &ref_cell(es, desc.whole_num)->type);
      dest cell_num = add_cell(es, {LocationStatic, info->cu, info->cu_props});
      annotate(after,
        mk_after(@[consume_actions]ConsumeByCopyDestroy({+{copy, dest, desc.partial_num},
                                                         +{destroy, desc.whole_num}}),
                 dest));
    }
    *moved_cell_ix_out = None;
  case &IsLvalYes(desc lval_description):
    dest cell_num = add_cell(es, {LocationStatic, info->cu, info->cu_props});
    if case Has(ix size) = find(movable_cells, Has(desc.num)) {
      move ctor_desc = #get_move_ctor(es, &info->cu);
      annotate(after, mk_after(@[consume_actions]ConsumeByMove(@[move_action]+{move, dest, desc.num}), dest));
      *moved_cell_ix_out = Has(ix);
    } else {
      copy ctor_desc = #get_copy_ctor(es, &info->cu);
      annotate(after, mk_after(@[consume_actions]ConsumeByCopy({@[copy_action]+{copy, dest, desc.num},
                                                                desc.deadme}),
                               dest));
      *moved_cell_ix_out = None;
    }
  }
  return NoFail;
}

// Annotates the disposal of an Expr statement's expr, or some other value we are done using.
func annotate_disposal_for_discard(es *framescope, a *ast_expr, after *nc[ast_expr_after_discard]) np {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
  case &IsLvalNo(desc rval_description):
    destroy ctor_desc = #get_destroy_ctor(es, &ref_cell(es, desc.whole_num)->type);
    annotate(after, mk_after_discard(@[destroy_action]+{destroy, desc.whole_num}));
  case &IsLvalYes(desc lval_description):
    if case DeadMe = desc.deadme {
      // This could ostensibly be Has(desc.num), but there's no reason to be
      // inconsistent with the rvalue case.
      annotate(after, mk_virtualdead_discard(desc.num));
    } else {
      annotate(after, mk_nothing_discard());
    }
  }
  return NoFail;
}


// Annotates the disposal for a value we'll use but then discard.
func annotate_disposal_for_consume_then_discard(es *framescope, a *ast_expr, after *nc[ast_expr_after_consume],
                                                later *ast_later_discard_info) np {
  #annotate_disposal_for_consume(es, a, after);

  info *ast_expr_complete_info = expr_complete_info(a);
  destroy ctor_desc = #get_destroy_ctor(es, &info->cu);
  annotate(&later->action, @[destroy_action]+{destroy, result_cell(un(after))});

  return NoFail;
}

func make_comparecells(es *framescope, dest cell_num) instpair {
  if case Has(ent def_entry_id) = es->cs->prims.ptr_eq {
    gp genparms = HasParms(mk_shray(ref_cell(es, dest)->type.x));
    parms idy_genparms;
    parms_emittance shray[unify_emission];
    if case Unprinted(pm) = check_and_compute_parms_with_canonicalization(es->clq, &es->tscope, &gp, &parms, &parms_emittance) {
      ice(_u8("make_comparecells re-cac'ing computed type"));
    }
    inst_id def_inst_id = enqueue_def_inst(es->clq, ent, &parms, &parms_emittance);
    return {ent, inst_id};
  } else {
    ice(_u8("cs->prims.ptr_eq not initialized"));
    return fake();
  }
}

func annotate_disposal_for_assignment(es *framescope, dest cell_num, a *ast_expr, assignment *ast_assignment) np {
  info *ast_expr_complete_info = expr_complete_info(a);
  switch &info->lval {
  case &IsLvalNo(desc rval_description):
    target_destroy ctor_desc = #get_destroy_ctor(es, &ref_cell(es, dest)->type);
    if whole_temporary(&desc) {
      move ctor_desc = #get_move_ctor(es, &ref_cell(es, dest)->type);
      annotate(&assignment->info,
        @[ast_assignment_info]
        SimpleMoveAssignment({@[destroy_action]+{target_destroy, dest},
                              @[move_action]+{move, dest, desc.whole_num}}));
    } else {
      // TODO: This dups code with other makers of DisposeCopyAndDestroy.
      copy ctor_desc = #get_copy_ctor(es, &ref_cell(es, dest)->type);
      destroy ctor_desc = #get_destroy_ctor(es, &ref_cell(es, desc.whole_num)->type);

      annotate(&assignment->info,
        @[ast_assignment_info]
        SimpleCopyDestroyAssignment({@[destroy_action]+{target_destroy, dest},
                                     @[copy_action]+{copy, dest, desc.partial_num},
                                     @[destroy_action]+{destroy, desc.whole_num}}));
    }
  case &IsLvalYes(desc lval_description):
    if dest == desc.num {
      // Static self-assignment!
      annotate(&assignment->info, StaticSelfAssignment);
    } else {
      target_destroy ctor_desc = #get_destroy_ctor(es, &ref_cell(es, dest)->type);
      copy ctor_desc = #get_copy_ctor(es, &ref_cell(es, dest)->type);
      do_conditional bool;
      switch &target_destroy {
      case &TrivialCtor:
        switch &copy {
        case &TrivialCtor:
          do_conditional = false;
        case &FunCtor(bfcd):
          do_conditional = true;
        }
      case &FunCtor(ip instpair):
        do_conditional = true;
      }
      if do_conditional {
        annotate(&assignment->info,
          @[ast_assignment_info]
          ConditionalAssignment({make_comparecells(es, dest),
                                 @[destroy_action]+{target_destroy, dest},
                                 @[copy_action]+{copy, dest, desc.num},
                                 desc.deadme}));
      } else {
        annotate(&assignment->info,
          @[ast_assignment_info]
          SimpleCopyAssignment({@[destroy_action]+{target_destroy, dest},
                                @[copy_action]+{copy, dest, desc.num},
                                desc.deadme}));
      }
    }
  }
  return NoFail;
}

func check_expr_name(es *framescope, ai allow_incomplete, a *ast_name_expr, pt *te_typeexpr, x *ast_expr) np {
  parms genparms;
  #replaced_name_parms(es->ds, &es->tscope, a, &parms);
  match_res es_match_res;
  #es_lookup_name(es, a->ident.value, &parms, pt, &match_res);
  switch &match_res {
  case &NoMatch:
    return MERR(es->cs, a->ident.meta, _u8("Name lookup for '"), lookup(es->im, a->ident.value),
                _u8("', maybe with parms, not found, matching type '"), pretty(es->im, pt), _u8("'"));

  case &AmbigGlobalMatch:
    if ai == AllowIncompleteYes {
      // NOTE: We could annotate this more precisely in ambiguous-single-match cases.
      annotate_info(x, @[ast_expr_info]IncompleteCheck);
      return NoFail;
    } else {
      return MERR(es->cs, a->ident.meta, _u8("Name lookup for '"), lookup(es->im, a->ident.value),
                  _u8("', maybe with parms, matches ambiguously over "), pretty(es->im, pt));
    }
  case &NoGlobalAmbigEnumConstructorMatch:
    if ai == AllowIncompleteYes {
      annotate_info(x, @[ast_expr_info]IncompleteCheck);
      return NoFail;
    } else {
      return MERR(es->cs, a->ident.meta, _u8("Name lookup for '"), lookup(es->im, a->ident.value),
                  _u8("', maybe with parms, not found, but cannot rule out enum constructor, on type '"),
                  pretty(es->im, pt),
                  _u8("'"));
    }

  case &OneEnumConstructorMatch(ci constructor_info):
    annotate(&a->name_info, @[ast_name_expr_info]EnumConstructor({ci.constructor_tag, ci.ip}));
    props type_properties;
    #compute_type_properties(es->clq, &es->tscope, &ci.type, &props);
    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ci.type, props})),
                                      ci.type, props, {ci.emissions})));
    return NoFail;
  case &EnumVoidConstructedMatch(vci voidconstructed_info):
    annotate(&a->name_info, @[ast_name_expr_info]EnumVoidConstructed({vci.constructor_tag, vci.et}));
    props type_properties;
    #compute_type_properties(es->clq, &es->tscope, &vci.constructed_type, &props);
    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, vci.constructed_type, props})),
                                      vci.constructed_type, props, {mk_empty_emittance()})));
    return NoFail;
  case &OneGlobalMatch(egm es_global_match):
    ent *def_entry = ref_def_entry(es->cs, egm.ent_id);

    emissions array[unify_emission];
    // This parallels or plagairizes ensure_def_inst_type_computed.
    // TODO: Dedup anything?
    matched_parms idy_repls;
    #check_and_compute_parms_no_canonicalize(es->clq, &es->tscope, &egm.parms, &emissions, &matched_parms);
    // ^ this is kind of weird -- we've done a global match, so we could just canonicalize the def inst parms/emittance or somethnig?  No?

    ent_typeexpr *te_typeexpr;
    #def_converted_typeexpr(ent, &ent_typeexpr);

    computed cac_typeexpr;
    #check_and_compute_typeexpr(es->clq, flatten(&ent->generics), &es->tscope, &matched_parms, ent_typeexpr, &emissions, &computed);

    check(computed.complete);
    cu_computed cu_typeexpr = ~computed.te;
    props type_properties;
    #compute_type_properties(es->clq, &es->tscope, &cu_computed, &props);

    append(&emissions, &egm.emissions);
    annotate(&a->name_info, @[ast_name_expr_info]GlobalResolve({egm.ent_id, egm.inst_id}));
    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, cu_computed, props})),
                                      cu_computed, props, {freeze(&emissions)})));
    return NoFail;

  case &OneLocalMatch(elm es_local_match):
    annotate(&a->name_info, @[ast_name_expr_info]LocalResolve({elm.varnum}));
    vi *var_info = ref_var(es, elm.varnum);
    annotate_info(x, CompleteCheck(mk(@[is_lval]IsLvalYes({vi->cell, DontDeadMe, vi->ipse.x}),
                                      vi->type, vi->props, {elm.emissions})));
    return NoFail;
  }
}

func check_expr_string_literal(es *framescope, a *ast_string_literal, pt *te_typeexpr, x *ast_expr) np {
  type cu_typeexpr;
  props type_properties;
  compute_prim(es->clq, primitive_string_literal_type(es->cs, count(&a->charspecs)),
               &type, &props);
  if !unifies(&type.x, pt) {
    return ERR(_u8("string literal in bad place"));
  }
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, type, props})), type, props, {mk_empty_emittance()})));
  return NoFail;
}

func check_expr_strinit(es *framescope, ai allow_incomplete, a *ast_strinit, pt *te_typeexpr, x *ast_expr) np {
  // I haven't thought about why emittance is empty in this function.  I guess because we expect the partial type to be complete.
  if !is_complete(pt) {
    if ai == AllowIncompleteYes {
      // NOTE: We could have more specific info, like number of fields and their incomplete types.
      annotate_info(x, @[ast_expr_info]IncompleteCheck);
      return NoFail;
    } else {
      return ERR(_u8("Structure literal used ambiguously."));
    }
  }

  // Since pt is complete, and since it's a pt, it's computed.
  if !is_complete_computed(pt).computed {
    ice(_u8("check_expr_strinit has non-computed pt"));
  }

  if case &TeArraytype(b te_arraytype) = pt {
    n u32 = *unHas(&b.count);  // We checked is_complete(pt).
    if n != ~count(&a->exprs) {
      return MERR(es->cs, a->meta, _u8("Structure literal has wrong number of fields."));
    }

    for i u32 = 0; i < n; i = i + 1 {
      x_i *ast_expr_consume = &ref(&a->exprs, ~i)->ec;
      #check_expr_consume(es, x_i, oo(&b.param));
      reannotate_static_to_virtual(es, result_cell(x_i));
    }

    // We checked is_computed(pt).
    props type_properties;
    #compute_complete_type_properties(es->clq, &es->tscope, pt, &props);

    // We checked is_computed(pt)
    param_props type_properties;
    #compute_complete_type_properties(es->clq, &es->tscope, oo(&b.param), &param_props);

    for i u32 = 0; i < n; i = i + 1 {
      p_i *ast_strinit_param = ref(&a->exprs, ~i);
      annotate(&p_i->info, {i * param_props.flat_size});
    }
    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ *pt, props})), ~ *pt, props, {mk_empty_emittance()})));
    return NoFail;
  } else {
    b structspec;
    switch structural_structspec(es->ds, pt, &b) {
    case Error(pm):
      return Unprinted(pm);
    case Success:
      void;
    case NotAccessible:
      return MERR(es->cs, a->meta, _u8("Strinit for inaccessible or non-structural type, "), pretty(es->im, pt));
    }

    n size = count(&b.fields);
    if n != count(&a->exprs) {
      return MERR(es->cs, a->meta, _u8("Structure literal has wrong number of fields."));
    }

    offsets array[u32];
    for i size = 0; i < n; i = i + 1 {
      x_i *ast_expr_consume = &ref(&a->exprs, i)->ec;
      field *te_vardecl = ref(&b.fields, i);
      #check_expr_consume(es, x_i, &field->type);
      reannotate_static_to_virtual(es, result_cell(x_i));
      psd partial_struct_data;
      #compute_partial_struct_data(es->clq, &es->tscope, &b.fields, Has(field->name), &psd);
      check(psd.found_field);
      push(&offsets, psd.offset);
    }

    // We checked is_computed(pt).
    props type_properties;
    #compute_complete_type_properties(es->clq, &es->tscope, pt, &props);

    for i size = 0; i < n; i = i + 1 {
      p_i *ast_strinit_param = &a->exprs[i];
      annotate(&p_i->info, {offsets[i]});
    }
    annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ *pt, props})), ~ *pt, props, {mk_empty_emittance()})));
    return NoFail;
  }
}

func check_expr_lambda(es *framescope, a *ast_lambda, pt *te_typeexpr, x *ast_expr) np {
  // TODO: Cache type.
  type ast_typeexpr = lambda_declared_type(es->im, a);
  // TODO: Cache converted.
  converted te_typeexpr = #convert_typeexpr(&type);

  // SCOPE: Local lifetimes can't be in scope -- the lambda doesn't capture anything.  When lambdas do capture, we'll have to handle that appropriately (depending on how capturing works).
  lambda_scope *type_scope = es->ds->deflevel_parms_scope;

  // TODO: I see some duplicated logic with the TypedExpr case.
  emissions array[unify_emission];
  computed cac_typeexpr;
  #check_and_compute_typeexpr(es->clq, es->ds->generics, lambda_scope, es->ds->repls, &converted, &emissions, &computed);
  // Lambda exprs can't have partial types (yet!).
  check(computed.complete);
  unified te_typeexpr;
  if !unify_types(lambda_scope, pt, &computed.te, &emissions, &unified) {
    return ERR(_u8("Lambda is incompatible with contextual type."));
  }

  computed_params *shray[te_typeexpr];
  if !decompose_typeapp(&computed.te, primitive_function_puretype(es->cs), &computed_params) {
    ice(_u8("lambda type is not a function type"));
  }

  if true {
    nargs size = count(&a->args);
    return_type cu_typeexpr = ~computed_params[nargs];
    #help_check_lambda_body(es->ds, lambda_scope, &return_type, a, computed_params);
  }

  props type_properties;
  #compute_complete_type_properties(es->clq, lambda_scope, &computed.te, &props);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~computed.te, props})),
                                    ~computed.te, props, {freeze(&emissions)})));
  return NoFail;
}

// This helper method shields its code from using the wrong (outer) framescope variable in
// check_expr_lambda.
func help_check_lambda_body(ds *defscope, scope *type_scope, return_type *cu_typeexpr, a *ast_lambda, computed_params *shray[te_typeexpr]) np {
  bs bodystate = mk(ds, scope, return_type);
  vp varpopper;
  init_vp(&vp, &bs.es);
  nargs size = count(&a->args);
  check(nargs + 1 == count(computed_params));
  arg_cells array[cell_num];
  for i size = 0; i < nargs; i = i + 1 {
    cu_param cu_typeexpr = ~computed_params[i];
    cu_param_props type_properties;
    #compute_type_properties(bs.clq, &bs.es.tscope, &cu_param, &cu_param_props);
    cell cell_num = add_cell(&bs.es, {LocationStatic, cu_param, cu_param_props});
    push(&arg_cells, cell);
    vn var_number;
    name *ast_ident = &a->args[i].name;
    #es_push_var(&bs.es, &vp, cell, Has(name), ~varname_ipse(&bs.es, name->value, cu_param, scope), &cu_param,
                 VarSelfContained, &vn);
    #es_note_var_destroyer(&bs.es, vn);
  }

  ee entryexit;
  #check_body(&bs, None, &a->body.bb, &ee);
  #finish_lambda_body(&bs, ee);

  destructions array[var_destruction];
  #make_destructions(&bs.es, read_nums(&vp), &destructions);

  return_type_props type_properties;
  #compute_type_properties(bs.clq, &bs.es.tscope, return_type, &return_type_props);
  return_cell cell_num = add_cell(&bs.es, {LocationStatic, *return_type, return_type_props});

  // SCOPE: Another even _more_ ghetto hack.
  bs.es.gr.scope = Computed(move(&bs.es.tscope));
  info ast_fullbody_info = {destructions, move(&bs.es.all_vars), Has(move(&bs.es.gr)), bs.gotos, bs.labels,
                            move(&bs.statements), return_cell, arg_cells};
  annotate(&a->body.info, info);

  return NoFail;
}

func numeric_literal_value(a *ast_numeric_literal) bigint {
  switch a {
  case &HexLiteral(b ast_hex_literal):
    return convert_to_bigint(16, &b.digits);
  case &DecLiteral(b ast_dec_literal):
    return convert_to_bigint(10, &b.digits);
  }
}

func check_numeric_literal(es *framescope, ai allow_incomplete, pt *te_typeexpr, n bigint, x *ast_expr) np {
  if case &TeUnknown = pt {
    if ai == AllowIncompleteYes {
      annotate_info(x, @[ast_expr_info]IncompleteCheck);
      return NoFail;
    } else {
      return ERR(_u8("Numeric literal usage is ambiguous."));
    }
  }

  facts numeric_traits;
  if !is_numeric_type(es->cs, pt, &facts) {
    return ERR(_u8("Numeric literal in bad place."));
  }
  if n < facts.minval || n > facts.maxval {
    return ERR(_u8("Numeric literal out of range."));
  }
  // It's a pt, and it's a numeric type, which means it must be a complete pt, which means
  // it's computed.
  check(is_complete_computed(pt).computed);
  props type_properties;
  #compute_complete_type_properties(es->clq, &es->tscope, pt, &props);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ *pt, props})), ~ *pt, props, {mk_empty_emittance()})));
  return NoFail;
}

// You really should use this, in case we decide to rearrange the order of parameters of
// the ref type.
func decompose_ref(t *te_typeexpr, cs *checkstate, ipse_out **te_typeexpr, param_out **te_typeexpr) bool {
  return decompose_typeapp(t, primitive_ref_puretype(cs), ipse_out, param_out);
}

// Writes a fake ipse in the case of pointer, a real ipse in the case of a reference.
func decompose_ref_or_ptr(t *cu_typeexpr, es *framescope, ipse_out *te_typeexpr, param_out **te_typeexpr) bool {
  lt *te_typeexpr;
  param *te_typeexpr;
  if decompose_ref(&t->x, es->cs, &lt, &param) {
    *ipse_out = *lt;
    *param_out = param;
    return true;
  }
  if decompose_typeapp(&t->x, primitive_pointer_puretype(es->cs), &param) {
    *ipse_out = misc_ipse(es, ~*param);
    *param_out = param;
    return true;
  }
  return false;
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, params_out **shray[te_typeexpr]) bool {
  // This could be implemented in terms of unify_under_generics, you know.
  if case &TeApp(app te_app) = t {
    unified te_puretype;
    if !unify_puretypes(&app.typefunc, &expected_puretype, &unified) {
      return false;
    }
    *params_out = &app.params;
    return true;
  } else {
    return false;
  }
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr) bool {
  params *shray[te_typeexpr];
  if !decompose_typeapp(t, expected_puretype, &params) {
    return false;
  }
  if count(params) != 1 {
    return false;
  }
  *oneparam_out = ref(params, 0);
  return true;
}

enum decompose_result {
  Success void;
  BadPuretype void;
  BadArity void;
}

func tri_decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr,
                           twoparam_out **te_typeexpr) decompose_result {
  params *shray[te_typeexpr];
  if !decompose_typeapp(t, expected_puretype, &params) {
    return BadPuretype;
  }
  if count(params) != 2 {
    return BadArity;
  }
  *oneparam_out = ref(params, 0);
  *twoparam_out = ref(params, 1);
  return Success;
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr,
                       twoparam_out **te_typeexpr) bool {
  if case Success = tri_decompose_typeapp(t, expected_puretype, oneparam_out, twoparam_out) {
    return true;
  } else {
    return false;
  }
}

func decompose_typeapp(t *te_typeexpr, expected_puretype te_puretype, oneparam_out **te_typeexpr,
                       twoparam_out **te_typeexpr, threeparam_out **te_typeexpr) bool {
  params *shray[te_typeexpr];
  if !decompose_typeapp(t, expected_puretype, &params) {
    return false;
  }
  if count(params) != 3 {
    return false;
  }
  *oneparam_out = ref(params, 0);
  *twoparam_out = ref(params, 1);
  *threeparam_out = ref(params, 2);
  return true;
}

struct check_field_offset_and_index {
  offset u32;
  index size;
}

enum check_field_result {
  // Inherits the lvalue-ness of the thing it's a field of.  Includes the field's offset
  // (in bnnos).
  InheritsLval check_field_offset_and_index;
  // Doesn't inherit the lvalue-ness.  In fact it's a compile-time constant (for the array
  // ".length" field).
  ConstantField u32;
}

func check_field(es *framescope, t *cu_typeexpr, a *ast_fieldname, pt *te_typeexpr,
                 fieldtype_out *cu_typeexpr, emissions_out *shray[unify_emission],
                 res_out *check_field_result) np {
  fieldtype cu_typeexpr;
  res check_field_result;
  #lookup_field(es, t, a, &fieldtype, &res);
  unified te_typeexpr;
  emissions array[unify_emission];
  if !unify_types(&es->tscope, pt, &fieldtype.x, &emissions, &unified) {
    return ERR(_u8("field has wrong type."));
  }
  *fieldtype_out = fieldtype;
  *emissions_out = freeze(&emissions);
  *res_out = res;
  return NoFail;
}

func structural_structspec(ds *defscope, t *te_typeexpr, st_out *structspec) structural_rhs_result {
  switch t {
  case &TeName(a te_name):
    ipse_mappings shray[sym];  // empty
    return help_structural_structspec(ds, unHas(&a.pack), &ipse_mappings, st_out);
  case &TeApp(a te_app):
    hp *te_app_pack = unHas(&a.pack);
    return help_structural_structspec(ds, &hp->teip, &hp->ipse_mappings, st_out);
  default:
    return NotAccessible;
  }
}

// et_out is set to a complete/computed value.
func structural_enumspec(ds *defscope, t *te_typeexpr, et_out *enumspec) structural_rhs_result {
  switch t {
  case &TeName(a te_name):
    ipse_mappings shray[sym]; // empty
    return help_structural_enumspec(ds, unHas(&a.pack), &ipse_mappings, et_out);
  case &TeApp(a te_app):
    hp *te_app_pack = unHas(&a.pack);
    return help_structural_enumspec(ds, &hp->teip, &hp->ipse_mappings, et_out);
  default:
    return NotAccessible;
  }
}

func deftype_rhs_info_accessible(ds *defscope, id deftype_entry_id, result_out *bool) np {
  ent *deftype_entry = ref_deftype_entry(ds->cs, id);
  if case &Has(np deftype_nonprim) = &ent->nonprim {
    rhs *deftype_rhs_spec;
    #deftype_converted_rhs(&np, &rhs);
    switch rhs {
    case &ClassexprRhsSpec(crs classexpr_rhs_spec):
      n size = count(&ds->accessible);
      for i size = 0; i < n; i = i + 1 {
        aid access_entry_id = ds->accessible[i];
        dti deftype_entry_id = #get_accessible_deftype(ds->cs, aid);
        if dti == id {
          *result_out = true;
          return NoFail;
        }
      }
      *result_out = false;
      return NoFail;
    case &DefstructRhsSpec(drs structspec):
      *result_out = true;
      return NoFail;
    case &DefenumRhsSpec(drs enumspec):
      *result_out = true;
      return NoFail;
    }
  } else {
    *result_out = false;
    return NoFail;
  }
}

enum structural_rhs_result {
  Error err_printed;
  Success void;
  NotAccessible void;
}

// Note that the caller will need to use its ipse_mappings to map the rhs type's ipses to the caller's ipses.
func help_structural_rhs_info(ds *defscope, pack *te_instpack,
                              rhs_info_out **deftype_inst_rhs_info) structural_rhs_result {
  accessible_result bool;
  if case Unprinted(pm) = deftype_rhs_info_accessible(ds, pack->ent_id, &accessible_result) {
    return Error(pm);
  }
  if !accessible_result {
    return NotAccessible;
  }
  if case Unprinted(pm) = ensure_deftype_inst_checked(ds->clq, pack->ent_id, pack->inst_id) {
    return Error(pm);
  }
  inst *deftype_inst = ref_deftype_inst(ds->cs, pack->inst_id);
  if case &Computed(info deftype_inst_info) = &inst->info {
    if case &Has(rhs_info deftype_inst_rhs_info) = &info.rhs {
      *rhs_info_out = &rhs_info;
      return Success;
    } else {
      ice(_u8("deftype_rhs_accessible permitted a primitive type."));
      return fake();
    }
  } else {
    ice(_u8("inst checked, info still None"));
    return fake();
  }
}

func map_enumspec_ipses(im *identmap, ipse_mappings *shray[sym], inn *enumspec, out *enumspec) void {
  constructors shray[te_vardecl] = map_vardecl_ipses(im, ipse_mappings, &inn->constructors);
  *out = {constructors, inn->success_case_ix};
}

func map_structspec_ipses(im *identmap, ipse_mappings *shray[sym], inn *structspec, out *structspec) void {
  fields shray[te_vardecl] = map_vardecl_ipses(im, ipse_mappings, &inn->fields);
  *out = {fields};
}

func help_structural_enumspec(ds *defscope, pack *te_instpack, ipse_mappings *shray[sym], et_out *enumspec) structural_rhs_result {
  rhs_info *deftype_inst_rhs_info;
  switch help_structural_rhs_info(ds, pack, &rhs_info) {
  case Error(pm):
    return Error(pm);
  case Success:
    switch rhs_info {
    case &RhsStructInfo(ri structspec):
      return NotAccessible;
    case &RhsEnumInfo(ri enumspec):
      map_enumspec_ipses(ds->im, ipse_mappings, &ri, et_out);
      return Success;
    }
  case NotAccessible:
    return NotAccessible;
  }
}

func help_structural_structspec(ds *defscope, pack *te_instpack, ipse_mappings *shray[sym], st_out *structspec) structural_rhs_result {
  rhs_info *deftype_inst_rhs_info;
  switch help_structural_rhs_info(ds, pack, &rhs_info) {
  case Error(pm):
    return Error(pm);
  case Success:
    switch rhs_info {
    case &RhsStructInfo(ri structspec):
      map_structspec_ipses(ds->im, ipse_mappings, &ri, st_out);
      return Success;
    case &RhsEnumInfo(ri enumspec):
      return NotAccessible;
    }
  case NotAccessible:
    return NotAccessible;
  }
}

func lookup_name_field(es *framescope, pack *te_instpack, ipse_mappings *shray[sym], fieldname *ast_ident,
                       fieldtype_out *cu_typeexpr, res_out *check_field_result) np {
  st structspec;
  switch help_structural_structspec(es->ds, pack, ipse_mappings, &st) {
  case Error(pm):
    return Unprinted(pm);
  case Success:
    return help_lookup_struct_field(es, &st, fieldname, fieldtype_out, res_out);
  case NotAccessible:
    return ERR(_u8("Looking up field on inaccessible defclass or primitive type"));
  }
}

func help_lookup_struct_field(es *framescope, st *structspec, fieldname *ast_ident,
                              fieldtype_out *cu_typeexpr, res_out *check_field_result) np {
  offset u32;
  index size;
  #lookup_field_from_list(es->clq, &es->tscope, &st->fields, fieldname->value, fieldtype_out, &offset, &index);
  *res_out = InheritsLval({offset, index});
  return NoFail;
}

func help_lookup_name_field(es *framescope, t *cu_typeexpr, fieldname *ast_ident,
                            fieldtype_out *cu_typeexpr, res_out *check_field_result) np {
  switch &t->x {
  case &TeName(a te_name):
    ipse_mappings shray[sym];  // empty
    return lookup_name_field(es, unHas(&a.pack), &ipse_mappings, fieldname, fieldtype_out, res_out);
  case &TeApp(a te_app):
    hp *te_app_pack = unHas(&a.pack);
    return lookup_name_field(es, &hp->teip, &hp->ipse_mappings, fieldname, fieldtype_out, res_out);
  case &TeUnion(a te_union):
    // The offset's what it would be for a struct.
    offset_discard u32;
    index size;
    #lookup_field_from_list(es->clq, &es->tscope, &a.fields, fieldname->value, fieldtype_out, &offset_discard, &index);
    // Offset's always 0 for a union.
    *res_out = InheritsLval({0, index});
    return NoFail;

  case &TeArraytype(a te_arraytype):
    if fieldname->value != es->im->cym.lengthsym {
      return ERR(_u8("field lookup (not .length) on array type"));
    }
    *fieldtype_out = compute_size(es->clq);
    if case Has(n u32) = a.count {
      *res_out = ConstantField(n);
    } else {
      ice(_u8("Complete arraytype has incomplete count"));
    }
    return NoFail;
  case &TeIpse(a te_ipse):
    return ERR(_u8("ICE: Looking up name field of... a ipse type?"));
  case &TeDotted(a te_dotted):
    return ERR(_u8("ICE: Looking up name field of... a dotted type?"));
  case &TeUnknown:
    ice(_u8("lookup_field sees incomplete type"));
    return fake();
  }
}

func lookup_field(es *framescope, t *cu_typeexpr, f *ast_fieldname,
                  fieldtype_out *cu_typeexpr, res_out *check_field_result) np {
  return help_lookup_name_field(es, t, &f->name, fieldtype_out, res_out);
}

func find_vardecl(a *shray[te_vardecl], name sym, out **te_typeexpr, index_out *size) bool {
  n size = count(a);
  for i size = 0; i < n; i = i + 1 {
    d *te_vardecl = ref(a, i);
    if d->name == name {
      *out = &d->type;
      *index_out = i;
      return true;
    }
  }
  return false;
}

// fields is supposed to be complete.
func lookup_field_from_list(clq *clqueue, scope *type_scope, fields *shray[te_vardecl], fieldname sym,
                            fieldtype_out *cu_typeexpr, offset_out *u32, index_out *size) np {
  psd partial_struct_data;
  #compute_partial_struct_data(clq, scope, fields, Has(fieldname), &psd);

  if !psd.found_field {
    return ERR(_u8("fieldname '"), lookup(clq->im, fieldname), _u8("' not found"));
  }

  *fieldtype_out = ~ ref(fields, psd_index(&psd))->type;
  *offset_out = psd.offset;
  *index_out = count(&psd.fields);
  return NoFail;
}

func check_expr_logical_conjunction(es *framescope, a *ast_logical_conjunction, pt *te_typeexpr, x *ast_expr) np {
  ty cu_typrop = compute_bool(es->clq);

  if !unifies(&ty.cu.x, pt) {
    return ERR(_u8("logical conjunction in bad place"));
  }
  #check_expr_consume(es, oo(&a->lhs), &ty.cu.x);
  #check_expr_consume(es, oo(&a->rhs), &ty.cu.x);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ty.cu, ty.props})), ty.cu, ty.props, {mk_empty_emittance()})));
  return NoFail;
}

func ai_incomplete(yes bool) allow_incomplete {
  if yes {
    return AllowIncompleteYes;
  } else {
    return AllowIncompleteNo;
  }
}

func check_expr_funcall(es *framescope, ai allow_incomplete, a *ast_funcall, pt *te_typeexpr, x *ast_expr) np {
  a_param_incomplete bool;
  #check_funcall_params_firsttime(es, &a->params, &a_param_incomplete);

  // This is so fruity, emissions should be redundant.  However, meh.
  emissions array[unify_emission];
  func_pt te_typeexpr;
  #make_fn_partial_type(es->clq, &es->tscope, pt, &a->params, &emissions, &func_pt);
  funec *ast_expr_consume = oo(&a->fun);
  #check_expr_ai(es, ai_incomplete(!a_param_incomplete && ai == AllowIncompleteYes), &funec->expr, &func_pt);

  if expr_type_incomplete(&funec->expr) {
    check(ai == AllowIncompleteYes);
    annotate_info(x, @[ast_expr_info]IncompleteCheck);
    return NoFail;
  }

  #check_funcall_params_secondtime(es, expr_complete_type(&funec->expr), &a->params);

  #annotate_disposal_for_consume(es, &funec->expr, &funec->after);

  return_type *te_typeexpr = fn_return_type(es->cs, &expr_complete_type(&oo(&a->fun)->expr)->x);
  props type_properties;
  #compute_complete_type_properties(es->clq, &es->tscope, return_type, &props);
  annotate_info(x, CompleteCheck(mk(wholeRval(add_cell(es, {LocationStatic, ~ *return_type, props})),
                                    ~ *return_type, props, {freeze(&emissions)})));
  return NoFail;
}

func check_funcall_params_firsttime(es *framescope, params *array[ast_expr_consume],
                                    a_param_incomplete_out *bool) np {
  n size = count(params);
  unknown te_typeexpr = TeUnknown;
  all_params_complete bool = true;
  for i size = 0; i < n; i = i + 1 {
    expr *ast_expr = &ref(params, i)->expr;
    #check_expr_ai(es, AllowIncompleteYes, expr, &unknown);
    complete bool = expr_type_complete(expr);
    all_params_complete = all_params_complete & complete;
  }
  *a_param_incomplete_out = !all_params_complete;
  return NoFail;
}

func check_funcall_params_secondtime(es *framescope, functype *cu_typeexpr, params *array[ast_expr_consume]) np {
  n size = count(params);

  type_params *shray[te_typeexpr];
  if !decompose_typeapp(&functype->x, primitive_function_puretype(es->cs), &type_params) {
    ice(_u8("Expecting a TeApp for fn-type."));
  }
  check(count(type_params) == n + 1);

  for i size = 0; i < n; i = i + 1 {
    ec *ast_expr_consume = ref(params, i);
    #check_expr_consume(es, ec, ref(type_params, i));
  }
  return NoFail;
}

// We have these helpful wrappers to limit usages of compute_prim, so that it's easier to feel comfortable about its use of global_scope.  Of course, some things like graph actually pass in their scope.
func compute_bool(clq *clqueue) cu_typeexpr { return compute_prim(clq, primitive_bool_type(clq->cs)); }
func compute_bool(clq *clqueue) cu_typrop { return compute_prim(clq, primitive_bool_type(clq->cs)); }

func compute_void(clq *clqueue) cu_typeexpr { return compute_prim(clq, primitive_void_type(clq->cs)); }
func compute_void(clq *clqueue) cu_typrop { return compute_prim(clq, primitive_void_type(clq->cs)); }

func compute_size(clq *clqueue) cu_typeexpr { return compute_prim(clq, primitive_size_type(clq->cs)); }

func compute_prim(clq *clqueue, t te_typeexpr) cu_typeexpr {
  global_scope type_scope = mk_global();
  emissions array[unify_emission];
  return compute_prim_with_scope(clq, &global_scope, t, &emissions);
}

func compute_prim_with_scope(clq *clqueue, scope *type_scope, t te_typeexpr, emissions_app *array[unify_emission]) cu_typeexpr {
  cac cac_typeexpr;
  if case Unprinted(pm) = nogeneric_check_and_compute_typeexpr(clq, scope, &t, emissions_app, &cac) {
    ice(_u8("compute_prim encounters uncomputable type: "), pm.msg);
  }
  check(cac.complete);
  return ~cac.te;
}

func compute_prim(clq *clqueue, t te_typeexpr) cu_typrop {
  ret cu_typrop;
  compute_prim(clq, t, &ret.cu, &ret.props);
  return ret;
}

func compute_prim(clq *clqueue, t te_typeexpr, out *cu_typeexpr, props_out *type_properties) void {
  global_scope type_scope = mk_global();
  emissions array[unify_emission];
  compute_prim_with_scope(clq, &global_scope, t, &emissions, out, props_out);
}

func compute_prim_with_scope(clq *clqueue, scope *type_scope, t te_typeexpr, emissions_app *array[unify_emission], out *cu_typeexpr, props_out *type_properties) void {
  type cu_typeexpr = compute_prim_with_scope(clq, scope, t, emissions_app);
  if case Unprinted(pm) = compute_type_properties(clq, scope, &type, props_out) {
    ice(_u8("compute_prim fails to compute type properties: "), pm.msg);
  }
  *out = type;
}

func check_expr_index(es *framescope, a *ast_index_expr, pt *te_typeexpr, x *ast_expr) np {
  unknown te_typeexpr = TeUnknown;
  #check_expr_ai(es, AllowIncompleteNo, oo(&a->lhs), &unknown);
  lhs_info *ast_expr_complete_info = expr_complete_info(oo(&a->lhs));

  result_type *te_typeexpr;
  key_type te_typeexpr;
  tech indexing_technique;
  #decompose_indexable(es->clq, &es->tscope, &lhs_info->cu.x, &result_type, &key_type, &tech);

  result_emissions array[unify_emission];
  unified te_typeexpr;
  if !unify_types(&es->tscope, pt, result_type, &result_emissions, &unified) {
    return ERR(_u8("index expr returns wrong type"));
  }

  result_props type_properties;
  #compute_complete_type_properties(es->clq, &es->tscope, result_type, &result_props);

  lval is_lval;
  switch tech.array {
  case None:
    rhs_later ast_later_discard_info = mk_later();
    #check_consume_then_discard_expr(es, oo(&a->rhs), &key_type, &rhs_later);

    if !tech.deref {
      // TODO: This is totally duplicating field access logic.
      switch &lhs_info->lval {
      case &IsLvalYes(desc lval_description):
        lval = IsLvalYes({add_cell(es, {LocationVirtual, ~ *result_type, result_props}),
                          DeadMe, field_ipse(es, desc.ipse, ~ *result_type)});
      case &IsLvalNo(desc rval_description):
        lval = IsLvalNo({desc.whole_num, add_cell(es, {LocationVirtual, ~ *result_type, result_props})});
      }
      // Nothing to dispose, it's a field access.
      annotate(&a->info, {None, ArrayIndexingInfo({rhs_later}), {freeze(&result_emissions)}});
    } else {
      // Dereferencing a pointer always makes an lvalue.
      lval = IsLvalYes({add_cell(es, {LocationVirtual, ~ *result_type, result_props}),
                        DeadMe, misc_ipse(es, ~ *result_type)});  // Yes, this misc_ipse is a field_ipse of some indexee object that was pointed at.
      ie_info_after nc[ast_expr_after_consume] = NotComputed;
      lhs_later ast_later_discard_info = mk_later();
      #annotate_disposal_for_consume_then_discard(es, oo(&a->lhs), &ie_info_after, &lhs_later);

      annotate(&a->info, {Has({*un(&ie_info_after), lhs_later}), ArrayIndexingInfo({rhs_later}), {freeze(&result_emissions)}});
    }

  case Has(fntech fn_indexing_technique):
    // What this becomes is:
    //   - If the lhs (possibly derefed) is an lvalue, we take its address, call ip,
    //     and deref the return value, which makes an lvalue.
    //   - If the lhs is an rvalue, we take its address, call ip, and copy the return
    //     value to a new whole rvalue.  But WHAT IF an rvalue's partial_num was allowed
    //     to not be a subcell of whole_num?  Then we could just update partial_num.
    //   - For now, if the lhs is an rvalue, we fail to compile.

    if !tech.deref {
      #check_expr_consume(es, oo(&a->rhs), &key_type);

      switch &lhs_info->lval {
      case &IsLvalYes(desc lval_description):
        lval = IsLvalYes({add_cell(es, {LocationVirtual, ~ *result_type, result_props}),
                          DeadMe, misc_ipse(es, ~ *result_type)});
      case &IsLvalNo(desc rval_description):
        return ERR(_u8("User-defined array indexing only works on lvalues"));
      }

      annotate(&a->info, {None, FnIndexingInfo({fntech.ip, {fntech.emissions}}), {freeze(&result_emissions)}});
    } else {
      #check_expr_consume(es, oo(&a->rhs), &key_type);

      lval = IsLvalYes({add_cell(es, {LocationVirtual, ~ *result_type, result_props}),
                        DeadMe, misc_ipse(es, ~ *result_type)});
      ie_info_after nc[ast_expr_after_consume] = NotComputed;
      lhs_later ast_later_discard_info = mk_later();
      #annotate_disposal_for_consume_then_discard(es, oo(&a->lhs), &ie_info_after, &lhs_later);

      annotate(&a->info, {Has({*un(&ie_info_after), lhs_later}), FnIndexingInfo({fntech.ip, {fntech.emissions}}), {freeze(&result_emissions)}});
    }
  }

  // We happen to emit our emissions... more specifically.  I'm not sure how you should feel about this.
  annotate_info(x, CompleteCheck(mk(lval, ~ *result_type, result_props, {mk_empty_emittance()})));
  return NoFail;
}

struct fn_indexing_technique {
  ip instpair;
  emissions shray[unify_emission];
}

struct indexing_technique {
  // None = raw array, Has(...) = fn indexing
  array opt[fn_indexing_technique];
  deref bool;
}

func decompose_indexable(clq *clqueue, scope *type_scope, typ *te_typeexpr,
                         result_type_out **te_typeexpr, key_type_out *te_typeexpr, tech_out *indexing_technique) np {
  // We specifically do _not_ support references here.  You can't index into a
  // reference... you'd need a slice type or something like that.
  indexable *te_typeexpr;
  deref bool;
  if decompose_typeapp(typ, primitive_pointer_puretype(clq->cs), &indexable) {
    deref = true;
  } else {
    indexable = typ;
    deref = false;
  }

  if decompose_arraytype(indexable, result_type_out) {
    *tech_out = {None, deref};
    *key_type_out = compute_size(clq).x;
    return NoFail;
  }

  fntype te_typeexpr = fn_type(clq->cs, ptr_type(clq->cs, *indexable), TeUnknown, TeUnknown);
  gp genparms = NoParms;
  res match_def_res;
  #match_def(clq->cs, clq->im->cym.do_indexsym, scope, &gp, &fntype, &res);
  switch &res {
  case &NoMatch:
    return ERR(_u8("indexing on non-indexable type"));
  case &MultiMatch:
    return ERR(_u8("indexing on type with multiple '"), lookup(clq->im, clq->im->cym.do_indexsym),
               _u8("' definitions"));
  case &OneMatch(m ent_and_parms):
    inst_id def_inst_id;
    #make_inst(clq, m.ent, scope, &m.parms, &inst_id);
    ty *def_inst_typeinfo;
    #ensure_def_inst_type_computed(clq->cs, clq, ref_def_entry(clq->cs, m.ent), inst_id, &ty);
    arr_ptr_type *te_typeexpr;
    key_type *te_typeexpr;
    result_ptr_type *te_typeexpr;
    if !decompose_typeapp(&ty->cu.x, primitive_function_puretype(clq->cs), &arr_ptr_type, &key_type,
                          &result_ptr_type) {
      // This failure can't happen because we constructed fntype to have 3 types.
      return ERR(_u8("ICE: decompose_indexable cannot decompose match_def type"));
    }
    result_type *te_typeexpr;
    if !decompose_typeapp(result_ptr_type, primitive_pointer_puretype(clq->cs), &result_type) {
      return ERR(_u8("indexing function '"), lookup(clq->im, clq->im->cym.do_indexsym),
                 _u8("' returns non-pointer type"));
    }
    *result_type_out = result_type;
    *key_type_out = *key_type;
    *tech_out = {Has({{m.ent, inst_id}, m.emissions}), deref};
    return NoFail;
  }
}

func decompose_arraytype(t *te_typeexpr, out **te_typeexpr) bool {
  if case &TeArraytype(a te_arraytype) = t {
    *out = oo(&a.param);
    return true;
  } else {
    return false;
  }
}

func expr_type(a *ast_expr) te_typeexpr {
  switch &a->info {
  case &NoInfo:
    ice(_u8("expr_type sees NoInfo"));
    return fake();
  case &IncompleteCheck:
    return TeUnknown;
  case &CompleteCheck(t ast_expr_complete_info):
    return t.cu.x;
  }
}

func expr_complete_info(a *ast_expr) *ast_expr_complete_info {
  if case &CompleteCheck(inf ast_expr_complete_info) = &a->info {
    return &inf;
  } else {
    ice(_u8("expr_complete_info sees... not a complete type"));
    return fake();
  }
}

func expr_complete_type(a *ast_expr) *cu_typeexpr {
  return &expr_complete_info(a)->cu;
}

func expr_type_complete(a *ast_expr) bool {
  switch &a->info {
  case &NoInfo:
    ice(_u8("expr_type_complete sees NoInfo"));
    return fake();
  case &IncompleteCheck:
    return false;
  case &CompleteCheck(t ast_expr_complete_info):
    return true;
  }
}


func expr_type_incomplete(a *ast_expr) bool {
  return !expr_type_complete(a);
}

func make_fn_partial_type(clq *clqueue, scope *type_scope, return_type *te_typeexpr, params *array[ast_expr_consume],
                          emissions_app *array[unify_emission], out *te_typeexpr) np {
  type_params array[te_typeexpr];
  n size = count(params);
  reserve(&type_params, n + 1);
  for i size = 0; i < n; i = i + 1 {
    push(&type_params, expr_type(&ref(params, i)->expr));
  }
  push(&type_params, *return_type);
  fntype te_typeexpr = TeApp({primitive_function_puretype(clq->cs), freeze(&type_params), None});
  cac cac_typeexpr;
  #nogeneric_check_and_compute_typeexpr(clq, scope, &fntype, emissions_app, &cac);
  *out = cac.te;
  return NoFail;
}

func fn_return_type(cs *checkstate, func_type *te_typeexpr) *te_typeexpr {
  params *shray[te_typeexpr];
  if !decompose_typeapp(func_type, primitive_function_puretype(cs), &params) {
    ice(_u8("Expected TeApp for fn-type in fn_return_type."));
  }
  n size = count(params);
  check(n > 0);
  return ref(params, n - 1);
}
