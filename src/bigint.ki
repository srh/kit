import array;

defclass copy bigint struct {
  negative bool;
  // We use a 2's complement representation.  (So -2 is represented by [0xFFFFFFFE], -1 is represented by [].)
  parts array[u32];
};

access bigint {
  func do_init(b *bigint) void {
    init(&b->negative);
    init(&b->parts);
  }

  func mk(negative bool, parts array[u32]) bigint {
    ret bigint;
    ret.negative = negative;
    ret.parts = parts;
    return ret;
  }

  func `~`(x u32) bigint {
    parts array[u32];
    if x != 0 {
      push(&parts, x);
    }
    return mk(false, parts);
  }

  func `~`(x i32) bigint {
    if x >= 0 {
      return ~(@[u32]~x);
    } else {
      y bigint = ~(@[u32]~((x + 0x40000000) + 0x40000000));
      z bigint = ~(@[u32]0x40000000);
      return (y - z) - z;
    }
  }

  func `+`(x bigint, y bigint) bigint {
    xn size = count(&x.parts);
    yn size = count(&y.parts);
    maxn size = max(xn, yn);
    build array[u32];
    reserve(&build, maxn + 1);
    carry u32 = 0;
    for i size = 0; i < maxn; i = i + 1 {
      xval u32 = getbigdigit(&x, i);
      yval u32 = getbigdigit(&y, i);
      oflow1 u32;
      sum u32;
      add_oflow(xval, yval, &sum, &oflow1);
      oflow2 u32;
      add_oflow(carry, sum, &sum, &oflow2);
      carry = oflow1 + oflow2;
      push(&build, sum);
    }
    if x.negative != y.negative {
      return squash(carry == 0, &build);
    } else if x.negative {
      // Both negative.
      if carry == 0 {
        push(&build, 0xFFFFFFFE);
      }
      return squash(true, &build);
    } else {
      // Both positive;
      if carry == 1 {
        push(&build, 1);
      }
      return squash(false, &build);
    }
  }

  func bigdigit_count(x *bigint) size {
    return count(&x->parts);
  }

  // 32 bits.  (This is a u32, not a size, because s1 can't statically eval sizes.)
  def bigdigit_bits u32 = 32;

  func getbigdigit(x *bigint, i size) u32 {
    if i < count(&x->parts) {
      return get(&x->parts, i);
    } else {
      if x->negative {
        return ^ @[u32] 0;
      } else {
        return 0;
      }
    }
  }

  func as_non_negative_u32(x *bigint, out *u32) bool {
    if x->negative {
      return false;
    }
    n size = count(&x->parts);
    if n == 0 {
      *out = 0;
      return true;
    } else if n == 1 {
      *out = get(&x->parts, 0);
      return true;
    } else {
      return false;
    }
  }

  func squash(negative bool, build *array[u32]) bigint {
    val u32;
    if negative {
      val = ^ @[u32] 0;
    } else {
      val = 0;
    }
    n size = count(build);
    while n > 0 {
      n = n - 1;
      if get(build, n) != val {
        return mk(negative, *build);
      }
      pop(build);
    }
    return mk(negative, *build);
  }

  func add_to_array(x *array[u32], ix size, val u32) void {
    n size = count(x);
    while ix < n && val != 0 {
      add_oflow(get(x, ix), val, ref(x, ix), &val);
      ix = ix + 1;
    }
  }

  func `*`(x bigint, y bigint) bigint {
    xn size = count(&x.parts);
    yn size = count(&y.parts);
    ressize size = xn + yn + 3;
    build array[u32] = repeat(ressize + 1, 0);
    carry u32 = 0;
    for i size = 0; i < ressize; i = i + 1 {
      for j size = 0; j < ressize - i; j = j + 1 {
        lo u32;
        hi u32;
        multiply_oflow(getbigdigit(&x, i), getbigdigit(&y, j), &lo, &hi);
        add_to_array(&build, i + j + 1, hi);
        add_to_array(&build, i + j, lo);
      }
    }
    signword u32 = get(&build, ressize - 2);
    if signword == 0 {
      pop(&build);
      return squash(false, &build);
    } else if signword == ^ @[u32] 0 {
      pop(&build);
      return squash(true, &build);
    } else {
      crash(_u8("bigint multiplication algorithm fail"));
      return fake();
    }
  }

  func abs(x bigint) bigint {
    if is_negative(&x) {
      return -x;
    } else {
      return x;
    }
  }

  func divmod(x bigint, y bigint) tup[bigint, bigint] {
    if y == ~ @[u32] 0 {
      crash(_u8("bigint divmod divide by zero"));
    }
    lo bigint = -abs(x);
    hi bigint = incr(abs(x));
    while hi > incr(lo) {
      m bigint = (lo + hi) >> 1;
      if y * m <= x {
        lo = m;
      } else {
        hi = m;
      }
    }
    return {lo, x - y * lo};
  }

  func `/`(x bigint, y bigint) bigint {
    return divmod(x, y).car;
  }

  func `%`(x bigint, y bigint) bigint {
    return divmod(x, y).cdr;
  }

  func add_oflow(x u32, y u32, sum_out *u32, carry_out *u32) void {
    xl u32 = (x & 0xFFFF);
    xh u32 = (x >> 16);
    yl u32 = (y & 0xFFFF);
    yh u32 = (y >> 16);
    q0 u32 = xl + yl;
    q1 u32 = xh + yh + (q0 >> 16);
    *sum_out = (((q1 & 0xFFFF) << 16) | (q0 & 0xFFFF));
    *carry_out = (q1 >> 16);
  }

  func multiply_oflow(x u32, y u32, lo_out *u32, hi_out *u32) void {
    xl u32 = (x & 0xFFFF);
    xh u32 = (x >> 16);
    yl u32 = (y & 0xFFFF);
    yh u32 = (y >> 16);
    p00 u32 = xl * yl;
    p01 u32 = xl * yh;
    p10 u32 = xh * yl;
    p11 u32 = xh * yh;

    q0 u32 = (p00 & 0xFFFF);
    q1 u32 = (p00 >> 16) + (p01 & 0xFFFF) + (p10 & 0xFFFF);
    q2 u32 = (p01 >> 16) + (p10 >> 16) + (p11 & 0xFFFF);
    q3 u32 = (p11 >> 16);

    q2 = q2 + (q1 >> 16);
    q3 = q3 + (q2 >> 16);

    *lo_out = (((q1 & 0xFFFF) << 16) | q0);
    *hi_out = (((q3 & 0xFFFF) << 16) | (q2 & 0xFFFF));
  }

  func `^`(x bigint) bigint {
    n size = count(&x.parts);
    for i size = 0; i < n; i = i + 1 {
      p *u32 = ref(&x.parts, i);
      *p = ^ *p;
    }
    x.negative = !x.negative;
    return x;
  }

  func incr(x bigint) bigint {
    carry u32 = 1;
    n size = count(&x.parts);
    for i size = 0; carry != 0 && i < n; i = i + 1 {
      p *u32 = ref(&x.parts, i);
      add_oflow(carry, *p, p, &carry);
    }
    if x.negative {
      return squash(carry == 0, &x.parts);
    } else {
      if carry != 0 {
        push(&x.parts, carry);
      }
      return x;
    }
  }

  func `-`(x bigint) bigint {
    y bigint = ^x;
    return incr(y);
  }

  func `-`(x bigint, y bigint) bigint {
    return x + - y;
  }

  func `>>`(x bigint, y u32) bigint {
    i size = ~(y / 32);
    yr u32 = y % 32;
    newparts array[u32];
    if yr == 0 {
      // We handle the yr == 0 case to avoid a shift-by-32.
      newparts = subarray(&x.parts, i);
    } else {
      ys u32 = 32 - yr;
      mask u32 = (@[u32] 1 << yr) - 1;
      nparts size = count(&x.parts);
      for ; i < nparts; i = i + 1 {
        valo u32 = get(&x.parts, i) >> yr;
        vahi u32 = (getbigdigit(&x, i + 1) & mask) << ys;
        push(&newparts, valo | vahi);
      }
    }
    return squash(x.negative, &newparts);
  }

  func `<<`(x bigint, y u32) bigint {
    wholewords size = ~(y / 32);
    yr u32 = y % 32;
    newparts array[u32];
    newparts = repeat(wholewords, @[u32] 0);
    if yr == 0 {
      // We handle the yr == 0 case to avoid a shift-by-32.
      append(&newparts, &x.parts);
    } else {
      ys u32 = 32 - yr;
      nparts size = count(&x.parts);
      for i size = 0; i < nparts + 1; i = i + 1 {
        valo u32;
        if i == 0 {
          valo = 0;
        } else {
          valo = get(&x.parts, i - 1) >> ys;
        }
        vahi u32 = getbigdigit(&x, i) << yr;
        push(&newparts, valo | vahi);
      }
    }
    return squash(x.negative, &newparts);
  }

  func `&`(x bigint, y bigint) bigint {
    n size = max(bigdigit_count(&x), bigdigit_count(&y));
    parts array[u32];
    for i size = 0; i < n; i = i + 1 {
      a u32 = getbigdigit(&x, i);
      b u32 = getbigdigit(&y, i);
      push(&parts, a & b);
    }
    return squash(x.negative && y.negative, &parts);
  }

  func `|`(x bigint, y bigint) bigint {
    n size = max(bigdigit_count(&x), bigdigit_count(&y));
    parts array[u32];
    for i size = 0; i < n; i = i + 1 {
      a u32 = getbigdigit(&x, i);
      b u32 = getbigdigit(&y, i);
      push(&parts, a | b);
    }
    return squash(x.negative || y.negative, &parts);
  }

  func `^`(x bigint, y bigint) bigint {
    n size = max(bigdigit_count(&x), bigdigit_count(&y));
    parts array[u32];
    for i size = 0; i < n; i = i + 1 {
      a u32 = getbigdigit(&x, i);
      b u32 = getbigdigit(&y, i);
      push(&parts, a ^ b);
    }
    return squash(x.negative != y.negative, &parts);
  }

  func `==`(x bigint, y bigint) bool {
    return x.negative == y.negative && array_equal(&x.parts, &y.parts);
  }
  func `!=`(x bigint, y bigint) bool {
    return !(x == y);
  }

  func backwards_lexicographic_less(x *u32, y *u32, n size) bool {
    while n > 0 {
      n = n - 1;
      if x[n] < y[n] {
        return true;
      } else if x[n] > y[n] {
        return false;
      }
    }
    return false;
  }

  func is_negative(x *bigint) bool {
    return x->negative;
  }

  func `<`(x bigint, y bigint) bool {
    if x.negative {
      if y.negative {
        xn size = count(&x.parts);
        yn size = count(&y.parts);
        if xn == yn {
          return backwards_lexicographic_less(data(&x.parts), data(&y.parts), xn);
        } else if xn < yn {
          return false;
        } else {
          return true;
        }
      } else {
        return true;
      }
    } else {
      if y.negative {
        return false;
      } else {
        xn size = count(&x.parts);
        yn size = count(&y.parts);
        if xn == yn {
          return backwards_lexicographic_less(data(&x.parts), data(&y.parts), xn);
        } else if xn < yn {
          return true;
        } else {
          return false;
        }
      }
    }
  }
  func `<=`(x bigint, y bigint) bool {
    return !(y < x);
  }
  func `>`(x bigint, y bigint) bool {
    return y < x;
  }
  func `>=`(x bigint, y bigint) bool {
    return !(x < y);
  }
}

func `~`(x i8) bigint {
  if x < 0 {
    x32 i32 = ~x;
    xu32 u32 = ~ (-x32);
    positive bigint = ~xu32;
    return -positive;
  } else {
    return ~ @[u32] ~x;
  }
}

func convert_to_bigint(base u32, digits *array[i8]) bigint {
  acc bigint;
  bigbase bigint = ~base;
  n size = count(digits);
  for i size = 0; i < n; i = i + 1 {
    x i8 = get(digits, i);
    check(x >= 0 && @[u32]~x < base);
    acc = acc * bigbase + ~x;
  }
  return acc;
}

func bigu(x u32) bigint { return ~x; }

func[T] big(arr T) bigint {
  b array[i8];
  reserve(&b, arr.length);
  for i size = 0; i < arr.length; i = i + 1 {
    val i8 = ~(@[u8] arr[i] - '0');
    check(val < 10);
    push(&b, val);
  }
  return convert_to_bigint(10, &b);
}

func test_bigint() bool {
  pass bool = true;
  fourg bigint = @[bigint]~ @[u32]2 * ~ @[u32]0x80000000;
  pass = pass & (big("1") + big("2") == big("3"));
  pass = pass & (big("20") + big("30") == big("50"));
  pass = pass & (big("2000000000") + big("3000000000") == big("5000000000"));
  pass = pass & (big("2000000000") - big("3000000000") == - big("1000000000"));
  pass = pass & ((-big("10000000000")) * (-big("17")) == big("170000000000"));
  pass = pass & ((big("129") >> 2) == (big("32")));
  pass = pass & (((fourg * big("129")) >> 34) == (big("32")));
  pass = pass & (((-big("9")) >> 2) == (-big("3")));
  pass = pass & (((-(fourg * big("9"))) >> 34) == (-big("3")));
  pass = pass & (((big("9")) << 2) == (big("36")));
  pass = pass & (((big("9")) << 34) == (fourg * big("36")));
  pass = pass & (incr(fourg - big("1")) == fourg);
  pass = pass & (incr(fourg) == (fourg + big("1")));
  pass = pass & (incr(big("1")) == big("2"));
  pass = pass & (incr(big("0")) == big("1"));
  pass = pass & (incr(-big("1")) == big("0"));
  pass = pass & (incr(-big("2")) == -big("1"));
  pass = pass & (incr(-big("18")) == -big("17"));
  pass = pass & (incr(-big("19")) == -big("18"));
  pass = pass & (incr(-fourg) == -(fourg - big("1")));
  pass = pass & (incr(-(fourg + big("1"))) == -fourg);
  pass = pass & (divmod(big("17"), big("3")) == cons(big("5"), big("2")));
  pass = pass & (divmod(-big("17"), big("3")) == cons(-big("6"), big("1")));
  pass = pass & (((-big("3")) & big("3")) == big("1"));
  pass = pass & (((-big("3")) | big("2")) == -big("1"));
  pass = pass & (((-big("3")) ^ big("3")) == -big("2"));
  pass = pass & (^big("3") == -big("4"));
  return pass;
}
