import check;

deftype frame_graph struct {
  cells array[cell_info];
  ops array[gr_node];
};

func init_frame_graph_from_cells(cells array[cell_info]) frame_graph {
  return {cells, mk_array@[gr_node]()};
}

func init_frame_graph_empty() frame_graph {
  return {mk_array@[cell_info](), mk_array@[gr_node]()};
}

func add_cell(gr *frame_graph, info cell_info) cell_num {
  num cell_num = ~count(&gr->cells);
  push(&gr->cells, info);
  return num;
}

deftype gr_num size;

func add_node(gr *frame_graph, node gr_node) gr_num {
  ret gr_num;
  ret.~ = count(&gr->ops);
  push(&gr->ops, node);
  return ret;
}

func mut_nop_node(gr *frame_graph, ix gr_num, newnode gr_node) void {
  node *gr_node = ref(&gr->ops, ix.~);
  if case &GrNop(v void) = &node->op {
    *node = newnode;
  } else {
    ice(_u8("mut_nop_node sees non-nop node"));
  }
}

func ref_cell(gr *frame_graph, c cell_num) *cell_info {
  return ref(&gr->cells, c.~);
}

func ref_node(gr *frame_graph, gn gr_num) *gr_node {
  return ref(&gr->ops, gn.~);
}

// To "evaluate" an op, first we evaluate its precs (in unspecified order), then we ealuate the op.
deftype gr_node struct {
  precs array[gr_num];
  op gr_op;
};

func node(precs array[gr_num], op gr_op) gr_node {
  return {precs, op};
}

func node0(op gr_op) gr_node {
  return node(mk_array(), op);
}

defenum gr_op {
  GrApply gr_apply;
  GrMemCopy gr_memcopy;
  GrWriteConst gr_writeconst;
  GrAddressof gr_addressof;
  GrDeref gr_deref;
  GrSubcell gr_subcell;
  GrBranch gr_branch;
  GrSequence gr_sequence;
  GrJmp gr_jmp;
  GrWriteNothing gr_writenothing;
  GrDead gr_dead;
  GrNop void;
};

deftype gr_apply struct {
  funcell cell_num;
  params array[cell_num];
  retcell cell_num;
};

deftype gr_memcopy struct {
  dest cell_num;
  src cell_num;
};

deftype gr_addressof struct {
  dest cell_num;
  addressee cell_num;
};

deftype gr_deref struct {
  name cell_num;
  pointer cell_num;
  offset gr_offset;
};

deftype gr_subcell struct {
  name cell_num;
  partof cell_num;
  offset gr_offset;
};

defenum gr_offset {
  OffsetConst u32;
  OffsetComputed tup[u32, cell_num];
};

deftype gr_writeconst struct {
  dest cell_num;
  value gr_const;
};

deftype gr_branch struct {
  src cell_num;
  cases array[tup[gr_const, gr_num]];
  default_case opt[gr_num];
};

deftype gr_sequence struct {
  first gr_num;
  second gr_num;
};

deftype gr_jmp struct {
  next gr_num;
};

deftype gr_writenothing struct {
  dest cell_num;
};

deftype gr_dead struct {
  cell cell_num;
};

defenum gr_const {
  ConstInt bigint;
  ConstDef instpair;
  ConstFnBody fn_body_id;
  ConstBytes array[u8];
};

deftype fullbody_state struct {
  // all_vars and labels is from the ast_fullbody_info.
  // We use the cell field, to know the name of the var's cell.
  all_vars array[var_info];

  final_node gr_num;
  // count(&label_gn) == count(&info->labels), they start off as nop nodes until we see the label.
  label_gn array[gr_num];
  // Cells that are used as return cells.
  return_cells array[cell_num];
};

func gr_fullbody(cs *checkstate, gr *frame_graph, x *ast_fullbody, out *gr_num, return_cell_out *cell_num) bool {
  var final_node = add_node(gr, node0(@[gr_op]GrNop(void)));

  info *ast_fullbody_info = unHas(&x->info);
  exit_node gr_num;
  if !gr_unwind_vars(cs, gr, &info->parameter_destructions, final_node, &exit_node) {
    return false;
  }

  label_gn array[gr_num];
  n size = count(&info->labels);
  for i size = 0; i < n; i = i + 1 {
    ngn gr_num = add_node(gr, node0(@[gr_op]GrNop(void)));
    push(&label_gn, ngn);
  }

  fb fullbody_state = {info->all_vars, final_node, label_gn, mk_array@[cell_num]()};

  body_gn gr_num;
  if !gr_bracebody(cs, gr, &fb, &x->bb, exit_node, &body_gn) {
    return false;
  }

  // This assumes it's okay to have a subcell op produce the identical type -- it's the only place we do that.
  // TODO: This and strinit are the places where a subcell is "rigid."
  return_subcell_ops array[gr_num];
  nreturncells size = count(&fb.return_cells);
  for i size = 0; i < nreturncells; i = i + 1 {
    var subn = add_node(gr, node0(@[gr_op]GrSubcell({get(&fb.return_cells, i), info->return_cell, OffsetConst(0)})));
    push(&return_subcell_ops, subn);
  }

  nopdep gr_num = add_node(gr, node(return_subcell_ops, GrNop(void)));
  seqop gr_num = add_node(gr, node0(@[gr_op]GrSequence({nopdep, body_gn})));

  *out = seqop;
  *return_cell_out = info->return_cell;
  return true;
}

func gr_bracebody(cs *checkstate, gr *frame_graph, fb *fullbody_state, x *ast_bracebody, outflow gr_num, out *gr_num) bool {
  bn gr_num;
  if !gr_unwind_vars(cs, gr, &unHas(&x->info)->destructions, outflow, &bn) {
    return false;
  }
  n size = count(&x->statements);
  for i size = n; i > 0; {
    i = i - 1;
    gn gr_num;
    if !gr_statement(cs, gr, fb, ref(&x->statements, i), bn, &gn) {
      return false;
    }
    bn = gn;
  }
  *out = bn;
  return true;
}

func gr_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, x *ast_statement, outflow gr_num, out *gr_num) bool {
  switch x {
    case &Expr(a ast_expr_discard): {
      gn gr_num;
      if !gr_expr_discard(cs, gr, &a, &gn) {
        return false;
      }
      *out = add_node(gr, node0(@[gr_op]GrSequence({gn, outflow})));
      return true;
    }
    case &Return(a ast_return_statement): {
      if !gr_return_statement(cs, gr, fb, &a, out) {
        return false;
      }
      return true;
    }
    case &Var(a ast_var_statement): {
      gn gr_num;
      if !gr_var_statement(cs, gr, fb, &a, &gn) {
        return false;
      }
      *out = add_node(gr, node0(@[gr_op]GrSequence({gn, outflow})));
      return true;
    }

    case &IfThen(a ast_ifthen_statement): {
      if !gr_ifthen_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &IfThenElse(a ast_ifthenelse_statement): {
      if !gr_ifthenelse_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &While(a ast_while_statement): {
      if !gr_while_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }

    case &For(a ast_for_statement): {
      if !gr_for_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &Switch(a ast_switch_statement): {
      if !gr_switch_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &Label(a ast_label_statement): {
      if !gr_label_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
    case &Goto(a ast_goto_statement): {
      if !gr_goto_statement(cs, gr, fb, &a, outflow, out) {
        return false;
      }
      return true;
    }
  }
}

func gr_goto_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_goto_statement, outflow gr_num, out *gr_num) bool {
  info *ast_goto_statement_info = unHas(&a->info);
  jmp gr_num = get(&fb->label_gn, info->label_number.~);
  wn gr_num;
  if !gr_wind_vars(cs, gr, &info->initializations, jmp, &wn) {
    return false;
  }
  un gr_num;
  if !gr_unwind_vars(cs, gr, &info->destructions, wn, &un) {
    return false;
  }
  *out = un;
  return true;
}

func gr_label_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_label_statement, outflow gr_num, out *gr_num) bool {
  gn gr_num = get(&fb->label_gn, unHas(&a->info)->label_number.~);
  mut_nop_node(gr, gn, node0(@[gr_op]GrJmp({outflow})));
  // Should we set *out to gn or outflow?  When labels get fancier, the answer will matter.
  *out = gn;
  return true;
}

func gr_switch_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_switch_statement, outflow gr_num, out *gr_num) bool {
  swartch_discard_gn gr_num;
  if !gr_later_discard(cs, gr, &a->swartch_discard, &swartch_discard_gn) {
    return false;
  }

  param_discard *te_typeexpr;
  is_ptr bool = decompose_typeapp(&expr_complete_type(&oo(&a->swartch)->expr)->~, primitive_pointer_puretype(cs), &param_discard);

  var exitseq = add_node(gr, node0(@[gr_op]GrSequence({swartch_discard_gn, outflow})));

  info *ast_enum_deconstruction_info = unHas(&a->info);
  cases array[tup[gr_const, gr_num]];
  default_case opt[gr_num] = None();
  ncases size = count(&a->cases);
  for i size = 0; i < ncases; i = i + 1 {
    sc *ast_switch_case = ref(&a->cases, i);
    body_gn gr_num;
    if !gr_bracebody(cs, gr, fb, &sc->body, exitseq, &body_gn) {
      return false;
    }

    switch &sc->pattern {
      case &Case(cp ast_constructor_pattern): {
        cp_info *ast_cp_info = unHas(&cp.cp_info);
        vi *var_info = ref(&fb->all_vars, cp_info->vn.~);
        vcgn gr_num;
        if is_ptr {
          vcgn = add_node(gr, node0(@[gr_op]GrDeref({vi->cell, result_cell(oo(&a->swartch)), OffsetConst(cp_info->field_offset)})));
        } else {
          vcgn = add_node(gr, node0(@[gr_op]GrSubcell({vi->cell, result_cell(oo(&a->swartch)), OffsetConst(cp_info->field_offset)})));
        }
        var gn = add_node(gr, node0(@[gr_op]GrSequence({vcgn, body_gn})));
        push(&cases, cons(@[gr_const]ConstInt(~cp_info->tag_value.~), gn));
      }
      case &Default(v void): {
        set(&default_case, body_gn);
      }
    }
  }

  swartch_gn gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->swartch), &swartch_gn) {
    return false;
  }

  taggn gr_num;
  if is_ptr {
    taggn = add_node(gr, node(mk_array(swartch_gn), @[gr_op]GrDeref({info->tag_cell, result_cell(oo(&a->swartch)), OffsetConst(enum_tag_offset)})));
  } else {
    taggn = add_node(gr, node(mk_array(swartch_gn), @[gr_op]GrSubcell({info->tag_cell, result_cell(oo(&a->swartch)), OffsetConst(enum_tag_offset)})));
  }

  var br = add_node(gr, node(mk_array(taggn), @[gr_op]GrBranch({info->tag_cell, cases, default_case})));

  *out = br;
  return true;
}

func gr_for_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_for_statement, outflow gr_num, out *gr_num) bool {
  var topgn = add_node(gr, node0(@[gr_op]GrNop(void)));

  loopcleanupgn gr_num;
  if case &Has(cond ast_for_condition) = &a->condition {
    if !gr_later_discard(cs, gr, &cond.discard, &loopcleanupgn) {
      return false;
    }
  } else {
    loopcleanupgn = add_node(gr, node0(@[gr_op]GrNop(void)));
  }

  continuegn gr_num;
  if case &Has(increment box[ast_expr_discard]) = &a->increment {
    incrgn gr_num;
    if !gr_expr_discard(cs, gr, oo(&increment), &incrgn) {
      return false;
    }
    var totopgn = add_node(gr, node0(@[gr_op]GrSequence({incrgn, topgn})));
    continuegn = add_node(gr, node0(@[gr_op]GrSequence({loopcleanupgn, totopgn})));
  } else {
    continuegn = add_node(gr, node0(@[gr_op]GrSequence({loopcleanupgn, topgn})));
  }

  thengn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->body, continuegn, &thengn) {
    return false;
  }

  gn gr_num;
  if case &Has(cond ast_for_condition) = &a->condition {
    loopexitgn gr_num;
    if !gr_later_discard(cs, gr, &cond.discard, &loopexitgn) {
      return false;
    }

    initseq gr_num;
    if !gr_unwind_vars(cs, gr, &unHas(&a->info)->initter_destructions, outflow, &initseq) {
      return false;
    }

    var exitseq = add_node(gr, node0(@[gr_op]GrSequence({loopexitgn, initseq})));

    if !gr_expr_condition(cs, gr, fb, oo(&cond.expr), thengn, exitseq, &gn) {
      return false;
    }
  } else {
    gn = thengn;
  }

  mut_nop_node(gr, topgn, node0(@[gr_op]GrJmp({gn})));

  fingn gr_num;
  if case &Has(bi box[ast_statement]) = &a->initializer {
    if !gr_statement(cs, gr, fb, oo(&bi), topgn, &fingn) {
      return false;
    }
  } else {
    fingn = topgn;
  }
  *out = fingn;
  return true;
}

func gr_while_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_while_statement, outflow gr_num, out *gr_num) bool {
  var topgn = add_node(gr, node0(@[gr_op]GrNop(void)));

  loopcleanupgn gr_num;
  if !gr_later_discard(cs, gr, &a->condition_discard, &loopcleanupgn) {
    return false;
  }

  loopexitgn gr_num;
  if !gr_later_discard(cs, gr, &a->condition_discard, &loopexitgn) {
    return false;
  }

  var exitseq = add_node(gr, node0(@[gr_op]GrSequence({loopexitgn, outflow})));

  var continuegn = add_node(gr, node0(@[gr_op]GrSequence({loopcleanupgn, topgn})));
  thengn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->body, continuegn, &thengn) {
    return false;
  }
  gn gr_num;
  if !gr_condition(cs, gr, fb, &a->condition, thengn, exitseq, &gn) {
    return false;
  }

  mut_nop_node(gr, topgn, node0(@[gr_op]GrJmp({gn})));
  *out = topgn;
  return true;
}

func gr_ifthenelse_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_ifthenelse_statement, outflow gr_num, out *gr_num) bool {
  latergn gr_num;
  if !gr_later_discard(cs, gr, &a->condition_discard, &latergn) {
    return false;
  }

  var latseq = add_node(gr, node0(@[gr_op]GrSequence({latergn, outflow})));

  thengn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->thenbody, latseq, &thengn) {
    return false;
  }
  elsegn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->elsebody, latseq, &elsegn) {
    return false;
  }
  gn gr_num;
  if !gr_condition(cs, gr, fb, &a->condition, thengn, elsegn, &gn) {
    return false;
  }
  *out = gn;
  return true;
}

func gr_ifthen_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_ifthen_statement, outflow gr_num, out *gr_num) bool {
  latergn gr_num;
  if !gr_later_discard(cs, gr, &a->condition_discard, &latergn) {
    return false;
  }

  var latseq = add_node(gr, node0(@[gr_op]GrSequence({latergn, outflow})));

  bodygn gr_num;
  if !gr_bracebody(cs, gr, fb, &a->body, latseq, &bodygn) {
    return false;
  }
  gn gr_num;
  if !gr_condition(cs, gr, fb, &a->condition, bodygn, latseq, &gn) {
    return false;
  }
  *out = gn;
  return true;
}

func gr_expr_condition(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_expr_consume, thengn gr_num, elsegn gr_num, out *gr_num) bool {
  congn gr_num;
  if !gr_expr_consume(cs, gr, a, &congn) {
    return false;
  }
  cases array[tup[gr_const, gr_num]] = mk_array(cons(@[gr_const]ConstInt(~ @[u32] 0), elsegn), cons(@[gr_const]ConstInt(~ @[u32] 1), thengn));
  var br = add_node(gr, node(mk_array(congn), @[gr_op]GrBranch({result_cell(a), cases, None()})));

  *out = br;
  return true;
}

func gr_condition(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_condition, thengn gr_num, elsegn gr_num, out *gr_num) bool {
  switch a {
    case &ExprCondition(bec box[ast_expr_consume]): {
      return gr_expr_condition(cs, gr, fb, oo(&bec), thengn, elsegn, out);
    }

    case &PatternCondition(pa ast_pattern_assign): {
      rhs gr_num;
      if !gr_expr_consume(cs, gr, oo(&pa.rhs), &rhs) {
        return false;
      }

      info *ast_pattern_assign_info = unHas(&pa.info);
      // TODO: Avoid the duplicate checks for addressof_constructor, only do one GrDeref.
      taggn gr_num;
      if isHas(&pa.pattern.addressof_constructor) {
        taggn = add_node(gr, node(mk_array(rhs), @[gr_op]GrDeref({info->deconstruct.tag_cell, result_cell(oo(&pa.rhs)), OffsetConst(enum_tag_offset)})));
      } else {
        taggn = add_node(gr, node(mk_array(rhs), @[gr_op]GrSubcell({info->deconstruct.tag_cell, result_cell(oo(&pa.rhs)), OffsetConst(enum_tag_offset)})));
      }
      cases array[tup[gr_const, gr_num]];
      n size = info->deconstruct.num_enum_constructors;
      for i size = 0; i < n; i = i + 1 {
        tag enum_tag_value = mk_enum_tag_value(i);
        if info->matching_tag_value.~ == tag.~ {
          cp_info *ast_cp_info = unHas(&pa.pattern.cp_info);
          vi *var_info = ref(&fb->all_vars, cp_info->vn.~);
          vcgn gr_num;
          if isHas(&pa.pattern.addressof_constructor) {
            vcgn = add_node(gr, node0(@[gr_op]GrDeref({vi->cell, result_cell(oo(&pa.rhs)), OffsetConst(cp_info->field_offset)})));
          } else {
            vcgn = add_node(gr, node0(@[gr_op]GrSubcell({vi->cell, result_cell(oo(&pa.rhs)), OffsetConst(cp_info->field_offset)})));
          }
          var gn = add_node(gr, node0(@[gr_op]GrSequence({vcgn, thengn})));
          push(&cases, cons(@[gr_const]ConstInt(~tag.~), gn));
        } else {
          push(&cases, cons(@[gr_const]ConstInt(~tag.~), elsegn));
        }
      }
      var br = add_node(gr, node(mk_array(taggn), @[gr_op]GrBranch({info->deconstruct.tag_cell, cases, None()})));

      *out = br;
      return true;
    }
  }
}

func gr_var_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_var_statement, out *gr_num) bool {
  switch &a->rhs {
    case &HasExpr(be box[ast_expr_consume]): {
      return gr_expr_consume(cs, gr, oo(&be), out);
    }
    case &AutoInit(x opt[init_action]): {
      if case &Has(ia init_action) = &x {
        return gr_init_action(cs, gr, &ia, out);
      } else {
        ice(_u8("AutoInit action not annotated"));
        return fake();
      }
    }
  }
}

func gr_return_statement(cs *checkstate, gr *frame_graph, fb *fullbody_state, a *ast_return_statement, out *gr_num) bool {
  gn gr_num;
  if case &Has(b box[ast_expr_consume]) = &a->expr {
    if !gr_expr_consume(cs, gr, oo(&b), &gn) {
      return false;
    }
    push(&fb->return_cells, result_cell(oo(&b)));
  } else {
    gn = add_node(gr, node0(@[gr_op]GrNop(void)));
  }
  info *ast_return_statement_info = unHas(&a->info);
  uw gr_num;
  if !gr_unwind_vars(cs, gr, &info->destructions, fb->final_node, &uw) {
    return false;
  }
  var sn = add_node(gr, node0(@[gr_op]GrSequence({gn, uw})));
  *out = sn;
  return true;
}

// "initializations" is in variable declaration order -- the _same_ order as evaluation.
func gr_wind_vars(cs *checkstate, gr *frame_graph, initializations *array[init_action], outflow gr_num, out *gr_num) bool {
  bn gr_num = outflow;
  n size = count(initializations);
  for i size = n; i > 0; {
    i = i - 1;
    gn gr_num;
    if !gr_init_action(cs, gr, ref(initializations, i), &gn) {
      return false;
    }
    bn = add_node(gr, node0(@[gr_op]GrSequence({gn, bn})));
  }
  *out = bn;
  return true;
}

// "destructions" is in variable declaration order -- the _opposite_ order of evaluation.
func gr_unwind_vars(cs *checkstate, gr *frame_graph, destructions *array[destroy_action], outflow gr_num, out *gr_num) bool {
  bn gr_num = outflow;
  n size = count(destructions);
  for i size = 0; i < n; i = i + 1 {
    gn gr_num;
    if !gr_destroy_action(cs, gr, ref(destructions, i), DeadAfterDestroyYes(void), &gn) {
      return false;
    }
    bn = add_node(gr, node0(@[gr_op]GrSequence({gn, bn})));
  }
  *out = bn;
  return true;
}

func gr_expr_discard(cs *checkstate, gr *frame_graph, x *ast_expr_discard, out *gr_num) bool {
  if case &Has(aft ast_expr_after) = &x->after {
    dp gr_num;
    if !gr_expr(cs, gr, &x->expr, &dp) {
      return false;
    }
    after_gn gr_num;
    if !gr_after_actions(cs, gr, dp, &aft.actions, &after_gn) {
      return false;
    }
    *out = after_gn;
    return true;
  } else {
    ice(_u8("gr_expr_discard missing annotation"));
    return fake();
  }
}

func gr_expr_consume(cs *checkstate, gr *frame_graph, x *ast_expr_consume, out *gr_num) bool {
  if case &Has(aft ast_expr_after) = &x->after {
    return gr_expr_and_consume(cs, gr, &x->expr, &aft, out);
  } else {
    ice(_u8("gr_expr_consume missing after"));
    return fake();
  }
}

func gr_expr_and_consume(cs *checkstate, gr *frame_graph, x *ast_expr, aft *ast_expr_after, out *gr_num) bool {
  expr_gn gr_num;
  if !gr_expr(cs, gr, x, &expr_gn) {
    return false;
  }
  after_gn gr_num;
  if !gr_after_actions(cs, gr, expr_gn, &aft->actions, &after_gn) {
    return false;
  }
  *out = after_gn;
  return true;
}

func gr_expr(cs *checkstate, gr *frame_graph, x *ast_expr, out *gr_num) bool {
  switch &x->u {
    case &NameExpr(a ast_name_expr): {
      return gr_name_expr(cs, gr, x, &a, out);
    }
    case &ParenExpr(a ast_paren_expr): {
      return gr_expr(cs, gr, oo(&a.expr), out);
    }
    case &NumericLiteral(a ast_numeric_literal): {
      return gr_literal(cs, gr, x, numeric_literal_value(&a), out);
    }
    case &BoolLiteral(a ast_bool_literal): {
      value bigint;
      if a.value {
        value = ~ @[u32] 1;
      } else {
        value = ~ @[u32] 0;
      }
      return gr_literal(cs, gr, x, value, out);
    }
    case &VoidLiteral(a ast_void_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(cs, gr, x, value, out);
    }
    case &NullLiteral(a ast_null_literal): {
      value bigint = ~ @[u32] 0;
      return gr_literal(cs, gr, x, value, out);
    }
    case &CharLiteral(a ast_char_literal): {
      value bigint = ~ a.charspec.value;
      return gr_literal(cs, gr, x, value, out);
    }

    case &StringLiteral(a ast_string_literal): {
      return gr_string_literal(cs, gr, x, &a, out);
    }
    case &Funcall(a ast_funcall): {
      return gr_funcall(cs, gr, x, &a, out);
    }
    case &LogicalConjunction(a ast_logical_conjunction): {
      return gr_logical_conjunction(cs, gr, x, &a, out);
    }
    case &Assignment(a ast_assignment): {
      return gr_assignment(cs, gr, x, &a, out);
    }
    case &AddressOf(a ast_addressof): {
      return gr_mk_addressof(cs, gr, x, &a, out);
    }
    case &Deref(a ast_deref): {
      return gr_mk_deref(cs, gr, x, &a, out);
    }
    case &IndexExpr(a ast_index_expr): {
      return gr_index_expr(cs, gr, x, &a, out);
    }
    case &Lambda(a ast_lambda): {
      return gr_lambda_expr(cs, gr, x, &a, out);
    }
    case &LocalField(a ast_local_field): {
      return gr_local_field(cs, gr, x, &a, out);
    }
    case &DerefField(a ast_deref_field): {
      return gr_deref_field(cs, gr, x, &a, out);
    }
    case &TypedExpr(a ast_typed_expr): {
      return gr_expr(cs, gr, oo(&a.expr), out);
    }
    case &Strinit(a ast_strinit): {
      return gr_mk_strinit(cs, gr, x, &a, out);
    }
  }
}

func gr_mk_strinit(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_strinit, out *gr_num) bool {
  ngn gr_num = add_node(gr, node0(@[gr_op]GrWriteNothing({rval_cell(x)})));

  precs array[gr_num];
  nparams size = count(&a->exprs);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_strinit_param = ref(&a->exprs, i);
    befdep gr_num = add_node(gr, node0(@[gr_op]GrSubcell({result_cell(&param->ec), rval_cell(x), OffsetConst(unHas(&param->info)->offset)})));
    dep gr_num;
    if !gr_expr_consume(cs, gr, &param->ec, &dep) {
      return false;
    }

    prec gr_num = add_node(gr, node0(@[gr_op]GrSequence({befdep, dep})));
    push(&precs, prec);
  }
  var np = add_node(gr, node(precs, GrNop(void)));
  var gn = add_node(gr, node0(@[gr_op]GrSequence({ngn, np})));
  *out = gn;
  return true;
}

func gr_deref_field(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_deref_field, out *gr_num) bool {
  rp gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->lhs), &rp) {
    return false;
  }
  if case &Has(info ast_deref_field_info) = &a->info {
    ap gr_num;
    if !gr_later_discard(cs, gr, &a->ptr_discard, &ap) {
      return false;
    }
    switch info {
      case DerefArrayLength(count u32): {
        var cp = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstInt(~count)})));
        var sp = add_node(gr, node0(@[gr_op]GrSequence({rp, ap})));
        var gn = add_node(gr, node(mk_array(sp, cp), GrNop(void)));
        *out = gn;
        return true;
      }
      case DerefFieldName(offset u32): {
        name cell_num = ellval_cell(x);
        var dp = add_node(gr, node(mk_array(rp), @[gr_op]GrDeref({name, result_cell(oo(&a->lhs)), OffsetConst(offset)})));
        var sp = add_node(gr, node0(@[gr_op]GrSequence({dp, ap})));
        *out = sp;
        return true;
      }
    }
  } else {
    ice(_u8("gr_deref_field sees ast_deref_field not annotated"));
    return fake();
  }
}

func gr_local_field(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_local_field, out *gr_num) bool {
  if case &Has(info ast_local_field_info) = &a->info {
    lp gr_num;
    if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
      return false;
    }
    switch &info {
      case &ArrayLength(alinfo ast_arraylength_info): {
        dp gr_num;
        if !gr_after_actions(cs, gr, lp, &alinfo.after.actions, &dp) {
          return false;
        }
        var cp = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstInt(~alinfo.count)})));
        var gn = add_node(gr, node(mk_array(dp, cp), GrNop(void)));
        *out = gn;
        return true;
      }
      case &FieldName(offset u32): {
        var gn = add_node(gr, node(mk_array(lp), @[gr_op]GrSubcell({value_cell(x), value_cell(oo(&a->lhs)), OffsetConst(offset)})));
        *out = gn;
        return true;
      }
    }
  } else {
    ice(_u8("ast_local_field missing info"));
    return fake();
  }
}

func check_all_cells_have_location(cells *array[cell_info]) void {
  ncells size = count(cells);
  for i size = 0; i < ncells; i = i + 1 {
    c *cell_info = ref(cells, i);
    if !isHas(&c->location) {
      ice(_u8("check_all_cells_have_location sees cell without location"));
    }
  }
}

func gr_lambda_expr(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_lambda, out *gr_num) bool {
  info *ast_fullbody_info = unHas(&a->body.info);
  lambda_gr frame_graph = init_frame_graph_from_cells(info->cells);
  fullbody_gn gr_num;
  return_cell cell_num;
  if !gr_fullbody(cs, &lambda_gr, &a->body, &fullbody_gn, &return_cell) {
    return false;
  }

  check_all_cells_have_location(&lambda_gr.cells);

  id fn_body_id = add_fn_body(cs, {@[fn_body_entry_enum]GraphedFnBody({FnBodyLambda(a), {lambda_gr, fullbody_gn, return_cell}, info->arg_cells})});
  var gn = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstFnBody(id)})));
  *out = gn;
  return true;
}

func gr_index_expr(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_index_expr, out *gr_num) bool {
  if case &Has(info ast_index_expr_info) = &a->info {
    rp gr_num;
    if !gr_expr_consume(cs, gr, oo(&a->rhs), &rp) {
      return false;
    }
    lp gr_num;
    if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
      return false;
    }
    if case &Has(aft ast_expr_after) = &info.after {
      // It's a pointer.
      name cell_num = ellval_cell(x);
      flat_size u32 = ref_cell(gr, name)->props.flat_size;
      var gp = add_node(gr, node(mk_array(rp, lp), @[gr_op]GrDeref({name, result_cell(&aft), OffsetComputed(cons(flat_size, result_cell(oo(&a->rhs))))})));
      gn gr_num;
      if !gr_after_actions(cs, gr, gp, &aft.actions, &gn) {
        return false;
      }
      *out = gn;
      return true;
    } else {
      name cell_num = value_cell(x);
      flat_size u32 = ref_cell(gr, name)->props.flat_size;
      var gp = add_node(gr, node(mk_array(rp, lp), @[gr_op]GrSubcell({name, value_cell(oo(&a->lhs)), OffsetComputed(cons(flat_size, result_cell(oo(&a->rhs))))})));
      *out = gp;
      return true;
    }
  } else {
    ice(_u8("gr_index_expr sees unannotated ast_index_expr"));
    return fake();
  }
}

func gr_later_discard(cs *checkstate, gr *frame_graph, a *ast_later_discard_info, out *gr_num) bool {
  if case &Has(da destroy_action) = &a->action {
    return gr_destroy_action(cs, gr, &da, DeadAfterDestroyYes(void), out);
  } else {
    ice(_u8("ast_later_discard_info not annotated"));
    return fake();
  }
}

func gr_mk_deref(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_deref, out *gr_num) bool {
  rp gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  var dp = add_node(gr, node(mk_array(rp), @[gr_op]GrDeref({ellval_cell(x), result_cell(oo(&a->rhs)), OffsetConst(0)})));
  ap gr_num;
  if !gr_later_discard(cs, gr, &a->ptr_discard, &ap) {
    return false;
  }
  var gn = add_node(gr, node0(@[gr_op]GrSequence({dp, ap})));
  *out = gn;
  return true;
}

func gr_mk_addressof(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_addressof, out *gr_num) bool {
  rp gr_num;
  if !gr_expr(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  ap gr_num = add_node(gr, node(mk_array(rp), @[gr_op]GrAddressof({rval_cell(x), ellval_cell(oo(&a->rhs))})));
  *out = ap;
  return true;
}

func gr_assignment(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_assignment, out *gr_num) bool {
  lp gr_num;
  if !gr_expr(cs, gr, oo(&a->lhs), &lp) {
    return false;
  }
  rp gr_num;
  if !gr_expr(cs, gr, oo(&a->rhs), &rp) {
    return false;
  }
  lp_rp_nop gr_num = add_node(gr, node(mk_array(lp, rp), GrNop(void)));
  switch unHas(&a->info) {
    case &StaticSelfAssignment(v void): {
      *out = lp_rp_nop;
      return true;
    }
    case &ConditionalAssignment(ci ast_conditional_assignment_info): {
      var fc = add_node(gr, node0(@[gr_op]GrWriteConst({ci.comparecells.funcell, ConstDef(ci.comparecells.ip)})));
      var dp = add_node(gr, node0(@[gr_op]GrAddressof({ci.comparecells.destptr, value_cell(oo(&a->lhs))})));
      var sp = add_node(gr, node0(@[gr_op]GrAddressof({ci.comparecells.srcptr, value_cell(oo(&a->rhs))})));
      var ap = add_node(gr, node(mk_array(fc, dp, sp), @[gr_op]GrApply({ci.comparecells.funcell, mk_array(ci.comparecells.destptr, ci.comparecells.srcptr), ci.comparecells.cmp_result})));

      var nop = add_node(gr, node0(@[gr_op]GrNop(void)));
      var assignnop = add_node(gr, node0(@[gr_op]GrNop(void)));
      assign gr_num;
      if !gr_after_actions(cs, gr, assignnop, &ci.conditional_actions, DeadAfterDestroyNo(void), &assign) {
        return false;
      }
      cases array[tup[gr_const, gr_num]] = mk_array(cons(@[gr_const]ConstInt(~ @[u32] 0), assign), cons(@[gr_const]ConstInt(~ @[u32] 1), nop));

      var br = add_node(gr, node(mk_array(ap), @[gr_op]GrBranch({ci.comparecells.cmp_result, cases, None()})));
      unc gr_num;
      if !gr_after_actions(cs, gr, br, &ci.unconditional_actions, &unc) {
        return false;
      }
      var seq_lp_rp_nop = add_node(gr, node0(@[gr_op]GrSequence({lp_rp_nop, unc})));
      *out = seq_lp_rp_nop;
      return true;
    }
  }
}

func gr_logical_conjunction(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_logical_conjunction, out *gr_num) bool {
  lhs_dep gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->lhs), &lhs_dep) {
    return false;
  }
  rhs_dep gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->rhs), &rhs_dep) {
    return false;
  }

  rhs_cp_gn gr_num = add_node(gr, node(mk_array(rhs_dep), @[gr_op]GrMemCopy({rval_cell(x), result_cell(oo(&a->rhs))})));
  rhs_dead_gn gr_num = add_node(gr, node(mk_array(rhs_cp_gn), @[gr_op]GrDead({result_cell(oo(&a->rhs))})));

  lhs_cp_gn gr_num = add_node(gr, node0(@[gr_op]GrMemCopy({rval_cell(x), result_cell(oo(&a->lhs))})));
  lhs_dead_gn gr_num = add_node(gr, node(mk_array(lhs_cp_gn), @[gr_op]GrDead({result_cell(oo(&a->lhs))})));

  cases array[tup[gr_const, gr_num]];
  short_circuit_case gr_const;
  eval_rhs_case gr_const;
  if a->is_logical_or {
    short_circuit_case = ConstInt(~ @[u32] 1);
    eval_rhs_case = ConstInt(~ @[u32] 0);
  } else {
    short_circuit_case = ConstInt(~ @[u32] 0);
    eval_rhs_case = ConstInt(~ @[u32] 1);
  }
  bn gr_num = add_node(gr, node(mk_array(lhs_dep), @[gr_op]GrBranch({result_cell(oo(&a->lhs)), mk_array({short_circuit_case, lhs_dead_gn}, {eval_rhs_case, rhs_dead_gn}), None()})));
  *out = bn;
  return true;
}

func gr_funcall(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_funcall, out *gr_num) bool {
  precs array[gr_num];
  dep gr_num;
  if !gr_expr_consume(cs, gr, oo(&a->fun), &dep) {
    return false;
  }
  push(&precs, dep);
  paramcells array[cell_num];
  nparams size = count(&a->params);
  for i size = 0; i < nparams; i = i + 1 {
    param *ast_expr_consume = ref(&a->params, i);
    if !gr_expr_consume(cs, gr, param, &dep) {
      return false;
    }
    push(&precs, dep);
    push(&paramcells, result_cell(param));
  }
  var ap = add_node(gr, node(precs, @[gr_op]GrApply({result_cell(oo(&a->fun)), paramcells, rval_cell(x)})));
  *out = ap;
  return true;
}

func gr_string_literal(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_string_literal, out *gr_num) bool {
  bytes array[u8];
  nchars size = count(&a->charspecs);
  for i size = 0; i < nchars; i = i + 1 {
    ch i32 = get(&a->charspecs, i).value;
    if ch < 0 || ch > 255 {
      ice(_u8("gr_string_literal char values out of range"));
    }
    push(&bytes, ~ch);
  }
  var gn = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstBytes(bytes)})));
  *out = gn;
  return true;
}

func gr_literal(cs *checkstate, gr *frame_graph, x *ast_expr, value bigint, out *gr_num) bool {
  var gn = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstInt(value)})));
  *out = gn;
  return true;
}

func gr_name_expr(cs *checkstate, gr *frame_graph, x *ast_expr, a *ast_name_expr, out *gr_num) bool {
  switch unHas(&a->name_info) {
    case &LocalResolve(li local_info): {
      *out = add_node(gr, node0(@[gr_op]GrNop(void)));
      return true;
    }
    case &GlobalResolve(gi global_info): {
      *out = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstDef({gi.ent, gi.inst})})));
      return true;
    }
    case &EnumConstructor(ei enum_constructor_info): {
      *out = add_node(gr, node0(@[gr_op]GrWriteConst({rval_cell(x), ConstDef(ei.ip)})));
      return true;
    }
  }
}

func ellval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalYes(desc lval_description): { return desc.num; }
    case &IsLvalNo(desc rval_description): {
      ice(_u8("lvalue_value_cell expects lvalue"));
      return fake();
    }
  }
}

func ellval_cell(a *ast_expr) cell_num {
  return ellval_cell(&expr_complete_info(a)->lval);
}

func rval_cell(x *ast_expr) cell_num {
  return rval_cell(&expr_complete_info(x)->lval);
}

func rval_cell(x *is_lval) cell_num {
  switch x {
    case &IsLvalNo(desc rval_description): {
      return desc.whole_num;
    }
    case &IsLvalYes(desc lval_description): {
      ice(_u8("rval_cell sees lvalue"));
      return fake();
    }
  }
}

// TODO: This is a lame and fragile way to specify when to make cells be GrDead.
defenum dead_after_destroy {
  DeadAfterDestroyYes void;
  DeadAfterDestroyNo void;
};

func gr_after_actions(cs *checkstate, gr *frame_graph, prec gr_num, x *array[after_action], out *gr_num) bool {
  return gr_after_actions(cs, gr, prec, x, DeadAfterDestroyYes(void), out);
}

func gr_after_actions(cs *checkstate, gr *frame_graph, prec gr_num, x *array[after_action], dad dead_after_destroy, out *gr_num) bool {
  nacts size = count(x);
  for i size = 0; i < nacts; i = i + 1 {
    dep gr_num;
    if !gr_after_action(cs, gr, ref(x, i), dad, &dep) {
      return false;
    }
    prec = add_node(gr, node0(@[gr_op]GrSequence({prec, dep})));
  }
  *out = prec;
  return true;
}

func gr_after_action(cs *checkstate, gr *frame_graph, x *after_action, dad dead_after_destroy, out *gr_num) bool {
  switch x {
    case &CopyAfter(ca copy_action): {
      return gr_bi_action(cs, gr, &ca.~, out);
    }
    case &MoveAfter(ma move_action): {
      dep gr_num;
      if !gr_bi_action(cs, gr, &ma.~, &dep) {
        return false;
      }
      *out = add_node(gr, node(mk_array(dep), @[gr_op]GrDead({ma.src})));
      return true;
    }
    case &DestroyAfter(da destroy_action): {
      return gr_destroy_action(cs, gr, &da, dad, out);
    }
  }
}

func gr_uni_fun_ctor_desc(cs *checkstate, gr *frame_graph, desc *uni_fun_ctor_desc, arg cell_num) gr_num {
  var fc = add_node(gr, node0(@[gr_op]GrWriteConst({desc->funcell, ConstDef(desc->ip)})));
  var arp = add_node(gr, node0(@[gr_op]GrAddressof({desc->argptr, arg})));
  var ap = add_node(gr, node(mk_array(fc, arp), @[gr_op]GrApply({desc->funcell, mk_array(desc->argptr), desc->retvoid})));
  var deadret = add_node(gr, node(mk_array(ap), @[gr_op]GrDead({desc->retvoid})));
  return deadret;
}

func gr_init_action(cs *checkstate, gr *frame_graph, x *init_action, out *gr_num) bool {
  switch &x->ctor {
    case &UniTrivialCtor(v void): {
      var dp = add_node(gr, node0(@[gr_op]GrWriteConst({x->arg, ConstInt(~ @[u32] 0)})));
      *out = dp;
      return true;
    }
    case &UniFunCtor(desc uni_fun_ctor_desc): {
      gn gr_num = gr_uni_fun_ctor_desc(cs, gr, &desc, x->arg);
      *out = gn;
      return true;
    }
  }
}

func gr_destroy_action(cs *checkstate, gr *frame_graph, x *destroy_action, dad dead_after_destroy, out *gr_num) bool {
  switch &x->ctor {
    case &UniTrivialCtor(v void): {
      dp gr_num;
      if case DeadAfterDestroyYes(v2 void) = dad {
        dp = add_node(gr, node0(@[gr_op]GrDead({x->arg})));
      } else {
        dp = add_node(gr, node0(@[gr_op]GrNop(void)));
      }
      *out = dp;
      return true;
    }
    case &UniFunCtor(desc uni_fun_ctor_desc): {
      gn gr_num = gr_uni_fun_ctor_desc(cs, gr, &desc, x->arg);
      dp gr_num;
      if case DeadAfterDestroyYes(v2 void) = dad {
        dp = add_node(gr, node(mk_array(gn), @[gr_op]GrDead({x->arg})));
      } else {
        dp = gn;
      }
      *out = dp;
      return true;
    }
  }
}

func gr_bi_fun_ctor_desc(cs *checkstate, gr *frame_graph, desc *bi_fun_ctor_desc, dest cell_num, src cell_num) gr_num {
  var fc = add_node(gr, node0(@[gr_op]GrWriteConst({desc->funcell, ConstDef(desc->ip)})));
  var dp = add_node(gr, node0(@[gr_op]GrAddressof({desc->destptr, dest})));
  var sp = add_node(gr, node0(@[gr_op]GrAddressof({desc->srcptr, src})));
  var ap = add_node(gr, node(mk_array(fc, dp, sp), @[gr_op]GrApply({desc->funcell, mk_array(desc->destptr, desc->srcptr), desc->retvoid})));
  var deadret = add_node(gr, node(mk_array(ap), @[gr_op]GrDead({desc->retvoid})));
  return deadret;
}

func gr_bi_action(cs *checkstate, gr *frame_graph, x *bi_action, out *gr_num) bool {
  switch &x->ctor {
    case &BiTrivialCtor(v void): {
      var cp = add_node(gr, node0(@[gr_op]GrMemCopy({x->dest, x->src})));
      *out = cp;
      return true;
    }
    case &BiFunCtor(desc bi_fun_ctor_desc): {
      gn gr_num = gr_bi_fun_ctor_desc(cs, gr, &desc, x->dest, x->src);
      *out = gn;
      return true;
    }
  }
}

// TODO: There's a lot of duplicated code in the splay-out of this function.
func gr_magic(cs *checkstate, clq *clqueue, mag *def_magic, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  switch mag {
  case &MagicBzero(mb magic_bzero):
    return gr_magic_bzero(cs, clq, &mb, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicMemcopy(mm magic_memcopy):
    return gr_magic_memcopy(cs, clq, &mm, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicNopdestroy(v void):
    return gr_magic_nopdestroy(cs, clq, gr_out, gn_out, return_cell_out, arg_cells_out);

  case &MagicCtor(wmc which_magic_ctor):
    return gr_magic_ctor(cs, clq, wmc.wc, &wmc.mc, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicEnumConstruct(mec magic_enum_construct):
    arg_cell cell_num;
    if !gr_magic_enum_construct(cs, clq, &mec, gr_out, gn_out, return_cell_out, &arg_cell) {
      return false;
    }
    *arg_cells_out = mk_array(arg_cell);
    return true;
  }
}

deftype gr_basics struct {
  return_cell cell_num;
  argcells array[cell_num];
  pointeecells array[cell_num];
  derefs array[gr_num];
};

func add_basics(cs *checkstate, clq *clqueue, gr *frame_graph, size u32, arity size, out *gr_basics) void {
  pointee_tp cu_typrop = compute_prim(clq, primitive_padding_type(cs, size));
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, pointee_tp.cu.~));
  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));
  ret gr_basics;
  ret.return_cell = add_cell(gr, {Has(LocationRigid(void)), voidtp.cu, voidtp.props});
  for i size = 0; i < arity; i = i + 1 {
    ac cell_num = add_cell(gr, {Has(LocationRigid(void)), argtp.cu, argtp.props});
    push(&ret.argcells, ac);
    pc cell_num = add_cell(gr, {Has(LocationVirtual(void)), pointee_tp.cu, pointee_tp.props});
    push(&ret.pointeecells, pc);
    dn gr_num = add_node(gr, node0(@[gr_op]GrDeref({pc, ac, OffsetConst(0)})));
    push(&ret.derefs, dn);
  }
  *out = ret;
}

func basics_cleanup(cs *checkstate, clq *clqueue, gr *frame_graph, bas *gr_basics, gn gr_num, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) void {
  precs array[gr_num];
  ncells size = count(&bas->argcells);
  for i size = 0; i < ncells; i = i + 1 {
    gd gr_num = add_node(gr, node0(@[gr_op]GrDead({get(&bas->argcells, i)})));
    push(&precs, gd);
  }
  var retset = add_node(gr, node0(@[gr_op]GrWriteConst({bas->return_cell, ConstInt(bigu(0))})));
  push(&precs, retset);
  var nopgn = add_node(gr, node(precs, @[gr_op]GrNop(void)));
  var fingn = add_node(gr, node0(@[gr_op]GrSequence({gn, nopgn})));
  *gr_out = *gr;
  *gn_out = fingn;
  *return_cell_out = bas->return_cell;
  *arg_cells_out = bas->argcells;
}

func gr_magic_nopdestroy(cs *checkstate, clq *clqueue, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty();
  bas gr_basics;
  // TODO: This creates a needless deref node, pointee cell.
  // TODO: How about make the size parameter opt[u32], don't deref if no size.
  add_basics(cs, clq, &gr, 0 /* Pass a made-up size. */, 1, &bas);
  gn gr_num = add_node(&gr, node0(@[gr_op]GrNop(void)));
  basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return true;
}

func gr_magic_memcopy(cs *checkstate, clq *clqueue, mm *magic_memcopy, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty();
  bas gr_basics;
  add_basics(cs, clq, &gr, *unHas(&mm->size), 2, &bas);
  gn gr_num = add_node(&gr, node(bas.derefs, @[gr_op]GrMemCopy({get(&bas.pointeecells, 0), get(&bas.pointeecells, 1)})));
  basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return true;
}

func gr_magic_bzero(cs *checkstate, clq *clqueue, mb *magic_bzero, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty();
  bas gr_basics;
  add_basics(cs, clq, &gr, *unHas(&mb->size), 1, &bas);
  gn gr_num = add_node(&gr, node(bas.derefs, @[gr_op]GrWriteConst({get(&bas.pointeecells, 0), ConstInt(bigu(0))})));
  basics_cleanup(cs, clq, &gr, &bas, gn, gr_out, gn_out, return_cell_out, arg_cells_out);
  return true;
}

func gr_magic_ctor(cs *checkstate, clq *clqueue, wc which_ctor, mc *magic_ctor, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  info *magic_ctor_info = ref_info(mc);
  switch info {
  case &MagicWholeFieldInfo(mwfi magic_whole_field_info):
    return gr_magic_whole_field_info(cs, clq, wc, &mwfi, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicStructInfo(msi magic_struct_info):
    return gr_magic_struct_info(cs, clq, wc, &msi, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicEnumInfo(mei magic_enum_info):
    return gr_magic_enum_info(cs, clq, wc, &mei, gr_out, gn_out, return_cell_out, arg_cells_out);
  case &MagicArraytypeInfo(mai magic_arraytype_info):
    return gr_magic_arraytype_info(cs, clq, wc, &mai, gr_out, gn_out, return_cell_out, arg_cells_out);
  }
}

func gr_magic_arraytype_info(cs *checkstate, clq *clqueue, wc which_ctor, mai *magic_arraytype_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty();
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mai->cu_type.~));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  param *te_typeexpr;
  arraycount u32;
  if case &TeArraytype(at te_arraytype) = &mai->cu_type.~ {
    param = oo(&at.param);
    if case Has(atcount u32) = at.count {
      arraycount = atcount;
    } else {
      ice(_u8("gr_magic_arraytype_info missing count"));
    }
  } else {
    ice(_u8("gr_magic_arraytype_info sees non-array type"));
  }

  param_props type_properties;
  if !compute_complete_type_properties(cs, clq, param, &param_props) {
    return false;
  }

  elemptrtype cu_typeexpr;
  elemptrtype_props type_properties;
  compute_prim(cs, clq, ptr_type(cs, *param), &elemptrtype, &elemptrtype_props);

  nargs size = num_args(wc);

  fntype cu_typeexpr;
  fntype_props type_properties;
  compute_prim(cs, clq, fn_type(cs, repeat(nargs, elemptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

  size_type cu_typeexpr;
  size_type_props type_properties;
  compute_prim(cs, clq, primitive_size_type(cs), &size_type, &size_type_props);

  argcells array[cell_num];
  pointeecells array[cell_num];
  derefgns array[gr_num];
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {Has(LocationRigid(void)), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {Has(LocationVirtual(void)), mai->cu_type, mai->cu_props});
    push(&pointeecells, pc);

    gn gr_num = add_node(&gr, node0(@[gr_op]GrDeref({pc, ac, OffsetConst(0)})));
    push(&derefgns, gn);
  }

  derefgn gr_num = add_node(&gr, node(derefgns, GrNop(void)));

  return_cell cell_num = add_cell(&gr, {Has(LocationRigid(void)), voidtp.cu, voidtp.props});
  bn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({return_cell, ConstInt(~ @[u32] 0)})));

  indexcell cell_num = add_cell(&gr, {Has(LocationFlex(void)), size_type, size_type_props});

  // TODO: Codegen a loop, not this unrolled loop.
  for i2 u32 = 0; i2 < arraycount; i2 = i2 + 1 {
    i u32;
    // Destructors go in reverse order (which means we prepend in the opposite of that).
    if case CtorDestroy(v void) = wc {
      i = i2;
    } else {
      i = arraycount - i2 - 1;
    }

    ixgn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({indexcell, ConstInt(~ i)})));

    elemptrcells array[cell_num];
    precs array[gr_num];

    elemcells array[cell_num];
    elemgns array[gr_num];
    for j size = 0; j < nargs; j = j + 1 {
      ec cell_num = add_cell(&gr, {Has(LocationVirtual(void)), ~ *param, param_props});
      push(&elemcells, ec);
      gn gr_num = add_node(&gr, node0(@[gr_op]GrSubcell({ec, get(&pointeecells, j), OffsetComputed({i, indexcell})})));
      push(&elemgns, gn);
      epc cell_num = add_cell(&gr, {Has(LocationRigid(void)), elemptrtype, elemptrtype_props});
      push(&elemptrcells, epc);
      ptrgn gr_num = add_node(&gr, node(mk_array(gn), @[gr_op]GrAddressof({epc, ec})));
      push(&precs, ptrgn);
    }

    elemretcell cell_num = add_cell(&gr, {Has(LocationFlex(void)), voidtp.cu, voidtp.props});
    func_cell cell_num = add_cell(&gr, {Has(LocationRigid(void)), fntype, fntype_props});

    func_gn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({func_cell, ConstDef(mai->ip)})));
    push(&precs, func_gn);

    ap gr_num = add_node(&gr, node(precs, @[gr_op]GrApply({func_cell, elemptrcells, elemretcell})));
    vd gr_num = add_node(&gr, node(mk_array(ap), @[gr_op]GrDead({elemretcell})));

    ixvd gr_num = add_node(&gr, node0(@[gr_op]GrSequence({ixgn, vd})));
    bn = add_node(&gr, node0(@[gr_op]GrSequence({ixvd, bn})));
  }

  var gn = add_node(&gr, node0(@[gr_op]GrSequence({derefgn, bn})));
  *gr_out = gr;
  *gn_out = gn;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return true;
}

func gr_magic_enum_info(cs *checkstate, clq *clqueue, wc which_ctor, mei *magic_enum_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  init_padding bool = false;
  switch wc {
  case CtorInit(v void):
    ice(_u8("Magic CtorInit on enum type"));
  case CtorCopy(v void):
    init_padding = true;
  case CtorMove(v void):
    init_padding = true;
  case CtorDestroy(v void):
    // don't init padding.
  }
  gr frame_graph = init_frame_graph_empty();
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mei->cu_type.~));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  et *te_enum;
  if case &TeEnum(t te_enum) = &mei->cu_type.~ {
    et = &t;
  } else {
    ice(_u8("gr_magic_enum_info called on non-enum"));
  }

  tagtype cu_typeexpr;
  tagtype_props type_properties;
  compute_prim(cs, clq, enum_tag_type(cs, et), &tagtype, &tagtype_props);

  argcells array[cell_num];
  pointeecells array[cell_num];
  tagcells array[cell_num];
  deref_gns array[gr_num];
  tagcell_gns array[gr_num];
  nargs size = num_args(wc);
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {Has(LocationRigid(void)), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {Has(LocationVirtual(void)), mei->cu_type, mei->cu_props});
    push(&pointeecells, pc);
    tc cell_num = add_cell(&gr, {Has(LocationVirtual(void)), tagtype, tagtype_props});
    push(&tagcells, tc);

    derefgn gr_num = add_node(&gr, node0(@[gr_op]GrDeref({pc, ac, OffsetConst(0)})));
    push(&deref_gns, derefgn);
    tcgn gr_num = add_node(&gr, node(mk_array(derefgn), @[gr_op]GrSubcell({tc, pc, OffsetConst(enum_tag_offset)})));
    push(&tagcell_gns, tcgn);
  }

  deref_gn gr_num = add_node(&gr, node(tagcell_gns, @[gr_op]GrNop(void)));

  return_cell cell_num = add_cell(&gr, {Has(LocationRigid(void)), voidtp.cu, voidtp.props});
  setret gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({return_cell, ConstInt(~ @[u32] 0)})));

  cases_gn array[tup[gr_const, gr_num]];
  nconstructors size = count(&et->constructors);
  for i size = 0; i < nconstructors; i = i + 1 {
    tagval enum_tag_value = mk_enum_tag_value(i);

    fieldtype cu_typeexpr = ~ref(&et->constructors, i)->type;
    fieldtype_props type_properties;
    if !compute_type_properties(cs, clq, &fieldtype, &fieldtype_props) {
      return false;
    }

    field_offset u32 = enum_field_offset(cs, et, tagval);
    field_end u32 = field_offset + fieldtype_props.flat_size;
    tag_end u32 = enum_tag_offset + tagtype_props.flat_size;
    prepadding_ogn opt[gr_num]
      = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), tag_end, field_offset - tag_end);
    postpadding_ogn opt[gr_num]
      = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), field_end, mei->cu_props.flat_size - field_end);

    fieldcella array[cell_num];
    fieldcellgn array[gr_num];
    for j size = 0; j < nargs; j = j + 1 {
      fc cell_num = add_cell(&gr, {Has(LocationVirtual(void)), fieldtype, fieldtype_props});
      push(&fieldcella, fc);
      sn gr_num = add_node(&gr, node0(@[gr_op]GrSubcell({get(&fieldcella, j), get(&pointeecells, j), OffsetConst(field_offset)})));
      push(&fieldcellgn, sn);
    }

    last_ogn opt[gr_num];
    if case &Has(ip instpair) = ref(&mei->cips, i) {
      fieldptrtype cu_typeexpr;
      fieldptrtype_props type_properties;
      compute_prim(cs, clq, ptr_type(cs, fieldtype.~), &fieldptrtype, &fieldptrtype_props);

      fieldptrcella array[cell_num];
      precs array[gr_num];
      for j size = 0; j < nargs; j = j + 1 {
        fpc cell_num = add_cell(&gr, {Has(LocationRigid(void)), fieldptrtype, fieldptrtype_props});
        push(&fieldptrcella, fpc);
        an gr_num = add_node(&gr, node(mk_array(get(&fieldcellgn, j)), @[gr_op]GrAddressof({fpc, get(&fieldcella, j)})));
        push(&precs, an);
      }

      fieldretcell cell_num = add_cell(&gr, {Has(LocationFlex(void)), voidtp.cu, voidtp.props});

      fntype cu_typeexpr;
      fntype_props type_properties;
      compute_prim(cs, clq, fn_type(cs, repeat(nargs, fieldptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

      func_cell cell_num = add_cell(&gr, {Has(LocationRigid(void)), fntype, fntype_props});
      func_gn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({func_cell, ConstDef(ip)})));
      push(&precs, func_gn);

      ap gr_num = add_node(&gr, node(precs, @[gr_op]GrApply({func_cell, fieldptrcella, fieldretcell})));
      vd gr_num = add_node(&gr, node(mk_array(ap), @[gr_op]GrDead({fieldretcell})));
      last_ogn = Has(vd);
    } else {
      ogn opt[gr_num];
      switch wc {
      case CtorInit(v void):
        ice(_u8("CtorInit on enum type"));
      case CtorCopy(v void):
        var cgn = add_node(&gr, node(fieldcellgn, @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)})));
        ogn = Has(cgn);
      case CtorMove(v void):
        var cgn = add_node(&gr, node(fieldcellgn, @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)})));
        ogn = Has(cgn);
      case CtorDestroy(v void):
        ogn = None();
        // do nothing.
      }

      last_ogn = ogn;
    }

    tagset_ogn opt[gr_num];
    switch wc {
    case CtorInit(v void):
      ice(_u8("CtorInit on wc type"));
    case CtorCopy(v void):
      var tgn = add_node(&gr, node0(@[gr_op]GrWriteConst({get(&fieldcella, 0), ConstInt(~ tagval.~)})));
      tagset_ogn = Has(tgn);
    case CtorMove(v void):
      var tgn = add_node(&gr, node0(@[gr_op]GrWriteConst({get(&fieldcella, 0), ConstInt(~ tagval.~)})));
      tagset_ogn = Has(tgn);
    case CtorDestroy(v void):
      tagset_ogn = None();
    }

    finalgn gr_num = add_node(&gr, node(concat(tagset_ogn, prepadding_ogn, last_ogn, postpadding_ogn), GrNop(void)));

    finalseqgn gr_num = add_node(&gr, node0(@[gr_op]GrSequence({finalgn, setret})));
    push(&cases_gn, cons(@[gr_const]ConstInt(~ tagval.~), finalseqgn));
  }

  br gr_num = add_node(&gr, node0(@[gr_op]GrBranch({get(&tagcells, nargs - 1), cases_gn, None()})));
  sqr gr_num = add_node(&gr, node0(@[gr_op]GrSequence({deref_gn, br})));
  *gr_out = gr;
  *gn_out = sqr;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return true;
}

func gr_magic_struct_info(cs *checkstate, clq *clqueue, wc which_ctor, msi *magic_struct_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  // Destructors go in reverse order (which means we prepend them in the reverse of reverse order).
  reverse_order bool = false;
  // Init, copy, and move requires initializing intervening padding.
  init_padding bool = false;
  switch wc {
  case CtorInit(v void):
    init_padding = true;
  case CtorCopy(v void):
    init_padding = true;
  case CtorMove(v void):
    init_padding = true;
  case CtorDestroy(v void):
    reverse_order = true;
  }

  gr frame_graph = init_frame_graph_empty();
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, msi->cu_type.~));

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  st *te_struct;
  if case &TeStruct(t te_struct) = &msi->cu_type.~ {
    st = &t;
  } else {
    ice(_u8("gr_magic_struct_info called on non-struct"));
  }

  psd partial_struct_data;
  if !compute_partial_struct_data(cs, clq, &st->fields, None(), &psd) {
    return false;
  }

  argcells array[cell_num];
  pointeecells array[cell_num];
  derefgns array[gr_num];
  nargs size = num_args(wc);
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {Has(LocationRigid(void)), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {Has(LocationVirtual(void)), msi->cu_type, msi->cu_props});
    push(&pointeecells, pc);

    gn gr_num = add_node(&gr, node0(@[gr_op]GrDeref({pc, ac, OffsetConst(0)})));
    push(&derefgns, gn);
  }

  derefgn gr_num = add_node(&gr, node(derefgns, GrNop(void)));

  return_cell cell_num = add_cell(&gr, {Has(LocationRigid(void)), voidtp.cu, voidtp.props});
  bn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({return_cell, ConstInt(~ @[u32] 0)})));

  nfields size = count(&msi->fips);
  check(nfields == count(&st->fields));
  for i2 size = 0; i2 < nfields; i2 = i2 + 1 {
    i size;
    if reverse_order {
      i = i2;
    } else {
      i = nfields - i2 - 1;
    }

    fieldcella array[cell_num];
    fieldcellgn array[gr_num];
    for j size = 0; j < nargs; j = j + 1 {
      fc cell_num = add_cell(&gr, {Has(LocationVirtual(void)), ~ ref(&st->fields, i)->type, ref(&psd.fields, i)->props});
      push(&fieldcella, fc);

      gn gr_num = add_node(&gr, node0(@[gr_op]GrSubcell({fc, get(&pointeecells, j), OffsetConst(ref(&psd.fields, i)->offset)})));
      push(&fieldcellgn, gn);
    }

    field_gn gr_num;
    if case Has(ip instpair) = get(&msi->fips, i) {
      fieldptrtype cu_typeexpr;
      fieldptrtype_props type_properties;
      compute_prim(cs, clq, ptr_type(cs, ref(&st->fields, i)->type), &fieldptrtype, &fieldptrtype_props);

      fieldptrcella array[cell_num];
      precs array[gr_num];
      for j size = 0; j < nargs; j = j + 1 {
        fpc cell_num = add_cell(&gr, {Has(LocationRigid(void)), fieldptrtype, fieldptrtype_props});
        push(&fieldptrcella, fpc);
        gn gr_num = add_node(&gr, node(mk_array(get(&fieldcellgn, j)), @[gr_op]GrAddressof({fpc, get(&fieldcella, j)})));
        push(&precs, gn);
      }

      fieldretcell cell_num = add_cell(&gr, {Has(LocationFlex(void)), voidtp.cu, voidtp.props});

      fntype cu_typeexpr;
      fntype_props type_properties;
      compute_prim(cs, clq, fn_type(cs, repeat(nargs, fieldptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

      func_cell cell_num = add_cell(&gr, {Has(LocationRigid(void)), fntype, fntype_props});

      func_gn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({func_cell, ConstDef(ip)})));
      push(&precs, func_gn);

      ap gr_num = add_node(&gr, node(precs, @[gr_op]GrApply({func_cell, fieldptrcella, fieldretcell})));

      vd gr_num = add_node(&gr, node(mk_array(ap), @[gr_op]GrDead({fieldretcell})));

      field_gn = vd;
    } else {
      gn gr_num;
      switch wc {
      case CtorInit(v void):
        // zero-initialize.
        gn = add_node(&gr, node(fieldcellgn, @[gr_op]GrWriteConst({get(&fieldcella, 0), ConstInt(~ @[u32] 0)})));
      case CtorCopy(v void):
        gn = add_node(&gr, node(fieldcellgn, @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)})));
      case CtorMove(v void):
        gn = add_node(&gr, node(fieldcellgn, @[gr_op]GrMemCopy({get(&fieldcella, 0), get(&fieldcella, 1)})));
      case CtorDestroy(v void):
        // do nothing.
      }

      field_gn = gn;
    }

    field_and_padding_gn gr_num;
    if init_padding {
      padding_offset u32;
      padding_count u32;
      postpadding_offset_and_count(&psd, i, &padding_offset, &padding_count);
      if case Has(bzero_gn gr_num) = gr_bzero_subcell(clq, &gr, get(&pointeecells, 0), padding_offset, padding_count) {
        var nop2_gn = add_node(&gr, node(mk_array(bzero_gn, field_gn), GrNop(void)));
        field_and_padding_gn = nop2_gn;
      } else {
        field_and_padding_gn = field_gn;
      }
    } else {
      field_and_padding_gn = field_gn;
    }

    bn = add_node(&gr, node0(@[gr_op]GrSequence({field_and_padding_gn, bn})));
  }

  var gn = add_node(&gr, node0(@[gr_op]GrSequence({derefgn, bn})));

  *gr_out = gr;
  *gn_out = gn;
  *return_cell_out = return_cell;
  *arg_cells_out = argcells;
  return true;
}

func gr_bzero_subcell(clq *clqueue, gr *frame_graph, c cell_num, offset u32, size u32) opt[gr_num] {
  if size == 0 {
    return None();
  }
  padtype cu_typrop = compute_prim(clq, primitive_padding_type(clq->cs, size));
  pad_cell cell_num = add_cell(gr, {Has(LocationVirtual(void)), padtype.cu, padtype.props});
  var subcell_gn = add_node(gr, node0(@[gr_op]GrSubcell({pad_cell, c, OffsetConst(offset)})));
  var bzero_gn = add_node(gr, node(mk_array(subcell_gn), @[gr_op]GrWriteConst({pad_cell, ConstInt(bigu(0))})));
  return Has(bzero_gn);
}

func postpadding_offset_and_count(psd *partial_struct_data, i size, offset_out *u32, count_out *u32) void {
  check(psd->index == count(&psd->fields));
  check(i < psd->index);
  begin u32 = ref(&psd->fields, i)->offset + ref(&psd->fields, i)->props.flat_size;
  end u32;
  if i + 1 < psd->index {
    end = ref(&psd->fields, i + 1)->offset;
  } else {
    end = psd->offset;
  }
  *offset_out = begin;
  *count_out = end - begin;
}

func gr_magic_whole_field_info(cs *checkstate, clq *clqueue, wc which_ctor, mwfi *magic_whole_field_info, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cells_out *array[cell_num]) bool {
  gr frame_graph = init_frame_graph_empty();
  argtp cu_typrop = compute_prim(clq, ptr_type(cs, mwfi->cu_type.~));

  fieldptrtype cu_typeexpr;
  fieldptrtype_props type_properties;
  compute_prim(cs, clq, ptr_type(cs, mwfi->rhs_type.~), &fieldptrtype, &fieldptrtype_props);

  voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

  nargs size = num_args(wc);
  fntype cu_typeexpr;
  fntype_props type_properties;
  compute_prim(cs, clq, fn_type(cs, repeat(nargs, fieldptrtype.~), voidtp.cu.~), &fntype, &fntype_props);

  fncell cell_num = add_cell(&gr, {Has(LocationRigid(void)), fntype, fntype_props});
  argcells array[cell_num];
  pointeecells array[cell_num];
  fieldcells array[cell_num];
  fieldptrcells array[cell_num];
  for i size = 0; i < nargs; i = i + 1 {
    ac cell_num = add_cell(&gr, {Has(LocationRigid(void)), argtp.cu, argtp.props});
    push(&argcells, ac);
    pc cell_num = add_cell(&gr, {Has(LocationVirtual(void)), mwfi->cu_type, mwfi->cu_props});
    push(&pointeecells, pc);
    fc cell_num = add_cell(&gr, {Has(LocationVirtual(void)), mwfi->rhs_type, mwfi->rhs_props});
    push(&fieldcells, fc);
    fpc cell_num = add_cell(&gr, {Has(LocationRigid(void)), fieldptrtype, fieldptrtype_props});
    push(&fieldptrcells, fpc);
  }

  retcell cell_num = add_cell(&gr, {Has(LocationRigid(void)), voidtp.cu, voidtp.props});

  precs array[gr_num];
  for i size = 0; i < nargs; i = i + 1 {
    var pointee_gn = add_node(&gr, node0(@[gr_op]GrDeref({get(&pointeecells, i), get(&argcells, i), OffsetConst(0)})));
    var fieldcell_gn = add_node(&gr, node(mk_array(pointee_gn), @[gr_op]GrSubcell({get(&fieldcells, i), get(&pointeecells, i), OffsetConst(0)})));
    var fieldptr_gn = add_node(&gr, node(mk_array(fieldcell_gn), @[gr_op]GrAddressof({get(&fieldptrcells, i), get(&fieldcells, i)})));
    push(&precs, fieldptr_gn);
  }

  var fn_gn = add_node(&gr, node0(@[gr_op]GrWriteConst({fncell, ConstDef(mwfi->ip)})));
  push(&precs, fn_gn);

  var ap = add_node(&gr, node(precs, @[gr_op]GrApply({fncell, fieldptrcells, retcell})));

  *gr_out = gr;
  *gn_out = ap;
  // We sort of make this look like a "tail call," informally -- is that bad?
  *return_cell_out = retcell;
  *arg_cells_out = argcells;
  return true;
}

func gr_magic_enum_construct(cs *checkstate, clq *clqueue, mec *magic_enum_construct, gr_out *frame_graph, gn_out *gr_num, return_cell_out *cell_num, arg_cell_out *cell_num) bool {
  gr frame_graph = init_frame_graph_empty();
  retnum cell_num = add_cell(&gr, {Has(LocationRigid(void)), mec->enum_type, mec->enum_type_props});

  tagval enum_tag_value = mk_enum_tag_value(mec->constructor_index);

  argtype *te_typeexpr;
  field_offset u32;
  tag_end u32;
  tag_cell cell_num;
  if case &TeEnum(et te_enum) = &mec->enum_type.~ {
    argtype = &ref(&et.constructors, mec->constructor_index)->type;
    field_offset = enum_field_offset(cs, &et, tagval);
    cu cu_typeexpr;
    props type_properties;
    compute_prim(cs, clq, enum_tag_type(cs, &et), &cu, &props);
    tag_end = props.flat_size;
    tag_cell = add_cell(&gr, {Has(LocationVirtual(void)), cu, props});
  } else {
    ice(_u8("magic_enum_construct on non-enum type"));
  }

  prepadding_ogn opt[gr_num]
    = gr_bzero_subcell(clq, &gr, retnum, tag_end, field_offset - tag_end);
  field_end u32 = field_offset + mec->rhs_props.flat_size;
  postpadding_ogn opt[gr_num]
    = gr_bzero_subcell(clq, &gr, retnum, field_end, mec->enum_type_props.flat_size - field_end);

  argnum cell_num = add_cell(&gr, {Has(LocationRigid(void)), ~ *argtype, mec->rhs_props});
  retpart cell_num = add_cell(&gr, {Has(LocationVirtual(void)), ~ *argtype, mec->rhs_props});

  var retpart_gn = add_node(&gr, node0(@[gr_op]GrSubcell({retpart, retnum, OffsetConst(field_offset)})));

  ctor_gn gr_num;
  switch &mec->operational {
  case &EnumConstructMove(cd ctor_desc):
    bi_ctor_gn gr_num;
    if !gr_bi_ctor(cs, clq, &gr, argtype, retpart, argnum, &cd, &bi_ctor_gn) {
      return false;
    }
    ctor_gn = add_node(&gr, node(mk_array(bi_ctor_gn), @[gr_op]GrDead({argnum})));

  case &EnumConstructCopyDestroy(cdd copy_destroy_desc):
    cpgn gr_num;
    if !gr_bi_ctor(cs, clq, &gr, argtype, retpart, argnum, &cdd.copy_desc, &cpgn) {
      return false;
    }
    destgn gr_num;
    if !gr_destroy_ctor(cs, clq, &gr, argtype, argnum, &cdd.destroy_desc, &destgn) {
      return false;
    }
    ctor_gn = add_node(&gr, node0(@[gr_op]GrSequence({cpgn, destgn})));
  }

  var assign_gn = add_node(&gr, node0(@[gr_op]GrSequence({retpart_gn, ctor_gn})));

  var tagcell_gn = add_node(&gr, node0(@[gr_op]GrSubcell({tag_cell, retnum, OffsetConst(enum_tag_offset)})));
  var tag_gn = add_node(&gr, node(mk_array(tagcell_gn), @[gr_op]GrWriteConst({tag_cell, ConstInt(~tagval.~)})));
  var gn = add_node(&gr, node(concat(@[opt[gr_num]]Has(tag_gn), prepadding_ogn, @[opt[gr_num]]Has(assign_gn), postpadding_ogn), GrNop(void)));
  *gr_out = gr;
  *gn_out = gn;
  *return_cell_out = retnum;
  *arg_cell_out = argnum;
  return true;
}

func gr_bi_ctor(cs *checkstate, clq *clqueue, gr *frame_graph, ty *te_typeexpr, destnum cell_num, srcnum cell_num, cd *ctor_desc, gn_out *gr_num) bool {
  switch cd {
  case &TrivialCtor(v void):
    var gn = add_node(gr, node0(@[gr_op]GrMemCopy({destnum, srcnum})));
    *gn_out = gn;
  case &FunCtor(ip instpair):
    pty te_typeexpr = ptr_type(cs, *ty);
    cu_pty cu_typeexpr;
    pty_props type_properties;
    compute_prim(cs, clq, pty, &cu_pty, &pty_props);
    voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

    functy te_typeexpr = fn_type(cs, pty, pty, voidtp.cu.~);
    cu_functy cu_typeexpr;
    functy_props type_properties;
    compute_prim(cs, clq, functy, &cu_functy, &functy_props);

    funcptr_cell cell_num = add_cell(gr, {Has(LocationRigid(void)), cu_functy, functy_props});
    destptr_cell cell_num = add_cell(gr, {Has(LocationRigid(void)), cu_pty, pty_props});
    srcptr_cell cell_num = add_cell(gr, {Has(LocationRigid(void)), cu_pty, pty_props});
    return_cell cell_num = add_cell(gr, {Has(LocationFlex(void)), voidtp.cu, voidtp.props});

    bi_desc bi_fun_ctor_desc = {ip, funcptr_cell, destptr_cell, srcptr_cell, return_cell};

    gn gr_num = gr_bi_fun_ctor_desc(cs, gr, &bi_desc, destnum, srcnum);
    *gn_out = gn;
  }
  return true;
}

func gr_destroy_ctor(cs *checkstate, clq *clqueue, gr *frame_graph, ty *te_typeexpr, argnum cell_num, cd *ctor_desc, gn_out *gr_num) bool {
  switch cd {
  case &TrivialCtor(v void):
    var dp = add_node(gr, node0(@[gr_op]GrDead({argnum})));
    *gn_out = dp;
  case &FunCtor(ip instpair):
    pty te_typeexpr = ptr_type(cs, *ty);
    cu_pty cu_typeexpr;
    pty_props type_properties;
    compute_prim(cs, clq, pty, &cu_pty, &pty_props);
    voidtp cu_typrop = compute_prim(clq, primitive_void_type(cs));

    functy te_typeexpr = fn_type(cs, pty, voidtp.cu.~);
    cu_functy cu_typeexpr;
    functy_props type_properties;
    compute_prim(cs, clq, functy, &cu_functy, &functy_props);

    funcptr_cell cell_num = add_cell(gr, {Has(LocationRigid(void)), cu_functy, functy_props});
    argptr_cell cell_num = add_cell(gr, {Has(LocationRigid(void)), cu_pty, pty_props});
    return_cell cell_num = add_cell(gr, {Has(LocationFlex(void)), voidtp.cu, voidtp.props});

    uni_desc uni_fun_ctor_desc = {ip, funcptr_cell, argptr_cell, return_cell};
    gn gr_num = gr_uni_fun_ctor_desc(cs, gr, &uni_desc, argnum);
    var dp = add_node(gr, node(mk_array(gn), @[gr_op]GrDead({argnum})));
    *gn_out = dp;
  }
  return true;
}


func ensure_def_inst_graphed(cs *checkstate, clq *clqueue, ent_id def_entry_id, inst_id def_inst_id) bool {
  if !ensure_def_inst_checked(cs, clq, ent_id, inst_id) {
    return false;
  }

  ent *def_entry = ref_def_entry(cs, ent_id);
  inst *def_inst = ref_inst(cs, inst_id);
  switch &inst->graph {
    case &NotComputed(v0 void): {
      inst->graph = BeganComputing();
      switch &inst->rhs {
        case &InstRhsPrim(op primitive_op): {
          id fn_body_id = add_fn_body(cs, {@[fn_body_entry_enum]PrimFnBody({op})});
          frg frame_regraphed = mk_const_frame_regraphed(&inst->computed_type, &inst->computed_type_properties, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return true;
        }
        case &InstRhsExtern(v void): {
          // TODO: What if an extern def isn't a function?
          id fn_body_id = add_fn_body(cs, {@[fn_body_entry_enum]ExternFnBody({ent->def_name})});
          frg frame_regraphed = mk_const_frame_regraphed(&inst->computed_type, &inst->computed_type_properties, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return true;
        }
        case &InstRhsExpr(dire def_inst_rhs_expr): {
          info *frame_info;
          if case &Has(finfo) = &dire.frame_info {
            info = &finfo;
          } else {
            ice(_u8("ensure_def_inst_graphed missing 'dire' info"));
          }
          gr frame_graph = init_frame_graph_from_cells(info->cells);
          gn gr_num;
          if !gr_expr_consume(cs, &gr, &dire.ec, &gn) {
            inst->graph = FailedComputation();
            return false;
          }
          inst->graph = Computed(Has(@[frame_regraphed]{gr, gn, result_cell(&dire.ec)}));
          return true;
        }

        case &InstRhsNonMagic(nonmag def_non_magic): {
          switch &nonmag {
          case &NonMagicCtor(wnmc which_non_magic_ctor):
            info *non_magic_ctor_info = unHas(&wnmc.nmc.info);
            frg frame_regraphed = mk_const_frame_regraphed(&inst->computed_type, &inst->computed_type_properties, ConstDef(info->ip));
            inst->graph = Computed(Has(frg));
            return true;
          case &NonMagicProp(nmp non_magic_prop):
            info u32 = *unHas(&nmp.info);
            frg frame_regraphed = mk_const_frame_regraphed(&inst->computed_type, &inst->computed_type_properties, @[gr_const]ConstInt(~info));
            inst->graph = Computed(Has(frg));
            return true;
          }
        }

        case &InstRhsMagic(mag def_magic): {
          id fn_body_id;
          if true {
            body_gr frame_graph;
            body_gn gr_num;
            return_cell cell_num;
            arg_cells array[cell_num];
            if !gr_magic(cs, clq, &mag, &body_gr, &body_gn, &return_cell, &arg_cells) {
              return false;
            }
            id = add_fn_body(cs, {@[fn_body_entry_enum]GraphedFnBody({FnBodyMagic(&mag), {body_gr, body_gn, return_cell}, arg_cells})});
          }

          frg frame_regraphed = mk_const_frame_regraphed(&inst->computed_type, &inst->computed_type_properties, ConstFnBody(id));
          inst->graph = Computed(Has(frg));
          return true;
        }
      }
    }
    case &BeganComputing(v void): {
      ice(_u8("ensure_def_inst_graphed recursively computing"));
      return fake();
    }
    case &FailedComputation(v void): {
      ERR(_u8("ensure_def_inst_graphed fails again on same def"));
      return false;
    }
    case &Computed(odr opt[frame_regraphed]): {
      return true;
    }
  }
}

func mk_const_frame_regraphed(type *cu_typeexpr, props *type_properties, c gr_const) frame_regraphed {
  gr frame_graph = init_frame_graph_empty();
  cell cell_num = add_cell(&gr, {Has(LocationRigid(void)), *type, *props});
  gn gr_num = add_node(&gr, node0(@[gr_op]GrWriteConst({cell, c})));
  return {gr, gn, cell};
}
