import state;

func dumbly_analyze_returning_expression(h *frame, gr *frame_graph, celltrack *gr_celltrack, gn gr_num) np {
  mbmut genexpr_result;
  if case Printed(pm) = dumbly_analyze_expression(h, gr, celltrack, gn, &mbmut) {
    return Printed(pm);
  }
  switch &mbmut {
  case &Terminal:
    return NoFail;
  case &NonTerminal:
    return ERR(_u8("ICE: Expecting terminal expression, for gn "), gn.x, _u8(" in "), lookup(h->im, gr->informal_name));
  }
}

enum genexpr_result {
  Terminal void;
  NonTerminal void;
}


func dumbly_analyze_expression(h *frame, gr *frame_graph, celltrack *gr_celltrack, gn gr_num, out *genexpr_result) np {
  gnc *gn_annot = ref_annot(h, gn);
  if case &Computed(checksum celltrack_checksum) = &gnc->plainly_live {
    // TODO: We should also check that we're part of the same sequential _family_ of exprs.
    if !matches_checksums(celltrack, &checksum) {
      return ERR(_u8("ICE: Inconsistent liveness/active state when revisiting node"));
    }
    *out = NonTerminal;
    return NoFail;
  }

  annotate(&gnc->plainly_live, get_checksum(celltrack));

  node *gr_node = ref_node(gr, gn);
  switch node {
  case &XOp(xn gr_xnode):
    switch &xn.op {
    case &GrApply(a gr_apply):
      // Retcell needs to be live _before_ the funcall happens.
      expect_live(celltrack, a.retcell);

      note_lower_paramlists(h, gn, celltrack);
      annotate_ref(&gnc->app_time_live, &celltrack->liveset);

      nparams size = count(&a.params);

      switch a.act {
      case TwoActiveOps(ops gr_two_active_ops):
        gr_track_active_op(celltrack, ops.one);
        gr_track_active_op(celltrack, ops.two);
      case StandardApply:
        gr_deactivate(celltrack, a.funcell);
        for i size = 0; i < nparams; i = i + 1 {
          gr_deactivate(celltrack, get(&a.params, i));
        }
        gr_activate(celltrack, a.retcell);
      }

      deaden(celltrack, a.funcell);
      for i size = 0; i < nparams; i = i + 1 {
        deaden(celltrack, get(&a.params, i));
      }
      *out = Terminal;
      return NoFail;

    case &GrPrimApply(a gr_prim_apply):
      expect_live(celltrack, a.retcell);

      nparams size = count(&a.params);
      for i size = 0; i < nparams; i = i + 1 {
        gr_deactivate(celltrack, get(&a.params, i));
      }
      gr_activate(celltrack, a.retcell);

      for i size = 0; i < nparams; i = i + 1 {
        deaden(celltrack, get(&a.params, i));
      }
      *out = Terminal;
      return NoFail;

    case &GrMemCopy(a gr_memcopy):
      expect_live(celltrack, a.dest);
      expect_live(celltrack, a.src);
      *out = Terminal;
      return NoFail;

    case &GrWriteConst(a gr_writeconst):
      expect_live(celltrack, a.dest);
      *out = Terminal;
      return NoFail;

    case &GrAddressof(a gr_addressof):
      expect_live(celltrack, a.addressee);
      expect_live(celltrack, a.dest);
      *out = Terminal;
      return NoFail;

    case &GrDeref(a gr_deref):
      expect_live(celltrack, a.pointer);
      check(!isLocationStatic(ref_cell(gr, a.name)->location));
      create(h, celltrack, a.name);
      *out = Terminal;
      return NoFail;

    case &GrSubcell(a gr_subcell):
      expect_live(celltrack, a.partof);
      check(!isLocationStatic(ref_cell(gr, a.name)->location));
      create(h, celltrack, a.name);
      *out = Terminal;
      return NoFail;

    case &GrLive(a gr_live):
      create(h, celltrack, a.cell);
      *out = Terminal;
      return NoFail;

    case &GrAssertLive(a gr_assert_live):
      expect_live(celltrack, a.cell);
      *out = Terminal;
      return NoFail;

    case &GrDead(a gr_dead):
      gr_expect_inactive(celltrack, a.cell);
      deaden(celltrack, a.cell);
      *out = Terminal;
      return NoFail;

    case &GrVirtualDead(a gr_virtual_dead):
      deaden(celltrack, a.cell);
      *out = Terminal;
      return NoFail;

    case &GrActiveXop(a gr_active_xop):
      gr_track_active_op(celltrack, a.op1);
      gr_track_active_op(celltrack, a.op2);
      *out = Terminal;
      return NoFail;

    case &GrManyActiveXop(a gr_many_active_xop):
      nops size = count(&a.ops);
      for i size = 0; i < nops; i = i + 1 {
        gr_track_active_op(celltrack, get(&a.ops, i));
      }
      *out = Terminal;
      return NoFail;
    }

  case &QOp(qn gr_qnode):
    switch &qn.op {
    case &GrBranch(a gr_branch):
      expect_live(celltrack, a.src);

      end_celltrack gr_celltrack;
      combined_mut genexpr_result = NonTerminal;
      ncases size = count(&a.cases);
      for i size = 0; i < ncases; i = i + 1 {
        cas *tup[gr_const, sq_num] = ref(&a.cases, i);
        new_live gr_celltrack = *celltrack;
        casmut genexpr_result;
        if case Printed(pm) = dumbly_analyze_expression(h, gr, &new_live, cas->cdr.x, &casmut) {
          return Printed(pm);
        }
        combine_branch_mut(&new_live, &combined_mut, casmut, &end_celltrack);
      }

      if case Has(def_gn sq_num) = a.default_case {
        new_live gr_celltrack = *celltrack;
        defcasmut genexpr_result;
        if case Printed(pm) = dumbly_analyze_expression(h, gr, &new_live, def_gn.x, &defcasmut) {
          return Printed(pm);
        }
        combine_branch_mut(&new_live, &combined_mut, defcasmut, &end_celltrack);
      }

      // Yes this is empty of it's NonTerminal -- it doesn't matter.
      *celltrack = end_celltrack;
      *out = combined_mut;
      return NoFail;

    case &GrSequence(a gr_sequence):
      if case Printed(pm) = dumbly_analyze_returning_expression(h, gr, celltrack, a.first) {
        return Printed(pm);
      }
      return dumbly_analyze_expression(h, gr, celltrack, a.second.x, out);

    case &GrJmp(a gr_jmp):
      return dumbly_analyze_expression(h, gr, celltrack, a.next.x, out);

    case &GrQNop:
      *out = Terminal;
      return NoFail;
    }
  }
}

func note_lower_paramlists(h *frame, our_gn gr_num, live_at_app_time *gr_celltrack) void {
  paramlists array[gr_num];
  nall size = count(&live_at_app_time->liveset.all);
  for i size = 0; i < nall; i = i + 1 {
    c cell_num = get(&live_at_app_time->liveset.all, i);
    if case Has(gn gr_num) = ref(&h->bas->celldisp, c.x)->paramlist {
      if gn != our_gn {
        push(&paramlists, gn);
        discard bool = try_insert(&ref_annot(h, gn)->higher_paramlists, &our_gn, void);
      }
    }
  }

  sort(&paramlists);
  dedup_sorted(&paramlists);
  annotate_move(&ref_annot(h, our_gn)->lower_paramlists, &paramlists);
}

func combine_branch_mut(new_live *gr_celltrack, onto *genexpr_result, case_mut genexpr_result, end_celltrack *gr_celltrack) void {
  switch case_mut {
  case Terminal:
    switch *onto {
    case Terminal:
      if !matches_checksums(new_live, end_celltrack) {
        ice(_u8("terminal/terminal new_live not equal, end_celltrack="), *end_celltrack, _u8(", new_live="), *new_live);
      }
    case NonTerminal:
      *onto = Terminal;
      *end_celltrack = *new_live;
    }
  case NonTerminal: { }
  }
}

// For deaden and other functions, prelive shows what was alive _before_ prec_muts modified it.
func deaden(celltrack *gr_celltrack, c cell_num) void {
  liveset *cellset = &celltrack->liveset;
  if !try_remove(&liveset->all, c) {
    ice(_u8("deaden on unlive cell "), c);
  }
  liveset->xored = liveset->xored ^ ~c.x;
  liveset->summed = liveset->summed - ~c.x;
}

func expect_live(celltrack *gr_celltrack, c cell_num) void {
  liveset *cellset = &celltrack->liveset;
  if case None = lookup(&liveset->all, c) {
    ice(_u8("expect_live on unlive cell "), c);
  }
}

func create(h *frame, celltrack *gr_celltrack, c cell_num) void {
  liveset *cellset = &celltrack->liveset;
  gr_create(liveset, c);
  note_conflicting(h, &liveset->all, c);
}

// Used in graph code because we don't note conflicting and don't have a frame (yet).
func gr_create(liveset *cellset, c cell_num) void {
  if !try_insert(&liveset->all, c) {
    ice(_u8("create on live cell "), c);
  }
  liveset->xored = liveset->xored ^ ~c.x;
  liveset->summed = liveset->summed + ~c.x;
}

func note_conflicting(h *frame, all *array[cell_num], c cell_num) void {
  // This also means conflicting is set to non-empty for any cell that's made live.
  c_disp *cell_disp = ref(&h->bas->celldisp, c.x);
  nall size = count(all);
  for i size = 0; i < nall; i = i + 1 {
    d cell_num = get(all, i);
    d_disp *cell_disp = ref(&h->bas->celldisp, d.x);
    push(&c_disp->conflicting, d);
    push(&d_disp->conflicting, c);
  }
}

func ref_annot(h *frame, gn gr_num) *gn_annot {
  return ref(&h->by_gn, gn.x);
}
